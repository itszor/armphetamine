Flat profile:

Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total           
 time   seconds   seconds    calls  ns/call  ns/call  name    
 30.90      2.12     2.12                             nativesupport_readword
 17.06      3.29     1.17  3205387   365.01   365.01  nativesupport_invoke
 16.33      4.41     1.12                             nativesupport_writeword
 10.93      5.16     0.75  3212158   233.49   803.71  block_gather
  9.33      5.80     0.64  3240082   197.53   197.53  hash_lookup
  4.96      6.14     0.34                             nativesupport_reconstructpc
  4.66      6.46     0.32                             nativesupport_readbyte
  4.52      6.77     0.31                             main
  0.73      6.82     0.05                             nativesupport_writebyte
  0.29      6.84     0.02     1170 17094.02 17094.02  exec_sdt
  0.15      6.85     0.01     5898  1695.49  1695.49  x86asm_out
  0.15      6.86     0.01      901 11098.78 11534.67  allocate_obtain
  0.00      6.86     0.00    13583     0.00     0.00  safemalloc
  0.00      6.86     0.00     9552     0.00   197.53  follow
  0.00      6.86     0.00     7399     0.00  2710.04  dispatch
  0.00      6.86     0.00     6770     0.00     0.00  exec_condition
  0.00      6.86     0.00     6691     0.00     0.00  addedge
  0.00      6.86     0.00     5933     0.00     0.00  list_add
  0.00      6.86     0.00     5390     0.00     0.00  list_removehead
  0.00      6.86     0.00     5331     0.00     0.00  hash_insert
  0.00      6.86     0.00     4219     0.00     0.00  queryreg
  0.00      6.86     0.00     3831     0.00  2838.27  allocate_reg
  0.00      6.86     0.00     3114     0.00     0.00  extend
  0.00      6.86     0.00     2794     0.00     0.00  exec_dp
  0.00      6.86     0.00     2432     0.00     0.00  codegen_rulify
  0.00      6.86     0.00     2264     0.00   197.53  codegen_addmapping
  0.00      6.86     0.00     2264     0.00  2591.04  codegen_match
  0.00      6.86     0.00     2264     0.00     0.00  pseudo_emit
  0.00      6.86     0.00     2096     0.00   835.61  allocate_cpyregtomem
  0.00      6.86     0.00     2093     0.00   376.69  allocate_preflags
  0.00      6.86     0.00     1910     0.00     0.00  allocate_npostfix
  0.00      6.86     0.00     1818     0.00   468.30  allocate_ensureflags
  0.00      6.86     0.00     1818     0.00  5328.33  allocate_setup
  0.00      6.86     0.00     1764     0.00     0.00  fake_syscall
  0.00      6.86     0.00     1764     0.00     0.00  riscos_swi
  0.00      6.86     0.00     1762     0.00     0.00  riscos_vdu
  0.00      6.86     0.00     1573     0.00     0.00  exec_dp_imm
  0.00      6.86     0.00     1369     0.00    10.60  allocate_postflags
  0.00      6.86     0.00      935     0.00     7.25  allocate_swap
  0.00      6.86     0.00      848     0.00     0.00  safecalloc
  0.00      6.86     0.00      841     0.00   745.85  allocate_nsolidify
  0.00      6.86     0.00      759     0.00     0.00  exec_bra
  0.00      6.86     0.00      747     0.00     0.00  pseudo_newtemp
  0.00      6.86     0.00      690     0.00   197.53  pseudo_addmapping
  0.00      6.86     0.00      690     0.00     0.00  pseudo_newpsminfo
  0.00      6.86     0.00      690     0.00     0.00  pseudo_psminfodestructor
  0.00      6.86     0.00      642     0.00     0.00  pseudo_condition
  0.00      6.86     0.00      599     0.00     0.00  hash_new
  0.00      6.86     0.00      572     0.00  1692.53  allocate_cpymemtoreg
  0.00      6.86     0.00      422     0.00     0.00  exec_bdt
  0.00      6.86     0.00      410     0.00  1452.04  allocate_coerce
  0.00      6.86     0.00      407     0.00     0.00  analyse_newbasicblock
  0.00      6.86     0.00      407     0.00 48578.98  codegen_inner
  0.00      6.86     0.00      407     0.00     0.00  pqueue_deleteitem
  0.00      6.86     0.00      407     0.00     0.00  pqueue_extract
  0.00      6.86     0.00      407     0.00     0.00  pqueue_heapify
  0.00      6.86     0.00      407     0.00     0.00  pqueue_insert
  0.00      6.86     0.00      407     0.00     0.00  pqueue_newitem
  0.00      6.86     0.00      373     0.00     0.00  pseudo_dp_guts
  0.00      6.86     0.00      366     0.00     0.00  allocate_rpop
  0.00      6.86     0.00      366     0.00  2365.28  allocate_rpush
  0.00      6.86     0.00      366     0.00 13574.46  generators_fncall
  0.00      6.86     0.00      261     0.00   197.53  pseudo_jmp
  0.00      6.86     0.00      248     0.00     0.00  hash_nuke
  0.00      6.86     0.00      222     0.00     0.00  block_new
  0.00      6.86     0.00      218     0.00    78.95  pseudo_dp
  0.00      6.86     0.00      179     0.00  2828.62  r_sub5
  0.00      6.86     0.00      176     0.00  2226.71  allocate_reset
  0.00      6.86     0.00      174     0.00   197.53  codegen_getinteladdr
  0.00      6.86     0.00      174     0.00   197.53  pseudo_getpsaddr
  0.00      6.86     0.00      166     0.00  2082.77  r_const0
  0.00      6.86     0.00      155     0.00    78.95  pseudo_dp_imm
  0.00      6.86     0.00      155     0.00 13574.46  r_ldw1
  0.00      6.86     0.00      146     0.00     0.00  codegen_merge
  0.00      6.86     0.00      146     0.00  2082.77  r_mov1
  0.00      6.86     0.00      139     0.00 13574.46  r_stw1
  0.00      6.86     0.00      123     0.00  2828.62  r_lsl3
  0.00      6.86     0.00      107     0.00    78.95  pseudo_sdt
  0.00      6.86     0.00       98     0.00    99.09  pseudo_bra
  0.00      6.86     0.00       92     0.00  9347.12  r_setpc0
  0.00      6.86     0.00       73     0.00  2828.62  r_cmp1
  0.00      6.86     0.00       68     0.00  2828.62  r_sub6
  0.00      6.86     0.00       66     0.00  2828.62  r_add6
  0.00      6.86     0.00       62     0.00  1296.66  analyse_block
  0.00      6.86     0.00       62     0.00     0.00  block_clean
  0.00      6.86     0.00       62     0.00 457956.27  block_dotranslation
  0.00      6.86     0.00       62     0.00 94614.89  codegen_matchblock
  0.00      6.86     0.00       62     0.00 426813.77  codegen_recompile
  0.00      6.86     0.00       62     0.00     0.00  pqueue_delete
  0.00      6.86     0.00       62     0.00     0.00  pqueue_new
  0.00      6.86     0.00       62     0.00     0.00  pseudo_deleteblock
  0.00      6.86     0.00       62     0.00     0.00  pseudo_newblock
  0.00      6.86     0.00       62     0.00     0.00  pseudo_reconstitutepc
  0.00      6.86     0.00       62     0.00 29648.31  pseudo_translateblock
  0.00      6.86     0.00       62     0.00  4298.89  r_end0
  0.00      6.86     0.00       62     0.00     0.00  x86asm_newnative
  0.00      6.86     0.00       56     0.00  2828.62  r_add5
  0.00      6.86     0.00       52     0.00  2477.82  r_bcc0
  0.00      6.86     0.00       48     0.00    78.95  pseudo_bdt
  0.00      6.86     0.00       46     0.00     0.00  exec_mul
  0.00      6.86     0.00       42     0.00 13951.14  r_reconstructpc0
  0.00      6.86     0.00       40     0.00  2082.77  r_mov2
  0.00      6.86     0.00       39     0.00  2477.82  r_bcs0
  0.00      6.86     0.00       35     0.00  2828.62  r_cmp2
  0.00      6.86     0.00       33     0.00  2828.62  r_add1
  0.00      6.86     0.00       32     0.00  2523.20  r_bne0
  0.00      6.86     0.00       26     0.00  2828.62  r_sub1
  0.00      6.86     0.00       22     0.00 13574.46  r_ldb1
  0.00      6.86     0.00       21     0.00  7137.16  r_xjmp0
  0.00      6.86     0.00       20     0.00  2828.62  r_add8
  0.00      6.86     0.00       18     0.00  2558.49  r_beq0
  0.00      6.86     0.00       17     0.00  2477.82  r_bpl0
  0.00      6.86     0.00       16     0.00  6965.45  r_sub2
  0.00      6.86     0.00       11     0.00  3778.26  r_add4
  0.00      6.86     0.00        7     0.00     0.00  exec_swi
  0.00      6.86     0.00        7     0.00 13574.46  r_stb1
  0.00      6.86     0.00        6     0.00  2828.62  r_and1
  0.00      6.86     0.00        6     0.00  2477.82  r_bgt0
  0.00      6.86     0.00        6     0.00  2828.62  r_eor2
  0.00      6.86     0.00        6     0.00  2082.77  r_mvn2
  0.00      6.86     0.00        5     0.00  2828.62  r_and6
  0.00      6.86     0.00        5     0.00  2828.62  r_lsr3
  0.00      6.86     0.00        5     0.00  2828.62  r_tst2
  0.00      6.86     0.00        4     0.00  4173.31  r_bhi0
  0.00      6.86     0.00        3     0.00  2828.62  r_and5
  0.00      6.86     0.00        2     0.00  3203.85  r_ble0
  0.00      6.86     0.00        2     0.00  2828.62  r_or5
  0.00      6.86     0.00        1     0.00     0.00  generators_register
  0.00      6.86     0.00        1     0.00     0.00  load_aout
  0.00      6.86     0.00        1     0.00     0.00  machine_create
  0.00      6.86     0.00        1     0.00     0.00  memory_initialise
  0.00      6.86     0.00        1     0.00    78.95  pseudo_mul
  0.00      6.86     0.00        1     0.00    78.95  pseudo_swi
  0.00      6.86     0.00        1     0.00  2477.82  r_bge0
  0.00      6.86     0.00        1     0.00  4173.31  r_bls0
  0.00      6.86     0.00        1     0.00  2477.82  r_blt0
  0.00      6.86     0.00        1     0.00  2477.82  r_bmi0
  0.00      6.86     0.00        1     0.00  2828.62  r_eor1
  0.00      6.86     0.00        1     0.00  2828.62  r_eor6
  0.00      6.86     0.00        1     0.00  1133.13  r_mov0
  0.00      6.86     0.00        1     0.00  3574.47  r_mul2
  0.00      6.86     0.00        1     0.00  2828.62  r_mvn1
  0.00      6.86     0.00        1     0.00  3778.26  r_or4
  0.00      6.86     0.00        1     0.00  3778.26  r_sub4
  0.00      6.86     0.00        1     0.00 16177.86  r_swi0
  0.00      6.86     0.00        1     0.00     0.00  registers_new
  0.00      6.86     0.00        1     0.00     0.00  riscos_initialise

 %         the percentage of the total running time of the
time       program used by this function.

cumulative a running sum of the number of seconds accounted
 seconds   for by this function and those listed above it.

 self      the number of seconds accounted for by this
seconds    function alone.  This is the major sort for this
           listing.

calls      the number of times this function was invoked, if
           this function is profiled, else blank.
 
 self      the average number of milliseconds spent in this
ms/call    function per call, if this function is profiled,
	   else blank.

 total     the average number of milliseconds spent in this
ms/call    function and its descendents per call, if this 
	   function is profiled, else blank.

name       the name of the function.  This is the minor sort
           for this listing. The index shows the location of
	   the function in the gprof listing. If the index is
	   in parenthesis it shows where it would appear in
	   the gprof listing if it were to be printed.

*** File /home/jules/ARMemu/armemu/fakesys.c:
                #include <stdio.h>
                #include <sys/syscall.h>
                #include <sys/types.h>
                #include <sys/stat.h>
                
                #include "defs.h"
                #include "machine.h"
                #include "decode.h"
                #include "memory.h"
                #include "registers.h"
                #include "processor.h"
                #include "execute.h"
                #include "fakesys.h"
                #include "riscos.h"
                
                // this doesn't work and is clearly The Wrong Thing To Do
                #undef FAKE_NETBSD
                
                #ifdef FAKE_NETBSD
                
                // Evil macro; get syscall argument number 'X'
                #define ARG(X) (temp=indirect?(X)+1:(X), temp<4?GET(temp):\
                  *memory_lookup(machine->mem, (uint5*)(GET(13)+(temp-4)*4)))
                
                void fake_syscall(machineinfo* machine, uint5 number)
                {
                	registerinfo* reg = machine->reg;
                	int indirect = (number==0 || number==198), temp;
                	int x, sysno = indirect ? GET(0) : number;
                	
                	for (x=0; x<16; x++)
                	{
                	  fprintf(stderr, "r%d=%d ", x, GET(x));
                	}
                	puts("");
                
                	switch (sysno)
                	{
                		case 0x3:      // SYS_read
                #ifdef VERBOSESYSCALL
                    fprintf(stderr, "syscall read() made\n");
                #endif
                		PUT(0, (uint5)read(ARG(0), (void*)memory_lookup(machine->mem,
                		  (uint5*)ARG(1)), (size_t)ARG(2)));
                		break;
                
                		case 0x4:      // SYS_write
                #ifdef VERBOSESYSCALL
                    fprintf(stderr, "syscall write() made\n");
                #endif
                    fprintf(stderr, "  write(%d,%x,%d)\n", ARG(0), ARG(1), ARG(2));
                		PUT(0, (uint5)write(ARG(0), (const void*)memory_lookup(machine->mem,
                		  (uint5*)ARG(1)), (size_t)ARG(2)));
                		break;
                		
                		case 0x11:
                #ifdef VERBOSESYSCALL
                		fprintf(stderr, "syscall break() made (0x11)\n");
                #endif
                    // 'brk' supposedly returns 0 on success, so here goes...
                		PUT(0,1024*1024);
                		break;
                		
                		case 0x3a:   // readlink
                #ifdef VERBOSESYSCALL
                		fprintf(stderr, "called readlink(%s,%x,%d)\n",
                		  (char*)memory_lookup(machine->mem, (uint5*)ARG(0)), ARG(1), ARG(2));
                #endif
                		PUT(0, readlink((const char*)ARG(0), (char*)ARG(1), (size_t)ARG(2)));
                		break;
                		
                		case 0xc5:   // mmap
                		{
                		  static uint5 mapbase = 1024*1024;
                	//		struct stat sb;
                		  fprintf(stderr, "Passed args: %x,%d,%d,%d,%d,%d\n", ARG(0), ARG(1), 
                			  ARG(2), ARG(3), ARG(4), ARG(5));
                		/*	fstat(ARG(4), &sb);
                			fprintf(stderr, "sb.st_size=%d\n", sb.st_size);*/
                		  PUT(0,mapbase);
                		}
                		break;
                		
                		case 0xca:
                #ifdef VERBOSESYSCALL
                		fprintf(stderr, "syscall sysctl() made (0xca)\n");
                #endif
                    {
                		  uint5* name = (uint5*)ARG(0);
                			uint5 nlen = ARG(1);
                			void* oldval = (void*)ARG(2);
                			size_t* oldlen = (size_t*)ARG(3);
                			void* newp = (void*)ARG(4);
                			size_t newlen = (size_t)ARG(5);
                    	fprintf(stderr, "  sysctl(%x,%d,%x,%x,%x,%d)\n",
                		  	name, nlen, oldval, oldlen, newp, newlen);
                			switch (*memory_lookup(machine->mem, name))
                			{
                			  case 0:
                				fprintf(stderr, "Ignoring top-level name zero (unused?)\n");
                				break;
                				
                			  case 6:     // CTL_HW, generic CPU/IO
                				switch (*memory_lookup(machine->mem, &name[1]))
                				{
                				  case 7:      // HW_PAGESIZE
                					PUT(0, 4096);   // pick a number, any number...
                					break;
                					
                					default:
                  				printf("Next-level name for CTL_HW=%d (unsupported)\n",
                					  *memory_lookup(machine->mem, &name[1]));
                					exit(1);
                				}
                				break;
                				
                			  default:
                				fprintf(stderr, "Top-level name=%d (unsupported)\n",
                				  *memory_lookup(machine->mem, name));
                				exit(1);
                			}
                		}
                		break;
                		
                		case 0x117:
                #ifdef VERBOSESYSCALL
                		fprintf(stderr, "syscall fstat(%d,%x) made (0x117)\n", ARG(0), ARG(1));
                #endif
                //		fstat((int)ARG(0),(struct stat*)ARG(1));
                		PUT(0,0);   // successful...
                		break;
                		
                		default:
                		fprintf(stderr, "Unrecognized SWI! (%x)\n", sysno);
                	}
                }
                #else
                
                void fake_syscall(machineinfo* machine, uint5 number)
        1764 -> {
                /*  switch (number)
                	{
                	  case 0:  // putchar
                		putchar(reg->r[0]);
                		break;
                	}*/
                  
                  riscos_swi(riscosstate, machine->mem, machine->reg, number);
                }	
                
                #endif
                


Top 10 Lines:

     Line      Count

      140       1764

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

     1764   Total number of line executions
  1764.00   Average executions per line


*** File /home/jules/ARMemu/armemu/machine.c:
                #include "cnew.h"
                #include "machine.h"
                #include "hash.h"
                #include "block.h"
                
                machineinfo* machine_create(uint5 memory)
           1 -> {
                	machineinfo* machine = cnew(machineinfo);
                	
                	machine->mem = memory_initialise(memory);
                	machine->reg = registers_new();
                //	machine->x86flags.value = 0;
                	machine->blocks = hash_new(17001);  // pick a number...
                	machine->live = 0;
                	machine->translaterules = 0;
                	
                	return machine;
                }


Top 10 Lines:

     Line      Count

        7          1

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        1   Total number of line executions
     1.00   Average executions per line


*** File /home/jules/ARMemu/armemu/decode3.c:
                #include "machine.h"
                #include "decode.h"
                #include "disassemble.h"
                #include "execute.h"
                #include "pseudo.h"
                
                // disassembler function table
                insttab diss = {
                	diss_dp,
                	diss_dp_imm,
                	diss_mul,
                	diss_sdt,
                	diss_bdt,
                	diss_bra,
                	diss_swi,
                	diss_cdt,
                	diss_cdo,
                	diss_crt,
                	diss_sds,
                	diss_und
                };
                
                // execution function table
                insttab exec = {
                	exec_dp,
                	exec_dp_imm,
                	exec_mul,
                	exec_sdt,
                	exec_bdt,
                	exec_bra,
                	exec_swi,
                	exec_cdt,
                	exec_cdo,
                	exec_crt,
                	exec_sds,
                	exec_und
                };
                
                // intermediate code translator function table
                insttab pseudo = {
                  pseudo_dp,
                	pseudo_dp_imm,
                	pseudo_mul,
                	pseudo_sdt,
                	pseudo_bdt,
                	pseudo_bra,
                	pseudo_swi,
                	pseudo_cdt,
                	pseudo_cdo,
                	pseudo_crt,
                	pseudo_sds,
                	pseudo_und
                };
                
                // Tree-shaped instruction dispatch
                void dispatch(machineinfo* machine, instructionformat inst, insttab* action,
                              void* data)
        7399 -> {
                	switch (inst.generic.type)
                	{
                		case 0:	// either data processing op, PSR tranfer or multiply
                		{
                			if (inst.mul.ident2==0 && inst.mul.ident==9)
                			{
                				// it's a multiply
                				action->mul(machine, inst, data);
                			}
                			else
                			{
                				action->dp(machine, inst, data);
                			}
                		}
                		break;
                		
                		case 1: // single data swap/DP
                		{
                			if (inst.sds.ident3==2 && inst.sds.ident2==0 && inst.sds.ident==9)
                			{
                			  // it's a single data swap
                				action->sds(machine, inst, data);
                			}
                			else
                			{
                				action->dp(machine, inst, data);
                			}
                		}
                		break;
                		
                		case 2: // DP (immediate operand)
                		case 3: // ditto
                		{
                			action->dp_imm(machine, inst, data);
                		}
                		break;
                		
                		case 4: // single data transfer
                		case 5: // SDT
                		{
                			action->sdt(machine, inst, data);
                		}
                		break;
                		
                		case 6: // SDT/undefined
                		case 7: // ditto
                		{
                			action->sdt(machine, inst, data);
                		}
                		break;
                		
                		case 8: // Block data transfer
                		case 9: // ditto
                		{
                			action->bdt(machine, inst, data);
                		}
                		break;
                		
                		case 10: // Branch
                		{
                			action->bra(machine, inst, data);
                		}
                		break;
                		
                		case 11: // Branch-with-link
                		{
                			action->bra(machine, inst, data);
                		}
                		break;
                		
                		case 12: // Coproc data transfer
                		case 13: // ditto
                		{
                		  action->cdt(machine, inst, data);
                		}
                		break;
                		
                		case 14: // Coproc data operation/register transfer
                		{
                		  if (inst.cdo.ident)
                			{
                		    action->crt(machine, inst, data);
                			}
                			else
                			{
                			  action->cdo(machine, inst, data);
                			}
                		}
                		break;
                		
                		case 15: // Software interrupt
                		{
                			action->swi(machine, inst, data);
                		}
                		break;
                	}
                }


Top 10 Lines:

     Line      Count

       58       7399

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

     7399   Total number of line executions
  7399.00   Average executions per line


*** File /home/jules/ARMemu/armemu/registers.c:
                #include <stdio.h>
                
                #include "cnew.h"
                #include "defs.h"
                #include "registers.h"
                
                registerinfo* registers_new(void)
           1 -> {
                	registerinfo* reg = cnew(registerinfo);
                	int i;
                	
                	for (i=0; i<16; i++) reg->r[i] = 0;
                
                	fprintf(stderr, "Initialised register bank\n");
                	
                	return reg;
                }


Top 10 Lines:

     Line      Count

        8          1

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        1   Total number of line executions
     1.00   Average executions per line


*** File /home/jules/ARMemu/armemu/cnew.c:
                #include <stdlib.h>
                #include <stdio.h>
                
                #include "cnew.h"
                
                void* safemalloc(size_t bytes)
       13583 -> {
                  void* mem = malloc(bytes);
                
                  if (!mem)
                  {
                    fprintf(stderr, "Out of memory!\n");
                    exit(1);
                  }
                
                  return mem;
                }
                
                void* safecalloc(size_t bytes, size_t num)
         848 -> {
                  void* mem = calloc(bytes, num);
                
                  if (!mem)
                  {
                    fprintf(stderr, "Out of memory!\n");
                    exit(1);
                  }
                
                  return mem;
                }


Top 10 Lines:

     Line      Count

        7      13583
       20        848

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

    14431   Total number of line executions
  7215.50   Average executions per line


*** File /home/jules/ARMemu/armemu/execute.c:
                #include <stdio.h>
                #include <sys/syscall.h>
                #include <sys/stat.h>
                
                #include "defs.h"
                #include "machine.h"
                #include "memory.h"
                #include "registers.h"
                #include "processor.h"
                #include "execute.h"
                #include "fakesys.h"
                #include "decode.h"
                
                int exec_condition(machineinfo* machine, instructionformat inst)
        6770 -> {
                	registerinfo* reg = machine->reg;
                  // conditional execution on any instruction
                  switch (inst.generic.cond)
                  {
                    case cc_EQ:  // Z set
                    if (!FLAG(z)) {
                      INCPC;
                      return 0;
                    }
                    break;
                
                    case cc_NE:  // Z clear
                    if (FLAG(z)) {
                      INCPC;
                      return 0;
                    }
                    break;
                
                    case cc_CS:  // C set (unsigned higher or same)
                    if (!FLAG(c)) {
                      INCPC;
                      return 0;
                    }
                    break;
                
                    case cc_CC:  // C clear (unsigned lower)
                    if (FLAG(c)) {
                      INCPC;
                      return 0;
                    }
                    break;
                
                    case cc_MI:  // N set (negative)
                    if (!FLAG(n)) {
                      INCPC;
                      return 0;
                    }
                    break;
                
                    case cc_PL:  // N clear (positive or zero)
                    if (FLAG(n)) {
                      INCPC;
                      return 0;
                    }
                    break;
                
                    case cc_VS:  // V set (overflow)
                    if (!FLAG(v)) {
                      INCPC;
                      return 0;
                    }
                    break;
                
                    case cc_VC:  // V clear (overflow)
                    if (FLAG(v)) {
                      INCPC;
                      return 0;
                    }
                    break;
                
                    case cc_HI:  // C set and Z clear (unsigned higher)
                    if (!FLAG(c) || FLAG(z)) {
                      INCPC;
                      return 0;
                    }
                    break;
                
                    case cc_LS:  // C clear or Z set (unsigned lower or same)
                    if (FLAG(c) && !FLAG(z)) {
                      INCPC;
                      return 0;
                    }
                    break;
                
                    case cc_GE:  // N set and V set, or N clear and V clear (greater or equal)
                    if (FLAG(n) ^ FLAG(v)) {
                      INCPC;
                      return 0;
                    }
                    break;
                
                    case cc_LT:  // N set and V clear, or N clear and V set (less than)
                    if (!(FLAG(n) ^ FLAG(v))) {
                      INCPC;
                      return 0;
                    }
                    break;
                
                    case cc_GT:  // Z clear, and either N set and V set, or N clear and V clear (greater than)
                    if (FLAG(z) || (FLAG(n) ^ FLAG(v))) {
                      INCPC;
                      return 0;
                    }
                    break;
                
                    case cc_LE:  // Z set, or N set and V clear, or N clear and V set (less than or equal)
                    if (!FLAG(z) && !(FLAG(n) ^ FLAG(v))) {
                      INCPC;
                      return 0;
                    }
                    break;
                
                    case cc_AL:  // always
                    break;
                
                    case cc_NV:  // never
                    INCPC;
                    return 0;
                  }
                  return 1;
                }
                
                // execute an ALU instruction with op2 as a shifted register
                void exec_dp(machineinfo* machine, instructionformat inst, void* null)
        2794 -> {
                  registerinfo* reg = machine->reg;
                  uint5 op2 = 0, temp = inst.dp.operand2;
                  // for register shift & op1==PC, instruction+12 is used
                  uint3 regshift = (temp & 16) ? 1 : 0;
                  uint5 op1 = (inst.dp.rn==15 && regshift) ? GET(inst.dp.rn)+4
                                                           : GET(inst.dp.rn);
                  uint5 rd = 0;
                  // mask for logic rather than arithmetic instructions
                  const uint5 logic = 0xf303;
                  // mask for rd-affecting instructions
                  const uint5 affectrd = 0xf0ff;
                  // I suppose this should be...
                  uint5 rm = ((temp&15)==15 && regshift) ? GET(temp&15)+4 : GET(temp&15);
                  uint5 shifttype = (temp>>5)&3, amount, tamount;
                  // islogic affects the way the carry flag is set
                  int islogic = logic & (1<<inst.dp.opcode);
                
                  if (!exec_condition(machine, inst)) return;
                
                  if (regshift)  // shift by register
                  {
                    amount = RGET(temp>>8) & 0xff; // only the least significant byte
                    
                    switch (shifttype)  // register shift operations
                    {
                      case 0:  // logical left/no shift
                      {
                        op2 = amount>31 ? 0 : rm<<amount;
                        if (islogic && amount && inst.dp.s)
                        {
                          FLAG(c) = amount>31 ? 0 : rm & (1U<<(32-amount)) ? 1 : 0;
                        }
                      }
                      break;
                      
                      case 1:  // logical right
                      {
                        op2 = amount>31 ? 0 : rm>>amount;
                        if (islogic && amount && inst.dp.s)
                        {
                          FLAG(c) = amount>32 ? 0 : rm & (1U<<(amount-1)) ? 1 : 0;
                        }
                      }
                      break;
                      
                      case 2:  // arithmetic right
                      {
                        op2 = amount>31 ? (rm&TOPBIT ? 0xffffffff : 0)
                                        : (uint5)((sint5)rm>>amount);
                        if (islogic && amount && inst.dp.s)
                        {
                          FLAG(c) = amount>32 ? (rm>>31) : rm & (1U<<(amount-1)) ? 1 : 0;
                        }
                      }
                      break;
                      
                      case 3:  // rotate right (no rrx for register shift)
                      {
                        amount &= 31;
                        op2 = ROR(rm, amount);
                        if (islogic && inst.dp.s)
                        {
                          if (!amount) amount=32;
                          FLAG(c) = (rm & (1U<<(amount-1))) ? 1 : 0;
                        }
                      }
                    }
                  }
                  else   // shift by immediate
                  {
                    tamount = amount = temp>>7;
                    
                    switch (shifttype)
                    {
                      case 0:  // logical left/no shift
                      {
                        op2 = amount ? rm<<amount : rm;
                        if (islogic && amount && inst.dp.s)
                        {
                          FLAG(c) = rm & (1U<<(32-amount)) ? 1 : 0;
                        }
                      }
                      break;
                      
                      case 1:  // logical right
                      {
                        op2 = amount ? rm>>amount : 0;
                        if (islogic && inst.dp.s)
                        {
                          if (!amount) amount=32;
                          FLAG(c) = rm & (1U<<(amount-1)) ? 1 : 0;
                        }
                      }
                      break;
                      
                      case 2:  // arithmetic right
                      {
                        op2 = amount ? (uint5)((sint5)rm>>amount) :
                              (rm&TOPBIT ? 0xffffffff : 0);
                        if (islogic && inst.dp.s)
                        {
                          if (!amount) amount=32;
                          FLAG(c) = rm & (1U<<(amount-1)) ? 1 : 0;
                        }
                      }
                      break;
                      
                      case 3:  // rotate right/rrx
                      {
                        if (amount==0)  // rrx
                        {
                          op2 = (rm>>1) | (FLAG(c)<<31);
                          if (islogic && inst.dp.s) FLAG(c) = rm & 1;  // also if !logic?
                        }
                        else
                        {
                          op2 = ROR(rm, amount);
                          if (islogic && inst.dp.s)
                          {
                            if (!amount) amount=32;
                            FLAG(c) = (rm & (1U<<(amount-1))) ? 1 : 0;
                          }
                        }
                      }
                    }
                  }
                	
                  switch (inst.dp.opcode)
                  {
                    case dp_AND:
                    {
                      rd = op1 & op2;
                      STOREREG(dp, rd);
                    }
                    break;
                
                    case dp_EOR:
                    {
                      rd = op1 ^ op2;
                      STOREREG(dp, rd);
                    }
                    break;
                
                    case dp_SUB:
                    {
                      rd = op1 - op2;
                      if (inst.dp.s) { SUBFLAGS(op1,op2); }
                      STOREREG(dp, rd);
                    }
                    break;
                
                    case dp_RSB:
                    {
                      rd = op2 - op1;
                      if (inst.dp.s) { SUBFLAGS(op2,op1); }
                      STOREREG(dp, rd);
                    }
                    break;
                
                    case dp_ADD:
                    {
                      rd = op1 + op2;
                      if (inst.dp.s) { ADDFLAGS(op1,op2); }
                      STOREREG(dp, rd);
                    }
                    break;
                
                    case dp_ADC:
                    {
                      rd = op1 + op2 + FLAG(c);
                      if (inst.dp.s) { ADDFLAGS(op1,op2); }
                      STOREREG(dp, rd);
                    }
                    break;
                
                    case dp_SBC:
                    {
                      rd = op1 - op2 - !FLAG(c);
                      if (inst.dp.s) { SUBFLAGS(op1,op2); }
                      STOREREG(dp, rd);
                    }
                    break;
                
                    case dp_RSC:
                    {
                      rd = op2 - op1 - !FLAG(c);
                      if (inst.dp.s) { SUBFLAGS(op2,op1); }
                      STOREREG(dp, rd);
                    }
                    break;
                
                    case dp_TST:
                    {
                      rd = op1 & op2;
                    }
                    break;
                
                    case dp_TEQ:
                    {
                      rd = op1 ^ op2;
                    }
                    break;
                
                    case dp_CMP:
                    {
                      rd = op1 - op2;
                      SUBFLAGS(op1,op2);  // always affect flags
                    }
                    break;
                
                    case dp_CMN:
                    {
                      rd = op1 + op2;
                      ADDFLAGS(op1,op2);  // always affect flags
                    }
                    break;
                
                    case dp_ORR:
                    {
                      rd = op1 | op2;
                      STOREREG(dp, rd);
                    }
                    break;
                
                    case dp_MOV:
                    {
                      rd = op2;
                      STOREREG(dp, rd);
                    }
                    break;
                
                    case dp_BIC:
                    {
                      rd = op1 & ~op2;
                      STOREREG(dp, rd);
                    }
                    break;
                
                    case dp_MVN:
                    {
                      rd = ~op2;
                      STOREREG(dp, rd);
                    }
                    break;
                  }
                  // deal with Z and N flags
                  if (inst.dp.s) { ZNFLAGS; }
                
                  if (inst.dp.rd==15 && (affectrd & (1<<inst.dp.opcode)))
                    reg->r[15]+=8;
                  else
                    INCPC;
                }
                
                void exec_dp_imm(machineinfo* machine, instructionformat inst, void* null)
        1573 -> {
                  registerinfo* reg = machine->reg;
                  uint5 op1 = GET(inst.dp.rn);
                  uint5 op2, temp = inst.dp.operand2;
                  uint5 rd = 0, amount = (temp>>8)*2;
                  // mask for rd-affecting instructions
                  const uint5 affectrd = 0xf0ff;
                
                  if (!exec_condition(machine, inst)) return;
                
                  op2 = ROR(temp&255, amount);
                  // why isn't this more clear in the data sheet? grr...
                  if (inst.dp.s && amount) FLAG(c) = (temp & (1U<<(amount-1))) ? 1 : 0;
                
                  switch (inst.dp.opcode)
                  {
                    case dp_AND:
                    {
                      rd = op1 & op2;
                      STOREREG(dp, rd);
                    }
                    break;
                
                    case dp_EOR:
                    {
                      rd = op1 ^ op2;
                      STOREREG(dp, rd);
                    }
                    break;
                
                    case dp_SUB:
                    {
                      rd = op1 - op2;
                      if (inst.dp.s) { SUBFLAGS(op1,op2); }
                      STOREREG(dp, rd);
                    }
                    break;
                
                    case dp_RSB:
                    {
                      rd = op2 - op1;
                      if (inst.dp.s) { SUBFLAGS(op2,op1); }
                      STOREREG(dp, rd);
                    }
                    break;
                
                    case dp_ADD:
                    {
                      rd = op1 + op2;
                      if (inst.dp.s) { ADDFLAGS(op1,op2); }
                      STOREREG(dp, rd);
                    }
                    break;
                
                    case dp_ADC:
                    {
                      rd = op1 + op2 + FLAG(c);
                      if (inst.dp.s) { ADDFLAGS(op1,op2); }
                      STOREREG(dp, rd);
                    }
                    break;
                
                    case dp_SBC:
                    {
                      rd = op1 - op2 - !FLAG(c);
                      if (inst.dp.s) { SUBFLAGS(op1,op2); }
                      STOREREG(dp, rd);
                    }
                    break;
                
                    case dp_RSC:
                    {
                      rd = op2 - op1 - !FLAG(c);
                      if (inst.dp.s) { SUBFLAGS(op2,op1); }
                      STOREREG(dp, rd);
                    }
                    break;
                
                    case dp_TST:
                    {
                      rd = op1 & op2;
                    }
                    break;
                
                    case dp_TEQ:
                    {
                      rd = op1 ^ op2;
                    }
                    break;
                
                    case dp_CMP:
                    {
                      rd = op1 - op2;
                      SUBFLAGS(op1,op2);  // always affect flags
                    }
                    break;
                
                    case dp_CMN:
                    {
                      rd = op1 + op2;
                      ADDFLAGS(op1,op2);  // always affect flags
                    }
                    break;
                
                    case dp_ORR:
                    {
                      rd = op1 | op2;
                      STOREREG(dp, rd);
                    }
                    break;
                
                    case dp_MOV:
                    {
                      rd = op2;
                      STOREREG(dp, rd);
                    }
                    break;
                
                    case dp_BIC:
                    {
                      rd = op1 & ~op2;
                      STOREREG(dp, rd);
                    }
                    break;
                
                    case dp_MVN:
                    {
                      rd = ~op2;
                      STOREREG(dp, rd);
                    }
                    break;
                  }
                  // deal with Z and N flags
                  if (inst.dp.s) { ZNFLAGS; }
                
                  if (inst.dp.rd==15 && (affectrd & (1<<inst.dp.opcode)))
                    reg->r[15]+=8;
                  else
                    INCPC;
                }
                
                void exec_bra(machineinfo* machine, instructionformat inst, void* null)
         759 -> {
                  registerinfo* reg = machine->reg;
                  sint5 offset = (sint5)(inst.bra.offset<<8)>>6;
                  offset+=8;
                
                  if (offset==0) exit(0);
                
                  if (!exec_condition(machine, inst)) return;
                
                  // PC now holds actual instruction+8 bytes, same as a real ARM
                  if (inst.bra.l) RPUT(14, RGET(15)-4);  // prefetch adjustment
                  RPUT(15, RGET(15)+offset);
                }
                
                void exec_mul(machineinfo* machine, instructionformat inst, void* null)
          46 -> {
                  registerinfo* reg = machine->reg;
                  uint5 op1 = RGET(inst.mul.rm), op2 = RGET(inst.mul.rs), rd;
                
                  if (!exec_condition(machine, inst)) return;
                
                  if (inst.mul.a)  // accumulate bit set
                  {
                    rd = op1*op2+RGET(inst.mul.rn);
                  }
                  else
                  {
                    rd = op1*op2;
                  }
                  RPUT(inst.mul.rd, rd);
                  if (inst.mul.s) { ZNFLAGS; }
                  INCPC;
                }
                
                void exec_sdt(machineinfo* machine, instructionformat inst, void* null)
        1170 -> {
                	registerinfo* reg = machine->reg;
                	meminfo* mem = machine->mem;
                	uint5* base = (uint5*)GET(inst.sdt.rn), *addr, *alignaddr;
                	uint5 byteoffset;
                	sint5 offset = 0;
                
                	if (!exec_condition(machine, inst)) return;
                
                	if (inst.sdt.i)
                	{
                		uint5 temp = inst.sdt.offset;
                		uint5 rm = GET(temp&15), shifttype = (temp>>5)&3, amount = (temp>>7);
                
                		switch (shifttype)
                		{
                			case 0:  // LSL / no shift
                			{
                				offset = amount ? rm<<amount : rm;
                			}
                			break;
                
                			case 1:  // LSR
                			{
                				offset = amount ? rm>>amount : 0;
                			}
                			break;
                
                			case 2:  // ASR
                			{
                				offset = amount ? (uint5)((sint5)rm>>amount)
                                        : ((rm&TOPBIT) ? 0xffffffff : 0);
                			}
                			break;
                
                			case 3:  // ROR + RRX (only a sick person would use RRX here, right?)
                			{
                				offset = (amount==0) ? (rm>>1) | (FLAG(c)<<31) : ROR(rm, amount);
                			}
                			break;
                		}
                	}
                	else  // 'i' bit zero, is immediate offset
                	{
                		offset = inst.sdt.offset;
                	}
                
                	if (!inst.sdt.u) offset = -offset;
                
                	if (inst.sdt.p)  // pre-indexed if 1
                		base = (uint5*)(((uint5)base)+offset);
                
                	addr = memory_lookup(mem, base);
                	alignaddr = (uint5*)((uint5)addr&~3);
                	byteoffset = (uint5)addr & 3;
                
                	if (inst.sdt.l)  // load
                	{
                		if (inst.sdt.b)
                		{
                			uint3* caddr = (uint3*) addr;
                			RPUT(inst.sdt.rd, (uint5) *caddr);
                		}
                		else
                		{
                			if (byteoffset) PUT(inst.sdt.rd, ROR(*alignaddr, byteoffset*8));
                			else PUT(inst.sdt.rd, *alignaddr);
                		}
                	}
                	else  // store
                	{
                	  // STR PC stores PC+12
                	  uint5 src = inst.sdt.rd==15 ? RGET(inst.sdt.rd)+4 : RGET(inst.sdt.rd);
                		if (inst.sdt.b)
                		{
                			uint3* caddr = (uint3*) addr;
                			*caddr = (unsigned char) src;
                		}
                		else
                		{
                			*alignaddr = src;
                		}
                    #ifdef VIRTUALFRAMEBUFFER
                    memory_postwrite(mem, base);
                    #endif
                	}
                
                	if (!inst.sdt.p)  // post-index addressing
                	{
                    // logic previously broke on, eg, ldr r5,[r5],#0
                		RPUT(inst.sdt.rn, RGET(inst.sdt.rn)+offset);
                	}
                
                	if (inst.sdt.w)  // writeback address into base
                	{
                		RPUT(inst.sdt.rn, (uint5)base);
                	}
                
                  // pipelining correction  
                  if (inst.sdt.l && inst.sdt.rd==15)
                    reg->r[15]+=8;
                  else
                    INCPC;
                }
                
                // macros relating to block data transfer
                /*
                #define TESTOVERLAP if ((uint5)prev>>12 != (uint5)physbase>>12) \
                                      physbase = memory_lookup(mem, base)
                */
                // we're living in a flat address space for now - no overlap testing necessary
                #define TESTOVERLAP 
                #define INC base++; physbase++;
                #define DEC base--; physbase--;
                #define TRANSFER if (inst.bdt.l) PUT(i, *physbase); \
                                   else *physbase = GET(i);
                // inst.bdt.s means 'hat'
                // if writing PC, writes *the raw value* (don't know if this is correct)
                #define PCTRANSFER if (inst.bdt.l) \
                                     if (inst.bdt.s) PCSETADFL(*physbase); \
                                       else PCSETADDR(*physbase); \
                                   else *physbase = reg->r[15];
                
                // block data transfer always tries to use ready-translated address unless
                // straddling a page boundary
                void exec_bdt(machineinfo* machine, instructionformat inst, void* null)
         422 -> {
                	registerinfo* reg = machine->reg;
                	meminfo* mem = machine->mem;
                  uint5* base = (uint5*)GET(inst.bdt.rn);
                  int i;
                
                	if (!exec_condition(machine, inst)) return;
                
                  if (inst.bdt.u)    // transfer registers upwards in memory
                  {
                    uint5 *prev, *physbase = (uint5*)((uint5)memory_lookup(mem, base)&~3);
                    if (inst.bdt.p)  // preincrement
                    {
                      for (i=0; i<15; i++)
                      {
                        if (inst.bdt.reglist & (1<<i))
                        {
                          prev = physbase;
                          INC;
                          TESTOVERLAP;
                          TRANSFER;
                        }
                      }
                      if (inst.bdt.reglist & (1<<15))
                      {
                        prev = physbase;
                        INC;
                        TESTOVERLAP;
                        PCTRANSFER;
                      }
                    }
                    else  // postincrement
                    {
                      for (i=0; i<15; i++)
                      {
                        if (inst.bdt.reglist & (1<<i))
                        {
                          prev = physbase;
                          TRANSFER;
                          INC;
                          TESTOVERLAP;
                        }
                      }
                      if (inst.bdt.reglist & (1<<15))
                      {
                        prev = physbase;
                        PCTRANSFER;
                        INC;
                        TESTOVERLAP;
                      }
                    }
                  }
                  else   // transfer registers downwards in memory
                  {
                    uint5 *prev, *physbase = (uint5*)((uint5)memory_lookup(mem, base)&~3);
                    if (inst.bdt.p) // predecrement
                    {
                      if (inst.bdt.reglist & (1<<15))
                      {
                        prev = physbase;
                        DEC;
                        TESTOVERLAP;
                        PCTRANSFER;
                      }
                      for (i=14; i>=0; i--)
                      {
                        if (inst.bdt.reglist & (1<<i))
                        {
                          prev = physbase;
                          DEC;
                          TESTOVERLAP;
                          TRANSFER;
                        }
                      }
                    }
                    else  // postdecrement
                    {
                      if (inst.bdt.reglist & (1<<15))
                      {
                        prev = physbase;
                        PCTRANSFER;
                        DEC;
                        TESTOVERLAP;
                      }
                      for (i=14; i>=0; i--)
                      {
                        if (inst.bdt.reglist & (1<<i))
                        {
                          prev = physbase;
                          TRANSFER;
                          DEC;
                          TESTOVERLAP;
                        }
                      }
                    }
                  }
                	if (inst.bdt.w) // writeback
                	{
                		PUT(inst.bdt.rn, (uint5)base);
                	}
                
                #ifdef VIRTUALFRAMEBUFFER
                  if (!inst.bdt.l) memory_postwrite(mem, base);
                #endif
                
                	// pipeline correction, or just next instruction
                  if (inst.bdt.l && (inst.bdt.reglist & (1<<15)))
                    reg->r[15]+=8;
                  else
                    INCPC;
                }
                
                /*
                #define read(A,B,C) printf("fread(%x,%x,%x,%x)\n", (A),(B),(C),(D))
                #define write(A,B,C) printf("fwrite(%x,%x,%x,%x)\n", (A),(B),(C),(D))
                */
                
                void exec_swi(machineinfo* machine, instructionformat inst, void* null)
           7 -> {
                	registerinfo* reg = machine->reg;
                
                	if (!exec_condition(machine, inst)) return;
                
                #ifdef FAKESWI
                  fake_syscall(machine, inst.swi.number);
                #endif
                
                	INCPC;
                }
                
                void exec_cdt(machineinfo* machine, instructionformat inst, void* null)
       ##### -> {
                  // unimplemented
                }
                
                void exec_cdo(machineinfo* machine, instructionformat inst, void* null)
       ##### -> {
                  // unimplemented
                }
                
                void exec_crt(machineinfo* machine, instructionformat inst, void* null)
       ##### -> {
                  // unimplemented
                }
                
                void exec_sds(machineinfo* machine, instructionformat inst, void* null)
       ##### -> {
                  // unimplemented
                }
                
                void exec_und(machineinfo* machine, instructionformat inst, void* null)
       ##### -> {
                  // unimplemented
                }


Top 10 Lines:

     Line      Count

       15       6770
      130       2794
      386       1573
      563       1170
      528        759
      689        422
      543         46
      807          7

Execution Summary:

       13   Executable lines in this file
       13   Lines executed
   100.00   Percent of the file executed

    13541   Total number of line executions
  1041.62   Average executions per line


*** File /home/jules/ARMemu/armemu/memory.c:
                #include <stdio.h>
                
                #include "defs.h"
                #include "cnew.h"
                #include "memory.h"
                
                meminfo* memory_initialise(uint5 bytes)
           1 -> {
                  meminfo* mem = cnew(meminfo);
                  int i;
                
                  mem->memory = cnewarray(int, bytes/4);
                  mem->pagetable = cnew(level1pt);
                  mem->writetag = 0;
                
                  for (i=0; i<256; mem->pagetable->ptr[i++]=0);
                
                  // start off with MMU disabled
                  mem->mmuactive = 0;
                	
                	fprintf(stderr, "Initialised memory, MMU inactive\n");
                
                  return mem;
                }
                
                // I don't know if this is sensible.
                void memory_setmapping(meminfo* mem, uint5 from, uint5 to)
       ##### -> {
                  // blah
                }
                
                #undef memory_lookup
                uint5* memory_lookup(meminfo* mem, uint5* virtualaddress)
       ##### -> {
                
                  if (mem->mmuactive)   // non-flat address space
                  {
                    addressparts vaddr;
                    level2pt* l2;
                    level3pt* l3;
                    uint5 page;
                    vaddr.address = (uint5)virtualaddress;
                    l2 = mem->pagetable->ptr[vaddr.part.l3];
                    l3 = l2 ? l2->ptr[vaddr.part.l2] : 0;
                    page = l3 ? l3->base[vaddr.part.l1] : -1;
                    if (page==-1)
                    {
                      fprintf(stderr, "Page fault (unimplemented)\n");
                      exit(1);
                    }
                    return (uint5*)((uint5)mem->memory+4096*page);
                  }
                  else  // flat address space
                  {
                    if ((uint5)virtualaddress>4096*1024)
                    {
                      mem->writetag = 1;
                //      return (uint5*)((uint5)mem->screen->pixels+(uint5)virtualaddress
                //                    -4096*1024);
                      fprintf(stderr, "Bad memory access at %x\n", virtualaddress);
                      abort();
                    }
                    if ((uint5)virtualaddress<0/* || (uint5)virtualaddress>4096*1024*/)
                    {
                      fprintf(stderr, "Bad memory access at %x\n", virtualaddress);
                      abort();
                    }
                    return (uint5*)((uint5)mem->memory+(uint5)virtualaddress);
                  }
                }
                
                #ifdef VIRTUALFRAMEBUFFER
                // screen might need updating (efficiency, efficiency...)
                void memory_postwrite(meminfo* mem, uint5* virtualaddress)
                {
                  uint5 v, x, y;
                  v = (uint5)virtualaddress-4096*1024;
                  x = v % 320, y = v / 320;
                  if (mem->writetag)
                  {
                    SDL_UpdateRect(mem->screen, x, y, 4, 1);
                    mem->writetag = 0;
                  }
                }
                #else
                void memory_postwrite(meminfo* mem, uint5* virtualaddress)
       ##### -> {
                }
                #endif


Top 10 Lines:

     Line      Count

        8          1

Execution Summary:

        4   Executable lines in this file
        4   Lines executed
   100.00   Percent of the file executed

        1   Total number of line executions
     0.25   Average executions per line


*** File /home/jules/ARMemu/armemu/riscos.c:
                #include <stdio.h>
                #include <signal.h>
                #include <sys/times.h>
                
                #include "defs.h"
                #include "cnew.h"
                #include "riscos.h"
                #include "execute.h"
                
                // This file borrows heavily from Edwin Dorre's armemu for DOS
                
                osstateinfo* riscosstate;
                
                void riscos_escapehandler(int x)
       ##### -> {
                  riscosstate->escape = 1;
                }
                
                osstateinfo* riscos_initialise(void)
           1 -> {
                  uint5 i, j;
                  osstateinfo* newstate = cnew(osstateinfo);
                
                  for (i=0; i<18; i++)
                    for (j=0; j<3; j++)
                      newstate->environment[i][j] = 0;
                
                  newstate->vdulen = 0;
                  newstate->vduptr = 0;
                  newstate->escape = 0;
                  newstate->escapekey = 27;
                
                  signal(SIGQUIT, riscos_escapehandler);
                
                  return newstate;
                }
                
                // this is broken for non-flat address space
                void riscos_stringcopy(meminfo* mem, uint5* to, uint5* from)
       ##### -> {
                  uint3* fromptr = (uint3*)memory_lookup(mem, (uint5*)from);
                  uint3* toptr = (uint3*)memory_lookup(mem, (uint5*)to);
                
                  while (*fromptr && *fromptr!=13) *toptr++ = *fromptr++;
                  *toptr = 0;
                }
                
                // limited VDU driver
                void riscos_vdu(osstateinfo* os, uint3 ch)
        1762 -> {
                  if (os->vdulen==0 && ch>=32)
                  {
                    fprintf(stderr, "%c", ch);
                    return;
                  }
                
                  os->vduqueue[os->vduptr++] = ch;
                
                  switch (os->vduqueue[0])
                  {
                    case 1: os->vdulen = 2; break;
                    case 17: os->vdulen = 2; break;
                    case 18: os->vdulen = 3; break;
                    case 19: os->vdulen = 6; break;
                    case 22: os->vdulen = 2; break;
                    case 23: os->vdulen = 10; break;
                    case 24: os->vdulen = 9; break;
                    case 25: os->vdulen = 6; break;
                    case 28: os->vdulen = 5; break;
                    case 29: os->vdulen = 5; break;
                    case 31: os->vdulen = 3; break;
                    default: os->vdulen = 1;
                  }
                
                  if (os->vduptr == os->vdulen)
                  {
                    os->vdulen = 0;
                    switch (os->vduqueue[0])
                    {
                      case 0: // nothing
                      case 1: // send next character to printer
                      case 2: // printer on
                      case 3: // printer off
                      case 4: // join text & graphics cursors
                      case 5: // split text & graphics cursors
                      case 6: // enable screen output
                      break;
                
                      case 7: // beep
                      case 8: // backspace
                      case 9: // horizontal tab
                      case 10: // line feed
                      case 11: // vertical tab
                      case 12: // formfeed/clear screen
                      case 13: // carriage return
                      putchar(os->vduqueue[0]);
                      break;
                
                      case 14: // page mode on
                      case 15: // page mode off
                      case 16: // clear graphics window
                      case 17: // set text colour
                      case 18: // set graphics colour
                      case 19: // set palette
                      case 20: // restore default colours
                      case 21: // disable screen display
                      break;
                
                      case 22: // change display mode
                      break;
                
                      case 23: // miscellaneous commands
                      case 24: // define graphics window
                      break;
                
                      case 25: // general plot command
                      break;
                
                      case 26: // restore default windows
                      case 27: // no operation
                      break;
                
                      case 28: // define text window
                      break;
                
                      case 29: // define graphics origin
                      break;
                
                      case 30: // home text cursor
                      break;
                
                      case 31: // position text cursor
                      break;
                    }
                    os->vduptr = 0;
                  }
                }
                
                void riscos_readline(osstateinfo* os, meminfo* mem, registerinfo* reg)
       ##### -> {
                  uint5 buf = reg->r[0] & 0x3fffffffU;
                  uint3* buffer = (uint3*)memory_lookup(mem, (uint5*)buf);
                  uint3 lo = reg->r[2], hi = reg->r[3], echo = reg->r[4];
                  uint3 enteronly = buf	& 0x80000000U ? 1 : 0;
                  uint3 obscure = buf & 0x40000000U ? 1 : 0;
                  uint5 done = 0, ptr = 0, i;
                
                  if (os->escape)
                  {
                    FLAG(c) = 1;
                    reg->r[0] = 0x1b;
                    reg->r[1] = 0;
                    return;
                  }
                
                  while (!done)
                  {
                    uint3 ch = getchar();
                    switch (ch)
                    {
                      case 8:
                      case 127:
                      if (ptr) buffer[--ptr] = 0;
                      break;
                
                      case 10:
                      case 13:
                      done = 1;
                      break;
                
                      case 21:
                      while (ptr)
                      {
                        buffer[--ptr] = 0;
                        putchar(127);
                      }
                      break;
                
                      default:
                      if (ch>=lo && ch<=hi)
                      {
                        buffer[ptr++] = ch;
                      }
                    }
                  }
                //  fprintf(stderr, "Read a line: %s\n", buffer);
                  FLAG(c) = 0;
                  buffer[ptr] = 13; // terminate the line?
                  reg->r[1] = ptr;
                }
                
                uint5 riscos_inkey(uint5 lo, uint5 hi)
       ##### -> {
                  return getchar();
                }
                
                void riscos_swi(osstateinfo* os, meminfo* mem, registerinfo* reg, uint5 num)
        1764 -> {
                  int xform = (num & XOS_Bit) ? 1 : 0;
                //  fprintf(stderr, "Calling SWI %x, r0=%d\n", num, reg->r[0]);
                
                  if (num>=256 && num<=511)
                  {
                    riscos_vdu(os, num-256);
                    return;
                  }
                
                  num &= ~XOS_Bit;
                
                  switch (num)
                  {
                    case OS_Byte:
                    fprintf(stderr, "OS_Byte %d called\n", reg->r[0]);
                    switch (reg->r[0])
                    {
                      case 124:  // clear escape condition
                      os->escape = 0;
                      break;
                
                      case 125:  // set escape condition
                      os->escape = 1;
                      break;
                
                      case 126:  // acknowledge escape condition
                      if (os->escape)
                      {
                        reg->r[1] = 255;
                        os->escape = 0;
                        printf("Escape\n");
                      } else reg->r[1] = 0;
                      break;
                
                      case 128: // get buffer/mouse status
                      reg->r[0] = reg->r[1] = reg->r[2] = 0;
                      break;
                
                      case 129:  // scan for a particular key
                      if (reg->r[2] < 0x80)
                      {
                        if (os->escape)
                        {
                          reg->r[1] = 0;
                          reg->r[2] = 0x1b;
                        }
                        else
                        {
                          reg->r[1] = riscos_inkey(reg->r[1], reg->r[2]);
                          reg->r[2] = reg->r[1]==-1 ? 255 : 0;
                        }
                      }
                      else
                      {
                        reg->r[1] = reg->r[2] = 0;
                      }
                      break;
                
                      case 218:  // read/write bytes in VDU queue
                      {
                        uint5 was = os->vdulen - os->vduptr;
                        // humm, something like this anyway
                        os->vdulen = ((was ^ 0xff) & reg->r[2]) ^ reg->r[1];
                        reg->r[1] = 0xff ^ was;
                      }
                      break;
                
                      default:
                      fprintf(stderr, "Unknown OS_Byte call: %d\n", reg->r[0]);
                    }
                    break;
                
                    case OS_ReadMonotonicTime:
                    {
                      struct tms time_info;
                      times(&time_info);
                      reg->r[0] = time_info.tms_utime;
                    }
                    break;
                 
                    case OS_ChangeEnvironment:
                    if (reg->r[0] < 17)
                    {
                      uint5 a = os->environment[reg->r[0]][0];
                      uint5 b = os->environment[reg->r[0]][1];
                      uint5 c = os->environment[reg->r[0]][2];
                      if (reg->r[1]) os->environment[reg->r[0]][0] = reg->r[1];
                      if (reg->r[2]) os->environment[reg->r[0]][1] = reg->r[2];
                      if (reg->r[3]) os->environment[reg->r[0]][2] = reg->r[3];
                      reg->r[1] = a;
                      reg->r[2] = b;
                      reg->r[3] = c;
                    }
                    break;
                
                    case OS_Exit:
                    if (os->environment[environment_Exit][0])
                    {
                      reg->r[15] = os->environment[environment_Exit][0]+8;
                      reg->r[12] = os->environment[environment_Exit][1];
                    }
                    else
                    {
                      printf("OS_Exit with no handler\n");
                      exit(0);
                    }
                    break;
                
                    case OS_GenerateError:
                    if (xform)
                    {
                      FLAG(v) = 1;
                      break;
                    }
                    if (os->environment[environment_Error][0])
                    {
                      uint5 a = os->environment[environment_Error][2];
                      reg->r[15] = os->environment[environment_Error][0]+8;
                
                      *memory_lookup(mem, (uint5*)a) = reg->r[15];
                      *memory_lookup(mem, (uint5*)(a+4)) = reg->r[0];
                
                      riscos_stringcopy(mem, (uint5*)(a+8), (uint5*)(reg->r[0]+4));
                
                      reg->r[0] = os->environment[environment_Error][1];
                    }
                    else
                    {
                      printf("Error: %s\n", memory_lookup(mem, (uint5*)(reg->r[0]+4)));
                    }
                    break;
                
                    case OS_Plot:
                    break;
                
                    case OS_ReadLine:
                    riscos_readline(os, mem, reg);
                    break;
                
                    case OS_ReadC:
                    if (os->escape)
                    {
                      FLAG(c) = 1;
                      reg->r[0] = 0x1b;
                      break;
                    }
                    reg->r[0] = getchar();
                    if (reg->r[0] == os->escapekey)
                    {
                      os->escape = 1;
                      FLAG(c) = 1;
                      reg->r[0] = 0x1b;
                    }
                    else FLAG(c) = 0;
                    break;
                
                    case OS_WriteC:
                    riscos_vdu(os, reg->r[0]);
                    break;
                
                    case OS_Write0:
                    {
                      uint5 addr = reg->r[0], ch;
                      while (ch = *(uint3*)memory_lookup(mem, (uint5*)(addr++)))
                        riscos_vdu(os, ch);
                    }
                    break;
                
                    // ew!
                    case OS_WriteS:
                    {
                      uint5 addr = GET(15)-4, ch, len = 0;
                      while (ch = *(uint3*)memory_lookup(mem, (uint5*)(addr++)))
                      {
                        riscos_vdu(os, ch);
                        len++;
                      }
                      len = (len+4)&~3;
                      reg->r[15] += len;
                    }
                    break;
                
                    case OS_WriteN:
                    {
                      uint5 addr = reg->r[0];
                      uint5 len;
                      for (len=reg->r[1]; len>0; len--)
                        riscos_vdu(os, *(uint3*)memory_lookup(mem, (uint5*)(addr++)));
                    }
                    break;
                
                    case OS_NewLine:
                    riscos_vdu(os, 10);
                    riscos_vdu(os, 13);
                    break;
                
                    case OS_GetEnv:
                    {
                	  static char* env = "BASIC";
                      reg->r[0] = 0x800;
                      strcpy((char*)memory_lookup(mem, (uint5*)reg->r[0]), env);
                //      riscos_stringcopy(mem, (uint5*)reg->r[0], (uint5*)env);
                //    we've got 256k! wow!
                      reg->r[1] = 256*1024;
                      reg->r[2] = 0x808;
                      break;
                    }
                
                    case OS_ConvertHex8:
                    snprintf((char*)memory_lookup(mem, (uint5*)reg->r[1]), reg->r[2], "%08lX",
                      reg->r[0]);
                    break;
                
                    case OS_CLI:
                    {
                      uint5 i=0;
                      uint3 ch;
                      fprintf(stderr, "CLI called with:\n");
                      while ((ch = ((char*)memory_lookup(mem, (uint5*)(reg->r[0])))[i++])>=32)
                        fprintf(stderr, "%c", ch);
                      fprintf(stderr, "\n");
                    }
                    break;
                
                    case OS_Word:
                    break;
                
                    case OS_File:
                    fprintf(stderr, "OS_File called, unimplemented\n");
                    break;
                
                    case OS_Find:
                    fprintf(stderr, "OS_Find not implemented\n");
                    exit(0);
                    break;
                
                    case OS_SynchroniseCodeAreas:
                	// This can be made to invalidate bits of recompiled code
                  	break;
                
                    case BASICTrans_Error:
                    // This causes default messages to be printed
                    FLAG(v) = 1;
                    break;
                    
                    case BASICTrans_Message:
                    FLAG(v) = 1;
                    break;
                
                    default:
                    fprintf(stderr, "Unknown SWI %x called\n", num);
                  }
                }


Top 10 Lines:

     Line      Count

      198       1764
       50       1762
       20          1

Execution Summary:

        7   Executable lines in this file
        7   Lines executed
   100.00   Percent of the file executed

     3527   Total number of line executions
   503.86   Average executions per line


*** File /home/jules/ARMemu/armemu/loadaout.c:
                #include <stdio.h>
                #include <sys/stat.h>
                #include <sys/types.h>
                #include <unistd.h>
                #include <a.out.h>
                
                #include "loadaout.h"
                
                // load an a.out format binary, return entry point (as word offset)
                int load_aout(int* memory, char* filename)
           1 -> {
                	struct stat filest;
                	struct exec* header;
                	FILE* bin;
                	
                	stat(filename, &filest);
                	bin = fopen(filename, "r");
                	if (!bin)
                	{
                	  fprintf(stderr, "Couldn't open file %s\n", filename);
                		exit(1);
                	}
                	fread(memory, 1, filest.st_size, bin);
                	fclose(bin);
                	
                	header = (struct exec*) memory;
                	
                	return 0x1030;  // hmm, fix this
                }


Top 10 Lines:

     Line      Count

       11          1

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        1   Total number of line executions
     1.00   Average executions per line


*** File /home/jules/ARMemu/armemu/x86asm.c:
                #include <stdarg.h>
                #include <stddef.h>
                #include <stdio.h>
                
                #include "cnew.h"
                #include "defs.h"
                #include "machine.h"
                #include "hash.h"
                #include "pseudo.h"
                #include "x86asm.h"
                #include "registers.h"
                
                nativeblockinfo* x86asm_newnative(void)
          62 -> {
                  nativeblockinfo* nat = cnew(nativeblockinfo);
                  nat->base = cnewarray(char, nat->size=2048);
                  nat->length = 0;
                  return nat;
                }
                
                // assemble an x86 instruction from a series of bit-blocks
                void x86asm_out(nativeblockinfo* nat, ...)
        5898 -> {
                	sint5 bit = 0, nb;
                	uint5 argval;
                	uint5* outc;
                	va_list ap;
                		
                	va_start(ap, nat);
                	
                	while (nb=va_arg(ap, uint5))
                	{
                		if (!bit) nat->base[nat->length] = 0;
                		argval = va_arg(ap, uint5);
                		while (nb>0)
                		{
                		  uint5 chunk = nb>8 ? 8 : nb;
                			nat->base[nat->length] |= (argval << bit) & 0xff;
                			bit += chunk;
                			argval >>= chunk;
                			nb -= chunk;
                			if (bit>=8)
                			{
                	  		bit -= 8;
                        if (++nat->length==nat->size)
                          nat->base = realloc(nat->base, nat->size*=2);
                			}
                		}
                  }
                	
                	va_end(ap);
                
                  if (bit!=0) fprintf(stderr, "Instruction doesn't seem to fill byte?\n");
                	
                //	fprintf(stderr, "Written %d bytes\n", byte);
                }


Top 10 Lines:

     Line      Count

       23       5898
       14         62

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

     5960   Total number of line executions
  2980.00   Average executions per line


*** File /home/jules/ARMemu/armemu/pqueue.c:
                #include <assert.h>
                
                #include "cnew.h"
                #include "pqueue.h"
                
                // Priority queue handling: algorithmi from The White Book (naturally)
                
                pqueue* pqueue_new(void)
          62 -> {
                  pqueue* pq = cnew(pqueue);
                  pq->data = cnewarray(pqueueitem, 4);
                  pq->length = 0;
                  pq->size = 4;
                  
                  return pq;
                }
                
                void pqueue_delete(pqueue* pq)
          62 -> {
                  // free things pointed to by pq->data[n]->item...
                  free(pq->data);
                  free(pq);
                }
                
                pqueueitem* pqueue_newitem(uint5 priority)
         407 -> {
                  pqueueitem* pqi = cnew(pqueueitem);
                  
                  pqi->priority = priority;
                  pqi->item = 0;
                  
                  return pqi;
                }
                
                void pqueue_deleteitem(pqueueitem* pqi)
         407 -> {
                  free(pqi);
                }
                
                pqueueitem* pqueue_insert(pqueue** pq, uint5 priority)
         407 -> {
                  sint5 i;
                  
                  if (++(*pq)->length==(*pq)->size)
                    (*pq)->data = realloc((*pq)->data, sizeof(pqueueitem*) * ((*pq)->size*=2));
                  
                  i = (*pq)->length-1;
                
                  while (i>0 && (*pq)->data[pq_PARENT(i)]->priority>priority)
                  {
                    (*pq)->data[i] = (*pq)->data[pq_PARENT(i)];
                    i = pq_PARENT(i);
                  }
                  
                  return (*pq)->data[i] = pqueue_newitem(priority);
                }
                
                pqueueitem* pqueue_head(pqueue* pq)
       ##### -> {
                  return pq->length ? pq->data[0] : 0;
                }
                
                // you're expected to deallocate the item yourself after calling this
                pqueueitem* pqueue_extract(pqueue* pq)
         407 -> {
                  pqueueitem* max;
                
                  assert(pq->length >= 1);
                  
                  max = pq->data[0];
                  pq->data[0] = pq->data[--pq->length];
                  pqueue_heapify(pq, 0);
                  
                  return max;
                }
                
                void pqueue_heapify(pqueue* pq, uint5 i)
         407 -> {
                  uint5 l = pq_LEFT(i), r = pq_RIGHT(i), largest;
                
                  largest = (l<pq->length && pq->data[l]->priority<pq->data[i]->priority)
                              ? l : i;
                
                  if (r<pq->length && pq->data[r]->priority<pq->data[largest]->priority)
                    largest = r;
                
                  if (largest != i)
                  {
                    pqueueitem* temp = pq->data[i];
                    pq->data[i] = pq->data[largest];
                    pq->data[largest] = temp;
                    pqueue_heapify(pq, largest);
                  }
                }
                


Top 10 Lines:

     Line      Count

       26        407
       36        407
       41        407
       65        407
       78        407
        9         62
       19         62

Execution Summary:

        8   Executable lines in this file
        8   Lines executed
   100.00   Percent of the file executed

     2159   Total number of line executions
   269.88   Average executions per line


*** File /home/jules/ARMemu/armemu/nativesupport.c:
                #include <stdio.h>
                
                #include "defs.h"
                #include "registers.h"
                #include "memory.h"
                #include "nativesupport.h"
                #include "execute.h"
                #include "fakesys.h"
                
                // glue code used to execute native code fragments
                void nativesupport_invoke(machineinfo* machine, nativeblockinfo* code)
     3205387 -> {
                  registerinfo* reg = machine->reg;
                  reg->cflag = FLAG(c);
                  reg->vflag = FLAG(v);
                  reg->nflag = FLAG(n);
                  reg->zflag = FLAG(z);
                  reg->r[15] &= 0x3fffffc;
                  // "A" means registers a to d - not perfect, but OK
                  // doesn't seem to understand clobbering %ebp, whoops
                  asm("pushl %%ebp\n\t" \
                      "movl %0,%%ebp\n\t" \
                      "call *%1\n\t" \
                      "popl %%ebp"
                      : /* unused */
                      : "A" (reg), "A" (code->base)
                      : "ax", "bx", "cx", "dx", "si", "di");
                      
                      /*"m" (reg->cflag),
                        "m" (reg->vflag), "m" (reg->nflag),
                        "m" (reg->zflag)*/
                  FLAG(c) = reg->cflag;
                  FLAG(v) = reg->vflag;
                  FLAG(n) = reg->nflag;
                  FLAG(z) = reg->zflag;
                }
                
                void nativesupport_swi(machineinfo* machine, uint5 number)
       ##### -> {
                  // just one more level of indirection...
                  fake_syscall(machine, number);
                }
                
                void nativesupport_writebyte(meminfo* mem, uint5 address, uint5 byte)
       ##### -> {
                  uint3* addr = (uint3*)memory_lookup(mem, (uint5*)address);
                  *addr = byte;
                //  fprintf(stderr, "STB @ %x\n", *(uint5*)memory_lookup(mem, (uint5*)0));
                  #ifdef VIRTUALFRAMEBUFFER
                  memory_postwrite(mem, (uint5*)address);
                  #endif
                }
                
                void nativesupport_writeword(meminfo* mem, uint5 address, uint5 word)
       ##### -> {
                  uint5* addr = memory_lookup(mem, (uint5*)address);
                  addr = (uint5*)((uint5)addr&~3);
                  *addr = word;
                  #ifdef VIRTUALFRAMEBUFFER
                  memory_postwrite(mem, (uint5*)address);
                  #endif
                //  fprintf(stderr, "Writing %x to %x\n", word, address);
                }
                
                uint5 nativesupport_readbyte(meminfo* mem, uint5 address)
       ##### -> {
                  uint3* addr = (uint3*)memory_lookup(mem, (uint5*)address);
                //  fprintf(stderr, "LDB @ %x\n", *(uint5*)memory_lookup(mem, (uint5*)0));
                  return *addr;
                }
                
                uint5 nativesupport_readword(meminfo* mem, uint5 address)
       ##### -> {
                  uint5* addr = memory_lookup(mem, (uint5*)address);
                  uint5 byteoffset = (uint5)addr & 3, val;
                  addr = (uint5*) ((uint5)addr&~3);
                  val = ROR(*addr, byteoffset*8);
                //  fprintf(stderr, "Read %x from %x\n", val, address);
                  return val;
                /*  return ROR(*addr, byteoffset*8);*/
                }
                
                uint5 nativesupport_reconstructpc(uint5 addr, registerinfo* reg)
       ##### -> {
                  uint5 val = addr | (reg->mode) | (reg->intmask<<26) | (reg->vflag<<28) |
                              (reg->cflag<<29) | (reg->zflag<<30) | (reg->nflag<<31);
                //  fprintf(stderr, "reconstructing pc, value %x (addr %x)\n", val, addr);
                  return val;
                }


Top 10 Lines:

     Line      Count

       12    3205387

Execution Summary:

        7   Executable lines in this file
        7   Lines executed
   100.00   Percent of the file executed

  3205387   Total number of line executions
457912.43   Average executions per line


*** File /home/jules/ARMemu/armemu/list.c:
                /*
                **    Name: list.c
                **
                **    Date: Sat Jun 27 15:24:02 1998
                **
                */
                
                #include <stdlib.h>
                
                #include "cnew.h"
                #include "list.h"
                
                list* list_add(list** oldhead)
        5933 -> {
                  list* item = cnew(list);
                  item->data = 0;
                  item->prev = *oldhead;
                  item->next = 0;
                  if (*oldhead) (*oldhead)->next = item;
                
                  return *oldhead = item;
                }
                
                void list_removehead(list** head)
        5390 -> {
                  list* prev = (*head)->prev;
                  if (*head) free(*head);
                  *head = prev;
                }
                
                // Delinks an item without freeing its data pointer */
                void list_delinkitem(list** head, list* item)
       ##### -> {
                  if (!item) return;
                  if (item->prev) item->prev->next = item->next;
                  if (item->next) item->next->prev = item->prev;
                  if (*head == item) *head = item->prev;
                  free(item);
                }
                
                list* list_itemfromdata(list* li, void* data)
       ##### -> {
                  for (; li; li = li->prev) if (li->data == data) return li;
                
                  return 0;
                }
                
                void list_destroy(list* li)
       ##### -> {
                  while (li) list_removehead(&li);
                }
                
                list* list_nthitem(list* li, int item)
       ##### -> {
                  while (item>0)
                  {
                    li = li->prev;
                    if (!li) return 0;   // return zero if item not in list
                    item--;
                  }
                  return li;
                }
                
                int list_length(list* head)
       ##### -> {
                  int count = 0;
                
                  while (head)
                  {
                    count++;
                    head = head->prev;
                  }
                  return count;
                }


Top 10 Lines:

     Line      Count

       14       5933
       25       5390

Execution Summary:

        7   Executable lines in this file
        7   Lines executed
   100.00   Percent of the file executed

    11323   Total number of line executions
  1617.57   Average executions per line


*** File /home/jules/ARMemu/armemu/block.c:
                #include <stdio.h>
                #include <assert.h>
                
                #include "defs.h"
                #include "machine.h"
                #include "cnew.h"
                #include "block.h"
                #include "pseudo.h"
                #include "decode.h"
                #include "execute.h"
                #include "analyse.h"
                #include "codegen.h"
                #include "x86dism.h"
                #include "nativesupport.h"
                
                blockinfo* block_new(void)
         222 -> {
                  blockinfo* block = cnew(blockinfo);
                	
                	block->length = block->usecount = 1;
                	block->psb = 0;
                //	block->info = 0;
                	block->lastset = 0;
                	block->nextused = 0;
                	block->native = 0;
                	
                	return block;
                }
                
                // Attempt to minimise space requirements for a recompiled block
                void block_clean(blockinfo* block)
          62 -> {
                  pseudo_deleteblock(block->psb);
                //  free(block->info);
                  hash_nuke(block->lastset, 0);
                  hash_nuke(block->nextused, 0);
                  block->psb = 0;
                //  block->info = 0;
                  block->lastset = block->nextused = 0;
                  block->native->base = realloc(block->native->base, block->native->length);
                  block->native->size = block->native->length;
                }
                
                // Don't call this, it looks broken
                void block_delete(blockinfo* block)
       ##### -> {
                  if (block->psb) pseudo_deleteblock(block->psb);
                	if (block->native) free(block->native);
                	free(block);
                }
                
                void block_dotranslation(machineinfo* machine, blockinfo* thisblock, uint5 pc)
          62 -> {
                  uint5 i;
                  #ifdef DEBUG
                	fprintf(stderr, "Code block executed more than %d times; translating "
                				          "to intermediate code...\n", EXECTHRESHOLD);
                  #endif
                  assert(machine->live = hash_lookup(machine->blocks, pc));
                	pseudo_translateblock(machine, thisblock, pc);
                //free(dag_build(thisblock->psb));
                  #ifdef DEBUG
                  fprintf(stderr, "Analysing block...\n");
                  pseudodism_block(thisblock->psb);
                  #endif
                	analyse_block(thisblock);
                  #ifdef DEBUG
                	fprintf(stderr, "Attempting recompilation...\n");
                  #endif
                	codegen_recompile(machine, thisblock);
                  #ifdef DEBUG
                	fprintf(stderr, "Generated intermediate code:\n");
                	pseudodism_block(thisblock->psb);
                  #endif
                  block_clean(thisblock);
                  #ifdef DEBUG
                	x86dism_block(thisblock->native);
                  for (i=0; i<16; i++)
                    fprintf(stderr, "r%d=%x ", i, machine->reg->r[i]);
                  fprintf(stderr, "\n");
                
                  fprintf(stderr, "Running native code at %x for first time\n",
                    thisblock->native->base);
                  #endif
                  #ifdef DEBUG
                  for (i=0; i<16; i++)
                    fprintf(stderr, "r%d=%x ", i, machine->reg->r[i]);
                  fprintf(stderr, "\n");
                  #endif
                }
                
                // extend current block or begin new block
                uint5 block_gather(machineinfo* machine, uint5 pc)
     3212158 -> {
                  blockinfo* thisblock = machine->live ? machine->live->data : 0;
                  uint5 start, end, newblock = 0;
                
                  if (!thisblock)
                  {
                    hashentry* h = hash_lookup(machine->blocks, pc);
                    
                    if (h)  // been here before...
                    {
                      thisblock = h->data;
                
                      if (thisblock->native)
                      {
                        nativesupport_invoke(machine, thisblock->native);
                        machine->live = 0;
                        return 1;
                      }
                      else
                      {
                        if (++thisblock->usecount > EXECTHRESHOLD)
                		    {
                          block_dotranslation(machine, thisblock, pc);
                          nativesupport_invoke(machine, thisblock->native);
                          machine->live = 0;
                          return 1;
                		    }
                        machine->live = h;
                        thisblock = machine->live->data;
                      }
                    }
                    else
                    {
                		  h = hash_insert(machine->blocks, pc);
                		  h->data = block_new();
                  	  machine->live = h;
                      thisblock = machine->live->data;
                      return 0;
                    }
                  }
                
                  start = machine->live->key;
                  end = start+thisblock->length*sizeof(uint5);
                
                  if (pc==end)
                  {
                    thisblock->length++;
                  }
                  else if (pc<start || pc>end)
                  {
                		machine->live = 0;
                    return block_gather(machine, pc);  // eeeew!
                  }
                
                  return 0;
                }
                
                /*
                void block_findrules(machineinfo* machine, blockinfo* blk)
                {
                  uint5 i, asgnset[6], aptr;
                	gencontext c;
                	
                	c.machine = machine;
                	c.srcbase = blk->psb->base;
                	c.info = blk->psb->dag;
                	c.lastblockstart = 0;
                	for (i=0; i<32; i++) c.rloc[i] = in_REGBLK;
                	for (i=0; i<8; i++) r.ireg[i] = reg_UNUSED;
                	c.spill = 0;
                	
                	for (i=0; i<psb->length; i++)
                	{
                	  if (c.info[i].flags & flag_BLOCKSTART) c.lastblockstart = i;
                	  aptr = 0;
                	  codegen_match(machine->translaterules, &c, asgnset, &aptr, i);
                		if (psbase[i].parts.next) i++;
                	}
                }
                */


Top 10 Lines:

     Line      Count

       94    3212158
       17        222
       32         62
       53         62

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

  3212504   Total number of line executions
642500.80   Average executions per line


*** File /home/jules/ARMemu/armemu/allocate.c:
                #include <assert.h>
                #include <stddef.h>
                #include <stdio.h>
                
                #include "cnew.h"
                #include "machine.h"
                #include "allocate.h"
                #include "block.h"
                #include "x86asm.h"
                #include "pseudo.h"
                #include "codegen.h"
                #include "registers.h"
                
                // registers to use for general-purpose calculation
                uint3 iregset[] = {EAX, EBX, ECX, EDX, ESI, EDI};
                
                void allocate_cpyregtomem(nativeblockinfo* nat, allocationinfo* alloc,
                                          uint5 ireg, uint5 var)
        2096 -> {
                  uint5 mod, disp, rm, reg;
                
                  assert(var<CACHEABLE);
                
                  if (alloc->vloc[var].in.valid && alloc->vloc[var].in.reg && 
                      !alloc->vloc[var].in.mem)
                  {
                	  mod = mod_DISP8;  // 8-bit displacement
                	  disp = var*4;
                	  rm = EBP;
                	  reg = iregset[ireg];
                
                	  #define MODSIBDISP MODDISP8
                	  x86asm_out(nat, MOVlmr, 0);
                	  #undef MODSIBDISP
                
                    alloc->vloc[var].in.mem = 1;
                  }
                  else
                  {
                    #ifdef DEBUG
                    fprintf(stderr, "Warning: register %d not saved to %d\n  (valid=%d, reg=%d, mem=%d)\n", ireg, var, alloc->vloc[var].in.valid, alloc->vloc[var].in.reg,
                    alloc->vloc[var].in.mem);
                    #endif
                  }
                }
                
                void allocate_cpymemtoreg(nativeblockinfo* nat, allocationinfo* alloc,
                                          uint5 var, uint5 ireg)
         572 -> {
                  uint5 mod, disp, rm, reg;
                
                  assert(var<CACHEABLE);
                
                  if (alloc->vloc[var].in.mem)
                  {
                	  mod = mod_DISP8;
                	  disp = var*4;
                	  rm = EBP;
                	  reg = iregset[ireg];
                
                	  #define MODSIBDISP MODDISP8
                	  x86asm_out(nat, MOVlrm, 0);
                	  #undef MODSIBDISP
                
                    alloc->vloc[var].in.reg = 1;
                    alloc->vloc[var].in.valid = 1;
                    alloc->vloc[var].in.number = ireg;
                    alloc->rctn[ireg].all = 1<<var;
                  }
                  else
                  {
                    #ifdef DEBUG
                    fprintf(stderr, "Warning: register %d not loaded from %d\n", ireg, var);
                    #endif
                  }
                }
                
                // get an x86 register, clearing out any others if necessary
                uint5 allocate_obtain(allocationinfo* alloc, uint5 lock, nativeblockinfo* nat)
         901 -> {
                  uint5 i;
                  
                  for (i=0; i<NUMIREG; i++) if (!alloc->rctn[i].all) return i;
                
                  for (i=0; i<NUMIREG; i++)
                  {
                    if (++alloc->spill>=NUMIREG) alloc->spill = 0;
                    
                /*    fprintf(stderr, "Attempting to tip reg %x under lock %x\n",
                      alloc->rctn[alloc->spill].all, lock);
                    
                    if (alloc->rctn[alloc->spill].all==0x10000 && lock==0xffc00000) abort();*/
                    
                    if (!(alloc->rctn[alloc->spill].all & lock))
                    {
                      uint5 j;
                
                      // 'potentially' more than one variable (intermediate reg) per ireg
                      for (j=0; j<32; j++)
                      {
                        if (alloc->rctn[alloc->spill].all & (1<<j))
                        {
                          allocate_cpyregtomem(nat, alloc, alloc->spill, j);
                          alloc->rctn[alloc->spill].all &= ~(1<<j);
                          alloc->vloc[j].in.reg = alloc->vloc[j].in.valid = 0;
                          alloc->vloc[j].in.mem = 1;
                          #ifdef DEBUG
                          fprintf(stderr, "Spilled variable %d\n", j);
                          #endif
                        }
                      }
                
                      return alloc->spill;
                    }
                  }
                
                  fprintf(stderr, "Can't spill register, dying?\n");
                  abort();
                }
                
                // new allocator, old one went stale...
                registermapping allocate_reg(allocationinfo* alloc, uint5 var, uint5 lock,
                                             uint5 type, nativeblockinfo* nat)
        3831 -> {
                  registermapping r;
                
                  #ifdef DEBUG
                  fprintf(stderr, "Lock seems to be %x\n", lock);
                  #endif
                
                  switch (type)
                  {
                    case alloc_VALID:
                    {
                      assert(var<CACHEABLE);
                      if (alloc->vloc[var].in.reg)
                      {
                        if (!alloc->vloc[var].in.valid)
                          allocate_cpymemtoreg(nat, alloc, var, alloc->vloc[var].in.number);
                
                        r.parts.original = var;
                        r.parts.mapnum = alloc->vloc[var].in.number;
                        r.parts.mappedto = iregset[r.parts.mapnum];
                        r.parts.status = alloc_VALID;
                        #ifdef DEBUG
                        fprintf(stderr, "Valid allocation returning register, var %d\n", var);
                        #endif
                      }
                      else
                      {
                        uint5 ireg = allocate_obtain(alloc, lock, nat);
                        allocate_cpymemtoreg(nat, alloc, var, ireg);
                        r.parts.original = var;
                        r.parts.mapnum = ireg;
                        r.parts.mappedto = iregset[ireg];
                        r.parts.status = alloc_VALID;
                        #ifdef DEBUG
                        fprintf(stderr, "Valid allocation returning new register, var %d\n",
                          var);
                        #endif
                      }
                    }
                    break;
                    
                    case alloc_INVALID:
                    {
                      assert(var<CACHEABLE);
                      if (alloc->vloc[var].in.reg)
                      {
                        r.parts.original = var;
                        r.parts.mapnum = alloc->vloc[var].in.number;
                        r.parts.mappedto = iregset[r.parts.mapnum];
                        r.parts.status = alloc->vloc[var].in.valid ? alloc_VALID : 
                          alloc_INVALID;
                        #ifdef DEBUG
                        fprintf(stderr, "Invalid allocation returning existing register, "
                          "var %d\n", var);
                        #endif
                      }
                      else
                      {
                        uint5 ireg = allocate_obtain(alloc, lock, nat);
                        alloc->vloc[var].in.reg = 1;
                        alloc->vloc[var].in.valid = 0;
                        alloc->vloc[var].in.number = ireg;
                        alloc->rctn[ireg].all = 1<<var;
                        r.parts.original = var;
                        r.parts.mapnum = ireg;
                        r.parts.mappedto = iregset[ireg];
                        r.parts.status = alloc_INVALID;
                        #ifdef DEBUG
                        fprintf(stderr, "Invalid allocation returning new register, var %d\n",
                          var);
                        #endif
                      }
                    }
                    break;
                    
                    case alloc_MEMORY:
                    {
                      if (alloc->vloc[var].in.reg)
                      {
                        if (!alloc->vloc[var].in.valid)
                          allocate_cpymemtoreg(nat, alloc, var, alloc->vloc[var].in.number);
                
                        r.parts.original = var;
                        r.parts.mapnum = alloc->vloc[var].in.number;
                        r.parts.mappedto = iregset[r.parts.mapnum];
                        r.parts.status = alloc_VALID;
                        #ifdef DEBUG
                        fprintf(stderr, "Memory allocation returning register, var %d\n", var);
                        #endif
                      }
                      else
                      {
                        // if this fails, something's horribly broken
                        assert(alloc->vloc[var].in.mem);
                        r.parts.original = var;
                        r.parts.mapnum = r.parts.mappedto = 255;
                        r.parts.status = alloc_MEMORY;
                        #ifdef DEBUG
                        fprintf(stderr, "Memory allocation returning memory, var %d\n", var);
                        #endif
                      }
                    }
                    break;
                    
                    case alloc_HIDDEN:
                    {
                      r.parts.original = var;
                      r.parts.mapnum = r.parts.mappedto = 255;
                      r.parts.status = alloc_HIDDEN;
                      #ifdef DEBUG
                      fprintf(stderr, "Hidden allocation returning nothing, var %d\n", var);
                      #endif
                    }
                  }
                  
                  return r;
                }
                
                // set up an allocation state (flags and registers) for an instruction
                void allocate_setup(allocationinfo* alloc, matchstate* mstate, uint5 ins,
                                    nativeblockinfo* nat, uint5* lock)
        1818 -> {
                  uint5 i, flags = 0;
                  pseudoformat inst;
                  uint5 allocmsk = 0x003fffff;
                  
                  inst.value = ins;
                  
                  for (i=0; i<mstate->num; i++) *lock |= 1<<mstate->regset[i].parts.original;
                
                  #ifdef DEBUG
                  fprintf(stderr, "Lock=%x\n", *lock);
                  #endif
                  
                  if (inst.parts.rm>=reg_CPSRC && inst.parts.rm<=reg_CPSRN)
                    flags |= (1<<(inst.parts.rm-reg_CPSRC));
                  if (inst.parts.rn>=reg_CPSRC && inst.parts.rn<=reg_CPSRN)
                    flags |= (1<<(inst.parts.rn-reg_CPSRC));
                  if (inst.parts.ro>=reg_CPSRC && inst.parts.ro<=reg_CPSRN)
                    flags |= (1<<(inst.parts.ro-reg_CPSRC));
                
                  allocate_ensureflags(alloc, mstate, flags, *lock, nat);
                
                  for (i=0; i<mstate->num; i++)
                  {
                    if (allocmsk & (1<<mstate->regset[i].parts.original))
                    {
                      mstate->regset[i] = allocate_reg(alloc, mstate->regset[i].parts.original,
                        *lock, (mstate->overwrite & (1<<i)) ? alloc_INVALID : ((mstate->hidden &
                        (1<<i)) ? alloc_HIDDEN : alloc_MEMORY), nat);
                    }
                    else
                    {
                      mstate->regset[i].parts.status = alloc_UNSET;
                    }
                  }
                }
                
                // any registers which have been intentionally set by a generated instruction
                // are now valid, but are no longer in step with the register dump in memory
                void allocate_npostfix(allocationinfo* alloc, matchstate* mstate)
        1910 -> {
                  uint5 i;
                  
                  for (i=0; i<mstate->num; i++)
                  {
                    if (mstate->overwrite & (1<<i))
                    {
                      uint5 orig = mstate->regset[i].parts.original;
                      alloc->vloc[orig].in.valid = 1;
                      alloc->vloc[orig].in.mem = 0;
                      #ifdef DEBUG
                      fprintf(stderr, "IC register %d set to valid\n  (reg=%d)\n", orig,
                        alloc->vloc[orig].in.reg);
                      #endif
                    }
                  }
                }
                
                // if it's discovered that a lazily allocated (alloc_MEMORY) register actually
                // needs to be in a real register, call this
                uint5 allocate_nsolidify(allocationinfo* alloc, registermapping* rmap,
                                         uint5 lock, nativeblockinfo* nat)
         841 -> {
                  uint5 var = rmap->parts.original;
                  
                  if (rmap->parts.status==alloc_VALID) return rmap->parts.mappedto;
                  if (rmap->parts.status==alloc_HIDDEN)
                  {
                    fprintf(stderr, "Warning: trying to solidify a hidden register?\n");
                    abort();
                  }
                  
                  *rmap = allocate_reg(alloc, rmap->parts.original, lock, alloc_VALID, nat);
                  
                  return rmap->parts.mappedto;
                }
                
                // store all ARM-equivalent IC registers in memory dump
                void allocate_reset(allocationinfo* alloc, nativeblockinfo* nat)
         176 -> {
                  uint5 i;
                  
                  for (i=0; i<CACHEABLE; i++)
                  {
                    if (alloc->vloc[i].in.reg && !alloc->vloc[i].in.mem && 
                        alloc->vloc[i].in.valid)
                    {
                      allocate_cpyregtomem(nat, alloc, alloc->vloc[i].in.number, i);
                      // reset usually called before clobbering things...?
                      alloc->vloc[i].in.reg = alloc->vloc[i].in.valid = 0;
                    }
                  }
                }
                
                // takes two IC registers, and swaps their contents
                void allocate_swap(allocationinfo* alloc, registermapping* x,
                                   registermapping* y, nativeblockinfo* nat)
         935 -> {
                  uint5 rm, reg, temp;
                  
                  assert(x->parts.status!=alloc_MEMORY && y->parts.status!=alloc_MEMORY);
                
                  if (x->parts.mappedto != y->parts.mappedto)
                  {  
                    rm = x->parts.mappedto;
                    reg = y->parts.mappedto;
                    x86asm_out(nat, XCHGlrr, 0);
                
                    temp = alloc->rctn[x->parts.mapnum].all;
                    alloc->rctn[x->parts.mapnum].all = alloc->rctn[y->parts.mapnum].all;
                    alloc->rctn[y->parts.mapnum].all = temp;
                
                    temp = alloc->vloc[x->parts.original].all;
                    alloc->vloc[x->parts.original].all = alloc->vloc[y->parts.original].all;
                    alloc->vloc[y->parts.original].all = temp;
                  }
                }
                
                // emit instructions necessary to move from one allocation context into another
                void allocate_coerce(allocationinfo* from, allocationinfo* to, nativeblockinfo*
                                     nat)
         410 -> {
                  // matchstate is used because it has the right sort of fields, it may not
                  // be the best thing representationally
                  matchstate mfrom, mto;
                  uint5 i;
                
                  #ifdef DEBUG
                  fprintf(stderr, "Coercing\n");
                  #endif
                  
                 /* mfrom.num = mto.num = 0;
                  
                  for (i=0; i<16; i++)
                  {
                    if (from->vloc[i].in.reg && from->vloc[i].in.valid)
                    {
                      mfrom.regset[mfrom.num].parts.original = i;
                      mfrom.regset[mfrom.num++].parts.mapnum = from->vloc[i].in.number;
                      assert(mfrom.num<6);
                    }
                    if (to->vloc[i].in.reg && to->vloc[i].in.valid)
                    {
                      mto.regset[mto.num].parts.original = i;
                      mto.regset[mto.num++].parts.mapnum = to->vloc[i].in.number;
                      assert(mto.num<6);
                    }
                  }*/
                  
                  // first, swap any registers which are fully allocated in both domains,
                  // but in different iregs
                  for (i=0; i<CACHEABLE; i++)
                  {
                    if (from->vloc[i].in.reg && from->vloc[i].in.valid &&
                        to->vloc[i].in.reg && to->vloc[i].in.valid)
                    {
                      registermapping x, y;
                      x.parts.original = y.parts.original = i;
                      x.parts.mapnum = from->vloc[i].in.number;
                      x.parts.mappedto = iregset[x.parts.mapnum];
                      y.parts.mapnum = to->vloc[i].in.number;
                      y.parts.mappedto = iregset[y.parts.mapnum];
                      allocate_swap(from, &x, &y, nat);
                    }
                  }
                  
                  // next, save any registers which are allocated in the 'from' domain
                  // but not the 'to' domain
                  for (i=0; i<CACHEABLE; i++)
                  {
                    if (from->vloc[i].in.reg && from->vloc[i].in.valid &&
                        ((!to->vloc[i].in.reg || !to->vloc[i].in.valid) ||
                        (!from->vloc[i].in.mem && to->vloc[i].in.mem)))
                    {
                      allocate_cpyregtomem(nat, from, from->vloc[i].in.number, i);
                    }
                  }
                  
                  // finally, load any registers which are allocated in the 'to' domain
                  // but not in the 'from' domain
                  for (i=0; i<CACHEABLE; i++)
                  {
                    if ((to->vloc[i].in.reg && (!from->vloc[i].in.reg ||
                        (from->vloc[i].in.reg && (to->vloc[i].in.valid &&
                         !from->vloc[i].in.valid)))))
                    {
                      allocate_cpymemtoreg(nat, from, i, to->vloc[i].in.number);
                    }
                  }
                }
                
                // force a particular (single) register mapping
                void allocate_force(allocationinfo* alloc, registermapping req,
                                    nativeblockinfo* nat)
       ##### -> {
                  registermapping cur;
                  
                  req.parts.status = alloc_VALID;
                  
                  // register contains something...
                  if (alloc->rctn[req.parts.mapnum].all)
                  {
                    uint5 i;
                    sint5 ireg = -1, var = -1;
                    registermapping x, y;
                    char* names[] = {"eax","ebx","ecx","edx","esi","edi"};
                    
                    // find where register is currently
                    for (i=0; i<NUMIREG && ireg==-1; i++)
                    {
                      if (alloc->rctn[i].all & (1<<req.parts.original)) ireg = i;
                    }
                    
                    for (i=0; i<32 && var==-1; i++)
                    {
                      if (alloc->vloc[i].in.reg && alloc->vloc[i].in.number==req.parts.mapnum)
                        var = i;
                    }
                    
                    assert(ireg!=-1 && var!=-1);
                    
                    x.parts.original = req.parts.original;
                    x.parts.mapnum = ireg;
                    x.parts.mappedto = iregset[ireg];
                    x.parts.status = alloc_VALID;
                    y.parts.original = var;
                    y.parts.mapnum = req.parts.mapnum;
                    y.parts.mappedto = iregset[req.parts.mapnum];
                    y.parts.status = alloc_VALID;
                    #ifdef DEBUG
                    fprintf(stderr, "Forced swap (%s,%d) (%s,%d)\n", names[x.parts.mapnum],
                      x.parts.original, names[y.parts.mapnum], y.parts.original);
                    #endif
                    allocate_swap(alloc, &x, &y, nat);
                  }
                }
                
                uint5 allocate_push(nativeblockinfo* nat, allocationinfo* alloc, uint5 ireg,
                                    uint5 var)
       ##### -> {
                  if (alloc->vloc[var].in.valid && alloc->vloc[var].in.reg && 
                      !alloc->vloc[var].in.mem)
                  {
                	  uint5 rm = iregset[ireg];
                	  x86asm_out(nat, PUSHlr, 0);
                
                    alloc->vloc[var].in.mem = 1;
                    return 1;
                  }
                  else
                  {
                    fprintf(stderr, "Warning: register %d not pushed onto stack\n", ireg);
                    return 0;
                  }
                }
                
                uint5 allocate_pop(nativeblockinfo* nat, allocationinfo* alloc, uint5 var,
                                   uint5 ireg)
       ##### -> {
                  if (alloc->vloc[var].in.mem)
                  {
                	  uint5 rm = iregset[ireg];
                
                	  x86asm_out(nat, POPlr, 0);
                
                    alloc->vloc[var].in.reg = 1;
                    alloc->vloc[var].in.valid = 1;
                    alloc->vloc[var].in.number = ireg;
                    alloc->rctn[ireg].all = 1<<var;
                    return 1;
                  }
                  else
                  {
                    fprintf(stderr, "Warning: register %d not popped from stack\n", ireg);
                    return 0;
                  }
                }
                
                // force some registers into memory (real ICR) or the stack (virtual ICR)
                // (just memory now)
                uint5 allocate_rpush(allocationinfo* alloc, uint5 which, nativeblockinfo* nat)
         366 -> {
                  uint5 i, stacked = 0;
                  
                  for (i=0; i<NUMIREG; i++)
                  {
                    if ((which & (1<<i)) && alloc->rctn[i].all)
                    {
                      if (alloc->rctn[i].all & 0x3fffff)
                      {
                        uint5 j;
                        // low; store to register dump
                        for (j=0; j<CACHEABLE; j++)
                        {
                          if (alloc->rctn[i].all & (1<<j))
                          {
                            allocate_cpyregtomem(nat, alloc, i, j);
                            alloc->vloc[j].in.valid = 0;
                          }
                        }
                      }
                /*      else
                      {
                        uint5 j;
                        // high; stick on the stack
                        for (j=reg_T0; j<=reg_T5; j++)
                        {
                          if (alloc->rctn[i].all & (1<<j))
                          {
                            //if (allocate_push(nat, alloc, i, j))
                            stacked |= 1<<j;
                          }
                        }
                      }*/
                    }
                  }
                
                /*  for (i=reg_T0; i<=reg_T5; i++)
                  {
                    if (stacked & (1<<i))
                      if (!allocate_push(nat, alloc, alloc->vloc[i].in.number, i))
                        stacked &= ~(1<<i);
                  }*/
                
                  return stacked;
                }
                
                // restore stacked (virtual IC) registers
                void allocate_rpop(allocationinfo* alloc, uint5 stacked,
                                   nativeblockinfo* nat)
         366 -> {
                  uint5 i;
                
                /*  for (i=reg_T5; i>=reg_T0; i--)
                  {
                    if (stacked & (1<<i))
                    {
                      allocate_pop(nat, alloc, i, alloc->vloc[i].in.number);
                      alloc->vloc[i].in.mem = 0;
                    }
                  }*/
                }
                
                // if 'type' is alloc_INVALID, a register is assigned but contains nonsense
                // if alloc_VALID, a register is assigned and made valid
                // if alloc_MEMORY, a variable is left in memory unless it is already in
                // a register
                /*registermapping allocate_reg(allocationinfo* alloc, uint5 var, uint5 lock,
                                             uint5 type, nativeblockinfo* nat)
                {
                  registermapping rmap;
                  uint5 mod, disp, rm, reg, i;
                	sint5 ireg = -1;
                
                  rmap.parts.original = var;
                  rmap.parts.mappedto = 0;
                  rmap.parts.mapnum = 0;
                  rmap.parts.status = alloc_UNSET;
                
                  #ifdef DEBUG
                  fprintf(stderr, "Attempting allocation for %d, type %d, current location "
                    "%x\n", var, type, alloc->vloc[var].all);
                  #endif
                
                  // it's not up to this allocator to deal with these things
                  if ((var>=reg_CPSRC && var<=reg_CPSRN) || var==reg_UNUSED)
                    return rmap;
                
                  // is variable already in an x86 register, and also valid?
                	if (alloc->vloc[var].all & var_REGISTER)
                	{
                		for (i=0; i<NUMIREG; i++)
                    {
                		  if ((alloc->vloc[var].all & (var_EAX<<i)) && ((type!=alloc_VALID) ||
                          type==alloc_VALID && alloc->vloc[var].in.valid))
                      {
                        rmap.parts.mapnum = i;
                        rmap.parts.mappedto = iregset[i];
                        rmap.parts.status = alloc_VALID;
                        return rmap;
                      }
                    }
                	}
                
                  if (type==alloc_MEMORY)
                  {
                    rmap.parts.mapnum = rmap.parts.mappedto = 0;
                    rmap.parts.status = alloc_MEMORY;
                    return rmap;
                  }
                	
                  // if there are any free registers, find one	
                	for (i=0; i<NUMIREG; i++)
                	{
                	  if (!alloc->rctn[i].all)
                		{
                		  ireg = i;
                			break;
                		}
                	}
                
                  // otherwise, one will have to be spilled
                	if (ireg==-1)
                	{
                  	// a more sophisticated algorithm here might be nice
                		while (ireg==-1)
                		{
                	  	// don't spill a register locked by this instruction
                			if (!(alloc->rctn[alloc->spill].all & lock))
                			  ireg = alloc->spill;
                
                  		if (++alloc->spill==NUMIREG) alloc->spill=0;
                		}
                
                    allocate_spill(alloc, ireg, 0, nat);
                	}
                	
                  switch (type)
                  {
                    case alloc_INVALID:
                    alloc->rctn[ireg].all = 1<<var;
                    alloc->vloc[var].all = var_EAX<<ireg;
                    rmap.parts.status = alloc_INVALID;
                    #ifdef DEBUG
                    fprintf(stderr, "Invalid allocation: ireg=%d, var=%d, location %x\n", ireg, 
                      var, alloc->vloc[var].all);
                    #endif
                    break;
                    
                    case alloc_VALID:
                	  if (alloc->vloc[var].in.mem)
                		{
                //	  	assert(alloc->vloc[var].in.mem);
                	  	// preserved variable; need to load previous value from dump
                			mod = mod_DISP8;
                			disp = var*4;
                			rm = EBP;
                			reg = iregset[ireg];
                			#define MODSIBDISP MODDISP8
                			x86asm_out(nat, MOVlrm, 0);
                			#undef MODSIBDISP
                		}
                	  alloc->rctn[ireg].all = 1<<var;
                	  alloc->vloc[var].all |= (var_EAX<<ireg) | var_VALID;
                    rmap.parts.status = alloc_VALID;
                    break;
                  }
                
                  // if (var>=reg_T0 && var<=reg_T4) rmap.parts.status = alloc_INREG;
                		
                  rmap.parts.mapnum = ireg;
                  rmap.parts.mappedto = iregset[ireg];
                    
                	return rmap;
                }
                */
                
                /*
                void allocate_registerpattern(allocationinfo* alloc, matchstate* mstate,
                                              uint5* lock, nativeblockinfo* native)
                {
                  uint5 j;
                
                	// lock all registers used by this instruction (so they can't be spilled)
                	for (j=0; j<mstate->num; j++) *lock |= 1<<mstate->regset[j].parts.original;
                
                	// allocate ARM registers in pattern to x86 registers
                	for (j=0; j<mstate->num; j++)
                	{
                		mstate->regset[j] = allocate_reg(alloc,
                      mstate->regset[j].parts.original, *lock, (mstate->overwrite & (1<<j))
                      ? alloc_INVALID : alloc_MEMORY, native);
                    allocate_checkalloc(alloc);
                	}
                }*/
                
                /*
                void allocate_postfix(allocationinfo* alloc, matchstate* mstate)
                {
                  uint5 j;
                
                  // any registers overwritten (set) are now valid
                	for (j=0; j<mstate->num; j++)
                  {
                    if (mstate->overwrite & (1<<j))
                    {
                      alloc->vloc[mstate->regset[j].parts.original].in.valid = 1;
                      alloc->vloc[mstate->regset[j].parts.original].in.mem = 0;
                   |* alloc->rctn[mstate->regset[j].parts.mapnum].all = 
                        1<<mstate->regset[j].parts.original;  *|
                      #ifdef DEBUG
                      fprintf(stderr, "Fiddled validity for original reg %d, match number" \
                        " %d, variable location %x\n", mstate->regset[j].parts.original, j,
                        alloc->vloc[mstate->regset[j].parts.original].all);
                      #endif
                    }
                  }
                }*/
                
                // check validity of allocationinfo structure
                /*void allocate_checkalloc(allocationinfo* alloc)
                {
                  uint5 i;
                  
                  for (i=0; i<32; i++)
                  {
                    uint5 j;
                    for (j=0; j<NUMIREG; j++)
                    {
                      if ((alloc->vloc[i].all & (var_EAX<<j)) && alloc->vloc[i].in.valid)
                      {
                        assert(alloc->rctn[j].all & (1<<i));
                      }
                    }
                  }
                  
                  for (i=0; i<NUMIREG; i++)
                  {
                    uint5 j;
                    for (j=0; j<32; j++)
                    {
                      if (alloc->rctn[i].all & (1<<j))
                      {
                        assert((alloc->vloc[j].all & (var_EAX<<i)) || !alloc->vloc[i].in.valid);
                      }
                    }
                  }
                }*/
                
                // spill a plain register into memory, or the stack if it's a temporary
                /*uint5 allocate_spill(allocationinfo* alloc, uint5 ireg, registermapping* into,
                                     nativeblockinfo* nat)
                {
                  uint5 j;
                //  allocate_checkalloc(alloc);
                  #ifdef DEBUG
                  fprintf(stderr, "Trying to spill %d\n", ireg);
                  #endif
                	// store variable(s) (only first 16) in this register in the dump
                	for (j=0; j<16; j++)
                	{
                		if (alloc->rctn[ireg].all & (1<<j))
                		{
                      if (alloc->vloc[j].in.valid && !alloc->vloc[j].in.mem)
                      {
                			  uint5 mod = mod_DISP8;  // 8-bit displacement
                			  uint5 disp = j*4;
                			  uint5 rm = EBP;
                			  uint5 reg = iregset[ireg];
                
                			  #define MODSIBDISP MODDISP8
                			  x86asm_out(nat, MOVlmr, 0);
                			  #undef MODSIBDISP
                      }
                
                |*			alloc->vloc[j].all &= ~(var_EAX<<ireg);*|
                			alloc->vloc[j].all = var_MEM;
                      alloc->rctn[ireg].all = 0;
                      #ifdef DEBUG
                      fprintf(stderr, "First type\n");
                      #endif
                      return 0;
                		}
                	}
                  for (j=reg_T0; j<=reg_T5; j++)
                  {
                    if ((alloc->rctn[ireg].all & (1<<j)))
                    {
                      uint5 rm = iregset[ireg];
                      x86asm_out(nat, PUSHlr, 0);
                      alloc->vloc[j].in.valid = 0;
                      alloc->rctn[ireg].all = 0;
                //      allocate_checkalloc(alloc);
                      if (into)
                      {
                        into->parts.original = j;
                        into->parts.mapnum = ireg;
                        into->parts.mappedto = iregset[ireg];
                      }
                      #ifdef DEBUG
                      fprintf(stderr, "Second type\n");
                      #endif
                      return 1;
                    }
                  }
                
                  if (alloc->rctn[ireg].all)
                  {
                    fprintf(stderr, "Failed to spill register %d (rctn[ireg]=%x) (locked or "
                      "wrong type?)\n", ireg, alloc->rctn[ireg]);
                    abort();
                  }
                  return 0;
                }*/
                
                /*
                void allocate_unspill(allocationinfo* alloc, registermapping* thisone,
                                      nativeblockinfo* nat)
                {
                  uint5 rm = thisone->parts.mappedto;
                  x86asm_out(nat, POPlr, 0);
                  alloc->vloc[thisone->parts.original].all |= (var_EAX<<thisone->parts.mapnum)
                                                           | var_VALID;
                  alloc->rctn[thisone->parts.mapnum].all |= 1<<thisone->parts.original;
                }*/
                
                /*
                uint5 allocate_solidify(allocationinfo* alloc, registermapping* rmap,
                                        uint5 lock, nativeblockinfo* nat)
                {
                  if (!(alloc->vloc[rmap->parts.original].all & var_REGISTER))
                  {
                    rmap->all = allocate_reg(alloc, rmap->parts.original, lock, alloc_VALID,
                                             nat).all;
                  }
                  else if (!alloc->vloc[rmap->parts.original].in.valid)
                  {
                    uint5 mod, disp, rm, reg;
                	  // need to load previous value from dump
                		mod = mod_DISP8;
                		disp = rmap->parts.original*4;
                		rm = EBP;
                		reg = rmap->parts.mappedto;
                		#define MODSIBDISP MODDISP8
                		x86asm_out(nat, MOVlrm, 0);
                		#undef MODSIBDISP
                  }
                  return rmap->parts.mappedto;
                }*/
                
                // move data from one x86 register to another
                // this isn't right yet
                /*void allocate_move(allocationinfo* alloc, registermapping from,
                                   registermapping to, nativeblockinfo* nat)
                {
                  uint5 rm, reg;
                  if (from.all==to.all) return;
                  
                  rm = to.parts.mappedto;
                  reg = from.parts.mappedto;
                  x86asm_out(nat, MOVlrr, 0);
                }*/
                
                // temporarily force a register to contain the value held in another register
                // use extreme caution with allocator after this (register may only be valid
                // until the next allocation?)
                /*sint5 allocate_forcereg(allocationinfo* alloc, matchstate* mstate, uint5 ireg,
                                        uint5 forceto, uint5 lock, nativeblockinfo* nat)
                {
                  uint5 i, mod, disp, reg, rm;
                  registermapping temp;
                	
                	// If it doesn't contain anything, don't bother saving it
                	if (alloc->rctn[ireg].all==0 || iregset[ireg]==forceto) return -1;
                
                  // store any variables held in this register
                  rm = iregset[ireg];
                  x86asm_out(nat, PUSHlr, 0);
                  
                |*  for (i=0; i<32; i++)
                  {
                    if (alloc->rctn[ireg].all & (1<<i))
                    {
                      alloc->vloc[i].all = var_MEM;
                      if (lock & (1<<i))
                      {
                        fprintf(stderr, "Warning - reallocating register...\n");
                        allocate_reg(alloc, i, lock, alloc_VALID, nat);
                      }
                	    mod = mod_DISP8;  // 8-bit displacement
                	    disp = i*4;
                	    rm = EBP;
                	    reg = iregset[ireg];
                
                	    #define MODSIBDISP MODDISP8
                	    x86asm_out(nat, MOVlmr, 0);
                	    #undef MODSIBDISP
                    }
                  }*|
                  
                	rm = iregset[ireg];
                	reg = forceto;
                	x86asm_out(nat, MOVlrr, 0);
                
                  return ireg;
                }*/
                
                /*
                void allocate_restorereg(allocationinfo* alloc, uint5 ireg, sint5 t,
                                         nativeblockinfo* nat)
                {
                  uint5 rm;
                  if (t != -1)
                  {
                    rm = iregset[t];
                    x86asm_out(nat, POPlr, 0);
                  }
                |*
                  uint5 rm, reg, i, j;
                  registermapping temp;
                    
                  if (t != -1)
                	{
                    temp.all = t;
                    rm = iregset[ireg];
                		reg = temp.parts.mappedto;
                		x86asm_out(base, ptr, MOVlrr, 0);
                    alloc->rctn[ireg].all &= ~reg_CPSRMODE;
                	}
                  *|
                }*/
                
                // If flags are about to be clobbered, save them away nicely
                void allocate_preflags(allocationinfo* alloc, uint5 corrupts, uint5 overwrites,
                                       nativeblockinfo* nat)
        2093 -> {
                  uint5 clobbered = corrupts & ~overwrites;
                	uint5 mod, rm, disp;
                
                	if (alloc->vloc[reg_CPSRC].in.flag && (clobbered & CFLAG) && 
                        !alloc->vloc[reg_CPSRC].in.mem)
                	{
                	  mod = mod_DISP8;
                		rm = EBP;
                		disp = offsetof(registerinfo, cflag);
                    #define MODSIBDISP MODDISP8
                    if (alloc->vloc[reg_CPSRC].in.invertedflag)
                    {
                      // store inverted carry flag
                      x86asm_out(nat, CMC, SETCm, 0);
                      alloc->vloc[reg_CPSRC].in.invertedflag = 0;
                    }
                    else
                    {
                		  x86asm_out(nat, SETCm, 0);
                    }
                    #undef MODSIBDISP
                		alloc->vloc[reg_CPSRC].all = var_MEM;
                	}
                
                	if (alloc->vloc[reg_CPSRV].in.flag && (clobbered & VFLAG) && 
                      !alloc->vloc[reg_CPSRV].in.mem)
                	{
                	  mod = mod_DISP8;
                		rm = EBP;
                		disp = offsetof(registerinfo, vflag);
                		#define MODSIBDISP MODDISP8
                		x86asm_out(nat, SETOm, 0);
                		#undef MODSIBDISP
                		alloc->vloc[reg_CPSRV].all = var_MEM;
                	}
                		
                	if (alloc->vloc[reg_CPSRZ].in.flag && (clobbered & ZFLAG) && 
                      !alloc->vloc[reg_CPSRZ].in.mem)
                	{
                	  mod = mod_DISP8;
                		rm = EBP;
                		disp = offsetof(registerinfo, zflag);
                		#define MODSIBDISP MODDISP8
                		x86asm_out(nat, SETZm, 0);
                		#undef MODSIBDISP
                		alloc->vloc[reg_CPSRZ].all = var_MEM;
                	}
                
                	if (alloc->vloc[reg_CPSRN].in.flag && (clobbered & NFLAG) && 
                      !alloc->vloc[reg_CPSRN].in.mem)
                	{
                	  mod = mod_DISP8;
                		rm = EBP;
                		disp = offsetof(registerinfo, nflag);
                		#define MODSIBDISP MODDISP8
                		x86asm_out(nat, SETSm, 0);
                		#undef MODSIBDISP
                		alloc->vloc[reg_CPSRN].all = var_MEM;
                	}
                }
                
                // if an instruction doesn't set quite enough flags (eg, movs), make sure it
                // sets some more. Also make sure it knows where the flags are now.
                void allocate_postflags(allocationinfo* alloc, matchstate* mstate, uint5 sets,
                                        uint5 required, nativeblockinfo* nat)
        1369 -> {
                  uint5 invcarry = (sets & ICFLAG) ? 1 : 0;
                 
                  if (required & (NFLAG | ZFLAG) && (~sets & (NFLAG | ZFLAG)))
                  {
                    uint5 rm = mstate->regset[0].parts.mappedto, imm = 0;
                    allocate_preflags(alloc, TESTdef|TESTundef, TESTdef, nat);
                    x86asm_out(nat, TESTlri, 0);
                    sets |= NFLAG | ZFLAG;
                  }
                  
                  sets &= required;
                  
                  if (sets & ZFLAG) alloc->vloc[reg_CPSRZ].all = var_FLAG;
                  if (sets & NFLAG) alloc->vloc[reg_CPSRN].all = var_FLAG;
                  if (sets & VFLAG) alloc->vloc[reg_CPSRV].all = var_FLAG;
                  if (sets & CFLAG)
                    alloc->vloc[reg_CPSRC].all = invcarry ? var_FLAG | var_INVERTEDFLAG
                                                          : var_FLAG;
                
                  assert(!(required & ~sets));
                /*
                  uint3 invcarry = (sets & ICFLAG) ? 1 : 0;
                  if ((required & ~sets) & (NFLAG|ZFLAG))
                  {
                    uint5 rm=mstate->regset[0].parts.mappedto, imm=0;
                    sets |= NFLAG | ZFLAG;
                
                    sets &= required;
                
                    if (sets & ZFLAG) alloc->vloc[reg_CPSRZ].all = var_FLAG;
                    if (sets & NFLAG) alloc->vloc[reg_CPSRN].all = var_FLAG;
                
                    x86asm_out(nat, TESTlri, 0);
                  }
                  else
                  {
                    sets &= required;
                
                    if (sets & ZFLAG) alloc->vloc[reg_CPSRZ].all = var_FLAG;
                    if (sets & NFLAG) alloc->vloc[reg_CPSRN].all = var_FLAG;
                  }
                
                  if (sets & VFLAG) alloc->vloc[reg_CPSRV].all = var_FLAG;
                  if (sets & CFLAG)
                    alloc->vloc[reg_CPSRC].all = invcarry ? var_FLAG | var_INVERTEDFLAG
                                                          : var_FLAG;*/
                }
                
                // eurgh.
                void allocate_ensureflags(allocationinfo* alloc, matchstate* mstate,
                                          uint5 flags, uint5 lock, nativeblockinfo* nat)
        1818 -> {
                  registermapping temp1, temp2;
                  uint5 rm, imm, reg, mod, disp;
                
                  flags &= ~(alloc->vloc[reg_CPSRC].in.flag ? CFLAG : 0) &
                           ~(alloc->vloc[reg_CPSRV].in.flag ? VFLAG : 0) &
                           ~(alloc->vloc[reg_CPSRN].in.flag ? NFLAG : 0) &
                           ~(alloc->vloc[reg_CPSRZ].in.flag ? ZFLAG : 0);
                
                  if (flags)
                  {
                    temp1 = allocate_reg(alloc, reg_T5, lock, alloc_INVALID, nat);
                    temp2 = allocate_reg(alloc, reg_T4, lock, alloc_INVALID, nat);
                
                    rm = temp1.parts.mappedto;
                    x86asm_out(nat, PUSHF, POPlr, 0);
                    imm = ~((flags&CFLAG?0x1:0)|(flags&ZFLAG?0x40:0)|(flags&NFLAG?0x80:0)|
                            (flags&VFLAG?0x800:0));
                    x86asm_out(nat, ANDlri, 0);
                
                    if (flags & CFLAG)
                    {
                      mod = mod_DISP8;
                      rm = EBP;
                      disp = offsetof(registerinfo, cflag);
                      reg = temp2.parts.mappedto;
                      #define MODSIBDISP MODDISP8
                      x86asm_out(nat, MOVZXlrbm, 0);
                      #undef MODSIBDISP
                      rm = temp1.parts.mappedto;
                      reg = temp2.parts.mappedto;
                      x86asm_out(nat, ORlrr, 0);
                      alloc->vloc[reg_CPSRC].all |= var_FLAG;
                    }
                
                    if (flags & ZFLAG)
                    {
                      mod = mod_DISP8;
                      rm = EBP;
                      disp = offsetof(registerinfo, zflag);
                      reg = temp2.parts.mappedto;
                      #define MODSIBDISP MODDISP8
                      x86asm_out(nat, MOVZXlrbm, 0);
                      #undef MODSIBDISP
                      rm = temp2.parts.mappedto;
                      imm = 6;
                      x86asm_out(nat, SHLlri, 0);
                      rm = temp1.parts.mappedto;
                      reg = temp2.parts.mappedto;
                      x86asm_out(nat, ORlrr, 0);
                      alloc->vloc[reg_CPSRZ].all |= var_FLAG;
                    }
                
                    if (flags & NFLAG)
                    {
                      mod = mod_DISP8;
                      rm = EBP;
                      disp = offsetof(registerinfo, nflag);
                      reg = temp2.parts.mappedto;
                      #define MODSIBDISP MODDISP8
                      x86asm_out(nat, MOVZXlrbm, 0);
                      #undef MODSIBDISP
                      rm = temp2.parts.mappedto;
                      imm = 7;
                      x86asm_out(nat, SHLlri, 0);
                      rm = temp1.parts.mappedto;
                      reg = temp2.parts.mappedto;
                      x86asm_out(nat, ORlrr, 0);
                      alloc->vloc[reg_CPSRN].all |= var_FLAG;
                    }
                
                    if (flags & VFLAG)
                    {
                      mod = mod_DISP8;
                      rm = EBP;
                      disp = offsetof(registerinfo, vflag);
                      reg = temp2.parts.mappedto;
                      #define MODSIBDISP MODDISP8
                      x86asm_out(nat, MOVZXlrbm, 0);
                      #undef MODSIBDISP
                      rm = temp2.parts.mappedto;
                      imm = 11;
                      x86asm_out(nat, SHLlri, 0);
                      rm = temp1.parts.mappedto;
                      reg = temp2.parts.mappedto;
                      x86asm_out(nat, ORlrr, 0);
                      alloc->vloc[reg_CPSRV].all |= var_FLAG;
                    }
                
                    rm = temp1.parts.mappedto;
                    x86asm_out(nat, PUSHlr, POPF, 0);
                /*    alloc->rctn[temp1.parts.mapnum].all = 0;
                    alloc->rctn[temp2.parts.mapnum].all = 0;*/
                  }
                }
                
                // generate instructions necessary to move from one allocation state into
                // another
                /*void allocate_massage(allocationinfo* from, allocationinfo* to,
                                      nativeblockinfo* nat)
                {
                  uint5 i, mod, disp, rm, reg;
                
                  #ifdef DEBUG
                  fprintf(stderr, "Massaging at x86 address %x\n", nat->length);
                  #endif
                
                  for (i=0; i<NUMIREG; i++)
                  {
                    // if register is located in different places in two contexts...
                    if ((from->rctn[i].all&0xffff) != (to->rctn[i].all&0xffff))
                    {
                      uint5 j;
                      for (j=0; j<16; j++)
                      {
                        uint5 fromalloc = (from->rctn[i].all & (1<<j)) ? 1 : 0;
                        uint5 toalloc = (to->rctn[i].all & (1<<j)) ? 1 : 0;
                        // store registers...
                        if (!toalloc && fromalloc && (from->vloc[j].all & var_REGISTER))
                        {
                          #ifdef DEBUG
                          fprintf(stderr, "storing x86 reg %d mapped to intermediate reg %d\n",
                                  i, j);
                          #endif
                          mod = mod_DISP8;
                          disp = j*4;
                          rm = EBP;
                          reg = iregset[i];
                          #define MODSIBDISP MODDISP8
                          x86asm_out(nat, MOVlmr, 0);
                          #undef MODSIBDISP
                        }
                        // load registers...
                        if (toalloc && !fromalloc)
                        {
                          #ifdef DEBUG
                          fprintf(stderr, "loading x86 reg %d mapped to intermediate reg %d\n", 
                                  i, j);
                          #endif
                          mod = mod_DISP8;
                          disp = j*4;
                          rm = EBP;
                          reg = iregset[i];
                          #define MODSIBDISP MODDISP8
                          x86asm_out(nat, MOVlrm, 0);
                          #undef MODSIBDISP
                          break;
                        }
                      }
                    }
                  }
                }
                */


Top 10 Lines:

     Line      Count

      124       3831
       19       2096
      960       2093
      285       1910
      245       1818
     1078       1818
     1026       1369
      342        935
       80        901
      307        841

Execution Summary:

       18   Executable lines in this file
       18   Lines executed
   100.00   Percent of the file executed

    19502   Total number of line executions
  1083.44   Average executions per line


*** File /home/jules/ARMemu/armemu/generators.c:
                #include <stdio.h>
                #include <stdarg.h>
                #include <stddef.h>
                
                #include "defs.h"
                #include "codegen.h"
                #include "generators.h"
                #include "x86asm.h"
                #include "pseudo.h"
                #include "analyse.h"
                #include "codegen_p.h"
                #include "registers.h"
                #include "nativesupport.h"
                #include "allocate.h"
                
                #define mk codegen_merge
                
                // Instruction encodings are built here
                // The encoding goes:
                //   <operator> <destination> <arg1> <arg2> <arg3> ... <done>
                
                hashtable* generators_register(void)
           1 -> {
                  hashtable* base = hash_new(50);
                	
                	mk(base, r_beq0, OP|op_BEQ, REGX, IMM, DONE);
                	mk(base, r_bne0, OP|op_BNE, REGX, IMM, DONE);
                	mk(base, r_bcs0, OP|op_BCS, REGX, IMM, DONE);
                	mk(base, r_bcc0, OP|op_BCC, REGX, IMM, DONE);
                	mk(base, r_bmi0, OP|op_BMI, REGX, IMM, DONE);
                	mk(base, r_bpl0, OP|op_BPL, REGX, IMM, DONE);
                	mk(base, r_bvs0, OP|op_BVS, REGX, IMM, DONE);
                	mk(base, r_bvc0, OP|op_BVC, REGX, IMM, DONE);
                	mk(base, r_bhi0, OP|op_BHI, REGX, REGY, IMM, DONE);
                	mk(base, r_bls0, OP|op_BLS, REGX, REGY, IMM, DONE);
                	mk(base, r_bge0, OP|op_BGE, REGX, REGY, IMM, DONE);
                	mk(base, r_blt0, OP|op_BLT, REGX, REGY, IMM, DONE);
                	mk(base, r_bgt0, OP|op_BGT, REGX, REGY, REGZ, IMM, DONE);
                	mk(base, r_ble0, OP|op_BLE, REGX, REGY, REGZ, IMM, DONE);
                	mk(base, r_bal0, OP|op_BAL, IMM, DONE);
                
                  // overloaded for atomic cmp/bnnx in register shift
                	mk(base, r_beq0, OP|op_BEQ, IMM, DONE);
                	mk(base, r_bne0, OP|op_BNE, IMM, DONE);
                	mk(base, r_bcs0, OP|op_BCS, IMM, DONE);
                	mk(base, r_bcc0, OP|op_BCC, IMM, DONE);
                	mk(base, r_bmi0, OP|op_BMI, IMM, DONE);
                	mk(base, r_bpl0, OP|op_BPL, IMM, DONE);
                	mk(base, r_bvs0, OP|op_BVS, IMM, DONE);
                	mk(base, r_bvc0, OP|op_BVC, IMM, DONE);
                	mk(base, r_bhi0, OP|op_BHI, IMM, DONE);
                	mk(base, r_bls0, OP|op_BLS, IMM, DONE);
                	mk(base, r_bge0, OP|op_BGE, IMM, DONE);
                	mk(base, r_blt0, OP|op_BLT, IMM, DONE);
                	mk(base, r_bgt0, OP|op_BGT, IMM, DONE);
                	mk(base, r_ble0, OP|op_BLE, IMM, DONE);
                
                #define SHIFTOP(t,T) \
                	mk(base, r_##t##0, OP|op_##T, REGX, REGX, REGY, DONE); \
                	mk(base, r_##t##1, OP|op_##T, REGX, REGY, REGZ, DONE); \
                	mk(base, r_##t##2, OP|op_##T, REGX, REGX, OP|op_CONST, REGY, IMM, DONE); \
                	mk(base, r_##t##3, OP|op_##T, REGX, REGY, OP|op_CONST, REGZ, IMM, DONE);
                	
                	SHIFTOP(lsl,LSL);
                	SHIFTOP(lsr,LSR);
                	SHIFTOP(asr,ASR);
                	SHIFTOP(ror,ROR);
                
                #undef SHIFTOP
                
                	mk(base, r_rrx0, OP|op_RRX, REGX, REGX, REGY, DONE);
                	mk(base, r_rrx1, OP|op_RRX, REGX, REGY, REGZ, DONE);
                
                	mk(base, r_const0, OP|op_CONST, REGX, IMM, DONE);
                	
                	mk(base, r_mov0, OP|op_MOV, REGX, REGX, DONE);
                	mk(base, r_mov1, OP|op_MOV, REGX, REGY, DONE);
                	mk(base, r_mov2, OP|op_MOV, REGX, OP|op_CONST, REGY, IMM, DONE);
                	
                	mk(base, r_mvn0, OP|op_MVN, REGX, REGX, DONE);
                	mk(base, r_mvn1, OP|op_MVN, REGX, REGY, DONE);
                	mk(base, r_mvn2, OP|op_MVN, REGX, OP|op_CONST, REGY, IMM, DONE);
                	
                	mk(base, r_end0, OP|op_END, DONE);
                  mk(base, r_setpc0, OP|op_SETPC, REGX, DONE);
                  mk(base, r_xjmp0, OP|op_XJMP, IMM, DONE);
                  mk(base, r_reconstructpc0, OP|op_RECONSTRUCTPC, REGX, REGY, REGZ, REGT, IMM, 
                     DONE);
                  
                  mk(base, r_swi0, OP|op_SWI, IMM, DONE);
                
                #define BINOP(t,T) \
                  mk(base, r_##t##0, OP|op_##T, REGX, REGX, REGX, DONE); \
                  mk(base, r_##t##1, OP|op_##T, REGX, REGX, REGY, DONE); \
                	mk(base, r_##t##2, OP|op_##T, REGX, REGY, REGX, DONE); \
                	mk(base, r_##t##3, OP|op_##T, REGX, REGY, REGY, DONE); \
                	mk(base, r_##t##4, OP|op_##T, REGX, REGY, REGZ, DONE); \
                	mk(base, r_##t##5, OP|op_##T, REGX, REGX, OP|op_CONST, REGY, IMM, DONE); \
                	mk(base, r_##t##6, OP|op_##T, REGX, REGY, OP|op_CONST, REGZ, IMM, DONE); \
                	mk(base, r_##t##7, OP|op_##T, REGX, OP|op_CONST, REGY, IMM, REGX, DONE); \
                	mk(base, r_##t##8, OP|op_##T, REGX, OP|op_CONST, REGY, IMM, REGZ, DONE);
                
                  BINOP(add,ADD);
                //	BINOP(adc,ADC);
                	BINOP(and,AND);
                	BINOP(or,OR);
                	BINOP(eor,EOR);
                //	BINOP(sub,SUB);
                
                #undef BINOP
                
                  mk(base, r_adc0, OP|op_ADC, REGX, REGX, REGX, REGY, DONE);
                  mk(base, r_adc1, OP|op_ADC, REGX, REGX, REGY, REGZ, DONE);
                	mk(base, r_adc2, OP|op_ADC, REGX, REGY, REGX, REGZ, DONE);
                	mk(base, r_adc3, OP|op_ADC, REGX, REGY, REGY, REGZ, DONE);
                	mk(base, r_adc4, OP|op_ADC, REGX, REGY, REGZ, REGT, DONE);
                	mk(base, r_adc5, OP|op_ADC, REGX, REGX, OP|op_CONST, REGY, IMM, REGZ, DONE);
                	mk(base, r_adc6, OP|op_ADC, REGX, REGY, OP|op_CONST, REGZ, IMM, REGT, DONE);
                	mk(base, r_adc7, OP|op_ADC, REGX, OP|op_CONST, REGY, IMM, REGX, REGZ, DONE);
                	mk(base, r_adc8, OP|op_ADC, REGX, OP|op_CONST, REGY, IMM, REGZ, REGT, DONE);
                
                  mk(base, r_sub0, OP|op_SUB, REGX, REGX, REGX, DONE);
                  mk(base, r_sub1, OP|op_SUB, REGX, REGX, REGY, DONE);
                	mk(base, r_sub2, OP|op_SUB, REGX, REGY, REGX, DONE);
                	mk(base, r_sub3, OP|op_SUB, REGX, REGY, REGY, DONE);
                	mk(base, r_sub4, OP|op_SUB, REGX, REGY, REGZ, DONE);
                	mk(base, r_sub5, OP|op_SUB, REGX, REGX, OP|op_CONST, REGY, IMM, DONE);
                	mk(base, r_sub6, OP|op_SUB, REGX, REGY, OP|op_CONST, REGZ, IMM, DONE);
                
                  mk(base, r_sbc0, OP|op_SBC, REGX, REGX, REGX, REGY, DONE);
                  mk(base, r_sbc1, OP|op_SBC, REGX, REGX, REGY, REGZ, DONE);
                	mk(base, r_sbc2, OP|op_SBC, REGX, REGY, REGX, REGZ, DONE);
                	mk(base, r_sbc3, OP|op_SBC, REGX, REGY, REGY, REGZ, DONE);
                	mk(base, r_sbc4, OP|op_SBC, REGX, REGY, REGZ, REGT, DONE);
                	mk(base, r_sbc5, OP|op_SBC, REGX, REGX, OP|op_CONST, REGY, IMM, REGZ, DONE);
                	mk(base, r_sbc6, OP|op_SBC, REGX, REGY, OP|op_CONST, REGZ, IMM, REGT, DONE);
                
                  mk(base, r_mul0, OP|op_MUL, REGX, REGX, REGX, DONE);
                  mk(base, r_mul1, OP|op_MUL, REGX, REGX, REGY, DONE);
                	mk(base, r_mul2, OP|op_MUL, REGX, REGY, REGX, DONE);
                	mk(base, r_mul3, OP|op_MUL, REGX, REGY, REGY, DONE);
                	mk(base, r_mul4, OP|op_MUL, REGX, REGY, REGZ, DONE);
                	
                #define CMPOP(t,T) \
                  mk(base, r_##t##0, OP|op_##T, REGX, REGX, DONE); \
                	mk(base, r_##t##1, OP|op_##T, REGX, REGY, DONE); \
                	mk(base, r_##t##2, OP|op_##T, REGX, OP|op_CONST, REGY, IMM, DONE);
                  
                  CMPOP(cmp,CMP);
                  CMPOP(cmn,CMN);
                  CMPOP(teq,TEQ);
                  CMPOP(tst,TST);
                
                #undef CMPOP
                
                	mk(base, r_cmp0, OP|op_CMP, REGX, REGX, DONE);
                	mk(base, r_cmp1, OP|op_CMP, REGX, REGY, DONE);
                	mk(base, r_cmp2, OP|op_CMP, REGX, OP|op_CONST, REGY, IMM, DONE);
                	
                	mk(base, r_ldw0, OP|op_LDW, REGX, REGX, DONE);
                	mk(base, r_ldw1, OP|op_LDW, REGX, REGY, DONE);
                	mk(base, r_ldb0, OP|op_LDB, REGX, REGX, DONE);
                	mk(base, r_ldb1, OP|op_LDB, REGX, REGY, DONE);
                	mk(base, r_stw0, OP|op_STW, REGX, REGX, DONE);
                	mk(base, r_stw1, OP|op_STW, REGX, REGY, DONE);
                	mk(base, r_stb0, OP|op_STB, REGX, REGX, DONE);
                	mk(base, r_stb1, OP|op_STB, REGX, REGY, DONE);
                	
                	return base;
                }
                
                #undef mk
                
                // generate function call sequence
                void generators_fncall(nativeblockinfo* native, allocationinfo* alloc,
                                       uint5 lock, void* fnaddr, sint5 dest, uint5 narg, ...)
         366 -> {
                  va_list ap;
                  uint5 i;
                  registermapping map, ra, rc, rd;
                  uint5 rm, imm, eaxst=0, ecxst, edxst;
                  uint5 alsolock = alloc->rctn[ireg_EAX].all;
                  uint5 stacked;
                  allocationinfo temp;
                
                  #ifdef DEBUG    
                  fprintf(stderr, "Locking %x\n", alsolock);
                  #endif
                /*
                  if (dest != EAX) eaxst = allocate_spill(alloc, ireg_EAX, &ra, native);
                  ecxst = allocate_spill(alloc, ireg_ECX, &rc, native);
                  edxst = allocate_spill(alloc, ireg_EDX, &rd, native);
                */
                  stacked = allocate_rpush(alloc, msk_EAX | msk_ECX | msk_EDX, native);
                  temp = *alloc;
                  
                  map = allocate_reg(alloc, reg_T5, lock | ctn_T5 | alsolock, 
                                     alloc_INVALID, native);
                  
                  va_start(ap, narg);
                
                  for (i=0; i<narg; i++)
                  {
                    uint5 t = va_arg(ap, uint5);
                    if (t==0)  // register
                    {
                      registermapping r = va_arg(ap, registermapping);
                
                      if (r.parts.status != alloc_VALID)
                      {
                        uint5 mod = mod_DISP8, disp;
                        rm = EBP;
                        if (r.parts.original<CACHEABLE)
                          disp = r.parts.original*4;
                        else
                        {
                          fprintf(stderr, "Bad register\n");
                          abort();
                        }
                        #define MODSIBDISP MODDISP8
                        x86asm_out(native, PUSHlm, 0);
                        #undef MODSIBDISP
                      }
                      else
                      {
                        rm = r.parts.mappedto;
                        x86asm_out(native, PUSHlr, 0);
                      }
                    }
                    else  // immediate
                    {
                      uint5 imm = va_arg(ap, uint5);
                      x86asm_out(native, PUSHli, 0);
                    }
                  }
                  va_end(ap);
                    
                  imm = (uint5)fnaddr;
                  rm = map.parts.mappedto;
                  x86asm_out(native, MOVlri, CALLnar, 0);
                  // goodbye args
                  imm = narg*4;
                  rm = ESP;
                  x86asm_out(native, ADDlri, 0);
                
                  if (dest != EAX && dest != -1)
                  {
                    uint5 reg = EAX;
                    rm = dest;
                    x86asm_out(native, MOVlrr, 0);
                  }
                  
                /*  if (edxst) allocate_unspill(alloc, &rd, native);
                  if (ecxst) allocate_unspill(alloc, &rc, native);
                  if (eaxst) allocate_unspill(alloc, &ra, native);*/
                  allocate_rpop(&temp, stacked, native);
                }
                
                #define INMEM(X) (mstate->regset[(X)].parts.status==alloc_MEMORY)
                
                #define ARG(X) mstate->regset[(X)].parts.mappedto
                
                #define FORCEARG(X) \
                  allocate_nsolidify(alloc, &mstate->regset[(X)], lock, native)
                
                #define MEMSETUP(F,T) \
                  uint5 mod = mod_DISP8; \
                  uint5 disp = mstate->regset[(F)].parts.original*4; \
                  uint5 rm = EBP; \
                  uint5 reg = mstate->regset[(T)].parts.mappedto;
                
                #define REGSETUP(F,T) \
                  uint5 reg = mstate->regset[(F)].parts.mappedto; \
                  uint5 rm = mstate->regset[(T)].parts.mappedto;
                
                // Unfortunately, the formal parameters for these functions are obscured by
                // the use of the GENFN macro. They are:
                // void <fn> (machineinfo* machine, blockinfo* blk, allocationinfo* alloc,
                //   matchstate* mstate, uint5 lock, uint5 flagsset)
                
                #define JUMP(t,T,O) \
                  GENFN(t##0) \
                  { \
                    hashentry* h = hash_lookup(basic, mstate->imm); \
                    basicblockinfo* bl = h ? (basicblockinfo*) h->data : 0; \
                    uint5 disp; \
                    if (((imapinfo*)info)[mstate->imm].special.flag.allocated) \
                    { \
                      allocate_coerce(alloc, &bl->startalloc, native); \
                      *alloc = bl->startalloc; \
                    } \
                    allocate_preflags(alloc, Jdef|Jundef, flagsset, native); \
                    disp = codegen_getinteladdr(basic, mstate->imm, \
                                                native->length+(O)); \
                	  x86asm_out(native, T##nr, 0); \
                    allocate_postflags(alloc, mstate, Jdef, flagsset, native); \
                  }
                
                // sometimes (bhi/bls) we need to invert the carry flag...
                #define JUMP2(t,T,O) \
                  GENFN(t##0) \
                  { \
                    hashentry* h = hash_lookup(basic, mstate->imm); \
                    basicblockinfo* bl = h ? (basicblockinfo*) h->data : 0; \
                    uint5 disp; \
                    allocate_preflags(alloc, Jdef|Jundef, flagsset, native); \
                    if (((imapinfo*)info)[mstate->imm].special.flag.allocated) \
                    { \
                      allocate_coerce(alloc, &bl->startalloc, native); \
                      *alloc = bl->startalloc; \
                    } \
                    if (!alloc->vloc[reg_CPSRC].in.invertedflag) \
                    { \
                      x86asm_out(native, CMC, 0); \
                      alloc->vloc[reg_CPSRC].in.invertedflag = 1; \
                    } \
                    disp = codegen_getinteladdr(basic, mstate->imm, native->length+(O)); \
                	  x86asm_out(native, T##nr, 0); \
                    allocate_postflags(alloc, mstate, Jdef, flagsset, native); \
                  }
                
                // the last arg is the offset of the address from the start of the instruction
          18 -> JUMP(beq,JZ,2);
          32 -> JUMP(bne,JNZ,2);
          39 -> JUMP(bcs,JC,2);
          52 -> JUMP(bcc,JNC,2);
           1 -> JUMP(bmi,JS,2);
          17 -> JUMP(bpl,JNS,2);
       ##### -> JUMP(bvs,JO,2);
       ##### -> JUMP(bvc,JNO,2);
           4 -> JUMP2(bhi,JA,2);
           1 -> JUMP2(bls,JBE,2);
           1 -> JUMP(bge,JGE,2);
           1 -> JUMP(blt,JL,2);
           6 -> JUMP(bgt,JG,2);
           2 -> JUMP(ble,JLE,2);
       ##### -> JUMP(bal,JMP,1);
                
                #undef JUMP
                #undef JUMP2
                
                // regx <- regx shift regy
                #define SHIFT0(t,T) \
                	GENFN(t##0) \
                	{ \
                		uint5 temp, reg, rm = ARG(0); \
                    registermapping f; \
                    lock |= 1<<mstate->regset[1].parts.original; \
                    FORCEARG(1); \
                    f.parts.original = mstate->regset[1].parts.original; \
                    f.parts.mapnum = ireg_ECX; \
                    f.parts.mappedto = ECX; \
                    f.parts.status = alloc_VALID; \
                    allocate_preflags(alloc, T##def|T##undef, flagsset, native); \
                		allocate_force(alloc, f, native); \
                		x86asm_out(native, T##lrc, 0); \
                    allocate_postflags(alloc, mstate, T##def, flagsset, native); \
                	}
                
                // regx <- regy shift regz
                #define SHIFT1(t,T) \
                	GENFN(t##1) \
                	{ \
                		uint5 temp, reg, rm = ARG(0); \
                    registermapping f; \
                    lock |= 1<<mstate->regset[2].parts.original; \
                    reg = FORCEARG(1); \
                    FORCEARG(2); \
                    fprintf(stderr, "rm=%d, status(0)=%d\n", rm, mstate->regset[0].parts.status); \
                    f.parts.original = mstate->regset[2].parts.original; \
                    f.parts.mapnum = ireg_ECX; \
                    f.parts.mappedto = ECX; \
                    f.parts.status = alloc_VALID; \
                    allocate_preflags(alloc, MOVdef|MOVundef|T##def|T##undef, flagsset, \
                                      native); \
                		x86asm_out(native, MOVlrr, 0); \
                		allocate_force(alloc, f, native); \
                		x86asm_out(native, T##lrc, 0); \
                    allocate_postflags(alloc, mstate, T##def, flagsset, native); \
                	}
                
                // regx <- regx shift (regy <- #imm)
                #define SHIFT2(t,T) \
                	GENFN(t##2) \
                	{ \
                  	uint5 rm = ARG(0); \
                		uint5 imm = mstate->imm; \
                    allocate_preflags(alloc, T##def|T##undef, flagsset, native); \
                		x86asm_out(native, T##lri, 0); \
                    allocate_postflags(alloc, mstate, T##def, flagsset, native); \
                	}
                
                // regx <- regy shift (regz <- #imm)
                #define SHIFT3(t,T) \
                	GENFN(t##3) \
                	{ \
                  	uint5 rm = ARG(0); \
                		uint5 reg = FORCEARG(1); \
                		uint5 imm = mstate->imm; \
                    allocate_preflags(alloc, MOVdef|MOVundef|T##def|T##undef, flagsset, \
                                      native); \
                		x86asm_out(native, MOVlrr, T##lri, 0); \
                    allocate_postflags(alloc, mstate, T##def, flagsset, native); \
                	}
                
                #define SHIFT(t,T) \
                  SHIFT0(t,T) \
                	SHIFT1(t,T) \
                	SHIFT2(t,T) \
                	SHIFT3(t,T)
                
         123 -> SHIFT(lsl,SHL);
           5 -> SHIFT(lsr,SHR);
       ##### -> SHIFT(asr,SAR);
       ##### -> SHIFT(ror,ROR);
                
                #undef SHIFT
                #undef SHIFT0
                #undef SHIFT1
                #undef SHIFT2
                #undef SHIFT3
                
                // regx <- rrx regx
                GENFN(rrx0)
       ##### -> {
                  uint5 imm = 1;
                	uint5 rm = FORCEARG(0);
                  allocate_preflags(alloc, RCRdef|RCRundef, flagsset, native);
                	x86asm_out(native, RCRlri, 0);
                  allocate_postflags(alloc, mstate, RCRdef, flagsset, native);
                }
                
                // regx <- rrx regy
                GENFN(rrx1)
       ##### -> {
                  uint5 imm = 1;
                	uint5 reg = FORCEARG(1);
                	uint5 rm = ARG(0);
                  allocate_preflags(alloc, MOVdef|MOVundef|RCRdef|RCRundef, flagsset,
                                    native);
                	x86asm_out(native, MOVlrr, RCRlri, 0);
                  allocate_postflags(alloc, mstate, RCRdef, flagsset, native);
                }
                
                // regx <- #imm
                GENFN(const0)
         166 -> {
                  uint5 rm = ARG(0);
                	uint5 imm = mstate->imm;
                  if (mstate->regset[0].parts.original==reg_CPSRC)  // ooh, special case
                  {
                    allocate_preflags(alloc, STCdef|STCundef, flagsset, native);
                    if (imm==1)
                      x86asm_out(native, STC, 0);
                    else
                      x86asm_out(native, CLC, 0);
                    allocate_postflags(alloc, mstate, STCdef, flagsset, native);
                  }
                  else
                  {
                    allocate_preflags(alloc, MOVdef|MOVundef, flagsset, native);
                    x86asm_out(native, MOVlri, 0);
                    allocate_postflags(alloc, mstate, MOVdef, flagsset, native);
                  }
                }
                
                // regx <- regx
                GENFN(mov0)
           1 -> {
                  FORCEARG(0);
                  allocate_preflags(alloc, MOVdef|MOVundef, flagsset, native);
                  allocate_postflags(alloc, mstate, MOVdef, flagsset, native);
                }
                
                // regx <- regy
                GENFN(mov1)
         146 -> {
                  if (mstate->regset[1].parts.original>=reg_CPSRC &&
                      mstate->regset[1].parts.original<=reg_CPSRN)
                  {
                    uint5 mod, rm, disp, reg;
                
                    // ensure this flag is spilled to memory
                    allocate_preflags(alloc, 1<<(mstate->regset[1].parts.original-reg_CPSRC),
                      0, native);
                
                    mod = mod_DISP8;
                    rm = EBP;
                    switch (mstate->regset[1].parts.original)
                    {
                      case reg_CPSRC: disp = offsetof(registerinfo, cflag); break;
                      case reg_CPSRV: disp = offsetof(registerinfo, vflag); break;
                      case reg_CPSRN: disp = offsetof(registerinfo, nflag); break;
                      case reg_CPSRZ: disp = offsetof(registerinfo, zflag); break;
                    }
                    reg = ARG(0);
                    #define MODSIBDISP MODDISP8
                    x86asm_out(native, MOVZXlrbm, 0);
                    #undef MODSIBDISP
                    allocate_postflags(alloc, mstate,
                      1<<(mstate->regset[1].parts.original-reg_CPSRC), 0, native);
                  }
                  else
                  {
                    allocate_preflags(alloc, MOVdef|MOVundef, flagsset, native);
                    if (INMEM(1))
                    {
                      MEMSETUP(1,0);
                      #define MODSIBDISP MODDISP8
                      x86asm_out(native, MOVlrm, 0);
                      #undef MODSIBDISP
                    }
                    else
                    {
                      REGSETUP(1,0);
                      x86asm_out(native, MOVlrr, 0);
                    }
                    allocate_postflags(alloc, mstate, MOVdef, flagsset, native);
                  }
                }
                
                // regx <- (regy <- #imm)
                GENFN(mov2)
          40 -> {
                  uint5 rm = ARG(0);
                	uint5 imm = mstate->imm;
                  if (mstate->regset[0].parts.original==reg_CPSRC)  // ooh, special case
                  {
                    allocate_preflags(alloc, STCdef|STCundef, flagsset, native);
                    if (imm==1)
                      x86asm_out(native, STC, 0);
                    else
                      x86asm_out(native, CLC, 0);
                    allocate_postflags(alloc, mstate, STCdef, flagsset, native);
                  }
                  else
                  {
                    allocate_preflags(alloc, MOVdef|MOVundef, flagsset, native);
                  	x86asm_out(native, MOVlri, 0);
                    allocate_postflags(alloc, mstate, MOVdef, flagsset, native);
                  }
                }
                
                // regx <- ~regx
                GENFN(mvn0)
       ##### -> {
                  uint5 rm = FORCEARG(0);
                  allocate_preflags(alloc, NOTdef|NOTundef, flagsset, native);
                	x86asm_out(native, NOTlr, 0);
                  allocate_postflags(alloc, mstate, NOTdef, flagsset, native);
                }
                
                // regx <- ~regy
                GENFN(mvn1)
           1 -> {
                  uint5 rm = ARG(0);
                	uint5 reg = FORCEARG(1);
                  allocate_preflags(alloc, NOTdef|NOTundef|MOVdef|MOVundef, flagsset,
                                    native);
                	x86asm_out(native, MOVlrr, NOTlr, 0);
                  allocate_postflags(alloc, mstate, NOTdef, flagsset, native);
                }
                
                // regx <- ~(regy <- #imm)
                GENFN(mvn2)
           6 -> {
                  uint5 rm = ARG(0);
                	uint5 imm = ~mstate->imm;
                  allocate_preflags(alloc, MOVdef|MOVundef, flagsset, native);
                	x86asm_out(native, MOVlri, 0);
                  allocate_postflags(alloc, mstate, MOVdef, flagsset, native);
                }
                
                GENFN(end0)
          62 -> {
                  allocate_preflags(alloc, ALLFLAGS, 0, native);
                  allocate_reset(alloc, native);
                  x86asm_out(native, RET, 0);
                }
                
                GENFN(setpc0)
          92 -> {
                  uint5 imm = 8, mod, disp;
                  uint5 rm = FORCEARG(0);
                  
                  allocate_preflags(alloc, ADDdef|ADDundef, 0, native);
                  x86asm_out(native, ADDlri, 0);
                  allocate_postflags(alloc, mstate, ADDdef, 0, native);
                
                  if (flagsset!=ALLFLAGS)
                  {
                    imm = ~0xfc000003;
                    allocate_preflags(alloc, ANDdef|ANDundef, 0, native);
                    x86asm_out(native, ANDlri, 0);
                  }
                  else
                  {
                    // Here, a (26-bit) program counter will have status bits included in the
                    // main program counter. We need to split them back out into their
                    // easy-access containers.
                    #ifdef ARM26BIT
                    allocate_preflags(alloc, BTdef|BTundef|ANDdef|ANDundef|SETdef|SETundef, 
                      flagsset, native);
                
                    #define FLAGFROMPC(f,o) \
                      mod = mod_DISP8; \
                      imm = (o); \
                      rm = ARG(0); \
                      x86asm_out(native, BTlri, 0); \
                      disp = offsetof(registerinfo, f##flag); \
                      rm = EBP; \
                      x86asm_out(native, SETCm, 0);
                
                    #define MODSIBDISP MODDISP8
                    FLAGFROMPC(v,28);
                    FLAGFROMPC(c,29);
                    FLAGFROMPC(z,30);
                    FLAGFROMPC(n,31);
                    #undef MODSIBDISP
                    #undef FLAGFROMPC
                
                    rm = ARG(0);
                    imm = ~0xfc000003;
                    x86asm_out(native, ANDlri, 0);
                    
                //    allocate_postflags(alloc, mstate, 0, flagsset, native);
                    alloc->vloc[reg_CPSRC].all
                      = alloc->vloc[reg_CPSRV].all
                      = alloc->vloc[reg_CPSRN].all
                      = alloc->vloc[reg_CPSRZ].all = var_MEM;
                    #else
                    #error "32-bit mode not supported yet"
                    #endif
                  }
                
                  // call npostfix early to mark pc as valid, not in memory...
                  allocate_npostfix(alloc, mstate);
                
                  allocate_reset(alloc, native);
                  // this is probably a no-op
                  allocate_preflags(alloc, ALLFLAGS, 0, native);
                  x86asm_out(native, RET, 0);
                }
                
                // if the value of the PC is used (eg, in an arithmetic op or if it's saved),
                // it needs to have the correct status bits set (in 26-bit mode). Here we
                // mock-up what the PC would have looked like when executing the original ARM
                // code.
                GENFN(reconstructpc0)
          42 -> {
                  allocate_preflags(alloc, ALLFLAGS, 0, native);
                  generators_fncall(native, alloc, lock, (void*)&nativesupport_reconstructpc,
                    ARG(0), 2, 1, machine->reg, 1, mstate->imm);
                }
                
                // jump directly to another block of x86 code
                GENFN(xjmp0)
          21 -> {
                  blockinfo* destblk = (blockinfo*) mstate->imm;
                  uint5 imm = (uint5)destblk->native->base;
                  registermapping temp = allocate_reg(alloc, reg_T5, lock | ctn_T5,
                                                      alloc_INVALID, native);
                  uint5 rm = temp.parts.mappedto;
                  allocate_preflags(alloc, ALLFLAGS, 0, native);
                  allocate_reset(alloc, native);
                  x86asm_out(native, MOVlri, JMPnar, 0);
                }
                
                GENFN(swi0)
           1 -> {
                  uint5 number = mstate->imm;
                  // massage to state at start of this block (ie, start of any block)
                  allocate_reset(alloc, native);
                  allocate_preflags(alloc, ALLFLAGS, 0, native);
                  generators_fncall(native, alloc, lock, (void*)&nativesupport_swi, -1, 2, 
                    1, number, 1, machine);
                }
                
                // LOGICx macros should work OK for some commutative operators
                
                #define INVCHECK
                
                // regx <- regx op regx
                #define LOGIC0(t,T) \
                  GENFN(t##0) \
                	{ \
                	  uint5 reg = FORCEARG(0); \
                		uint5 rm = reg; \
                    allocate_preflags(alloc, T##def|T##undef, flagsset, native); \
                    INVCHECK \
                		x86asm_out(native, T##lrr, 0); \
                    allocate_postflags(alloc, mstate, T##def, flagsset, native); \
                	}
                
                // regx <- regx op regy
                #define LOGIC1(t,T) \
                  GENFN(t##1) \
                	{ \
                    allocate_preflags(alloc, T##def|T##undef, flagsset, native); \
                    FORCEARG(0); \
                    INVCHECK \
                    if (INMEM(1)) \
                    { \
                      MEMSETUP(1,0); \
                      x86asm_out(native, T##lrm, 0); \
                    } \
                    else \
                    { \
                      REGSETUP(1,0); \
                		  x86asm_out(native, T##lrr, 0); \
                    } \
                    allocate_postflags(alloc, mstate, T##def, flagsset, native); \
                	}
                
                // regx <- regy op regx
                #define LOGIC2(t,T) \
                  GENFN(t##2) \
                	{ \
                    allocate_preflags(alloc, T##def|T##undef, flagsset, native); \
                    FORCEARG(0); \
                    INVCHECK \
                    if (INMEM(1)) \
                    { \
                      MEMSETUP(1,0); \
                      x86asm_out(native, T##lrm, 0); \
                    } \
                    else \
                    { \
                      REGSETUP(1,0); \
                		  x86asm_out(native, T##lrr, 0); \
                    } \
                    allocate_postflags(alloc, mstate, T##def, flagsset, native); \
                	}
                
                // regx <- regy op regy
                #define LOGIC3(t,T) \
                  GENFN(t##3) \
                	{ \
                	  uint5 reg = FORCEARG(1); \
                		uint5 rm = ARG(0); \
                    allocate_preflags(alloc, T##def|T##undef|MOVdef|MOVundef, flagsset, \
                                      native); \
                    INVCHECK \
                    x86asm_out(native, MOVlrr, 0); \
                		reg = rm; \
                		x86asm_out(native, T##lrr, 0); \
                    allocate_postflags(alloc, mstate, T##def, flagsset, native); \
                	}
                
                // regx <- regy op regz
                #define LOGIC4(t,T) \
                  GENFN(t##4) \
                	{ \
                    allocate_preflags(alloc, T##def|T##undef|MOVdef|MOVundef, flagsset, \
                                      native); \
                    INVCHECK \
                    if (INMEM(1)) \
                    { \
                      MEMSETUP(1,0); \
                	    x86asm_out(native, MOVlrm, 0); \
                    } \
                    else \
                    { \
                      REGSETUP(1,0); \
                      x86asm_out(native, MOVlrr, 0); \
                    } \
                    if (INMEM(2)) \
                    { \
                      MEMSETUP(2,0); \
                      x86asm_out(native, T##lrm, 0); \
                    } \
                    else \
                    { \
                      REGSETUP(2,0); \
                		  x86asm_out(native, T##lrr, 0); \
                    } \
                    allocate_postflags(alloc, mstate, T##def, flagsset, native); \
                	}
                
                // regx <- regx op (regy <- #imm)
                #define LOGIC5(t,T) \
                  GENFN(t##5) \
                	{ \
                	  uint5 rm = FORCEARG(0); \
                		uint5 imm = mstate->imm; \
                    allocate_preflags(alloc, T##def|T##undef, flagsset, native); \
                    INVCHECK \
                		x86asm_out(native, T##lri, 0); \
                    allocate_postflags(alloc, mstate, T##def, flagsset, native); \
                	}
                
                // regx <- regy op (regz <- #imm)
                #define LOGIC6(t,T) \
                  GENFN(t##6) \
                	{ \
                    uint5 reg = FORCEARG(1); \
                		uint5 rm = ARG(0); \
                		uint5 imm = mstate->imm; \
                    allocate_preflags(alloc, T##def|T##undef|MOVdef|MOVundef, flagsset, \
                                      native); \
                    INVCHECK \
                		x86asm_out(native, MOVlrr, T##lri, 0); \
                    allocate_postflags(alloc, mstate, T##def, flagsset, native); \
                	}
                
                // regx <- (regy <- #imm) op regx
                #define LOGIC7(t,T) \
                  GENFN(t##7) \
                	{ \
                	  uint5 rm = FORCEARG(0); \
                		uint5 imm = mstate->imm; \
                    allocate_preflags(alloc, T##def|T##undef, flagsset, native); \
                    INVCHECK \
                		x86asm_out(native, T##lri, 0); \
                    allocate_postflags(alloc, mstate, T##def, flagsset, native); \
                	}
                
                // regx <- (regy <- #imm) op regz
                #define LOGIC8(t,T) \
                  GENFN(t##8) \
                	{ \
                	  uint5 reg = FORCEARG(2); \
                		uint5 rm = ARG(0); \
                		uint5 imm = mstate->imm; \
                    allocate_preflags(alloc, T##def|T##undef|MOVdef|MOVundef, flagsset, \
                                      native); \
                    INVCHECK \
                		x86asm_out(native, MOVlrr, T##lri, 0); \
                    allocate_postflags(alloc, mstate, T##def, flagsset, native); \
                	}
                
                #define LOGIC(t,T) \
                  LOGIC0(t,T) \
                	LOGIC1(t,T) \
                	LOGIC2(t,T) \
                	LOGIC3(t,T) \
                	LOGIC4(t,T) \
                	LOGIC5(t,T) \
                	LOGIC6(t,T) \
                	LOGIC7(t,T) \
                	LOGIC8(t,T)
                
                // expand for the following...
                #define MODSIBDISP MODDISP8
         186 -> LOGIC(add,ADD);
       ##### -> LOGIC(adc,ADC);
          14 -> LOGIC(and,AND);
           3 -> LOGIC(or,OR);
           8 -> LOGIC(eor,XOR);
                
                // regx <- regy op regx, non-commutative
                #define NONCOM2(t,T) \
                  GENFN(t##2) \
                  { \
                    uint5 reg; \
                    uint5 rm; \
                    allocate_preflags(alloc, XCHGdef|XCHGundef|T##def|T##undef, flagsset, \
                                      native); \
                    INVCHECK \
                    rm = FORCEARG(1); \
                    x86asm_out(native, PUSHlr, 0); \
                    reg = rm; \
                    rm = FORCEARG(0); \
                    x86asm_out(native, XCHGlrr, T##lrr, 0); \
                    rm = reg; \
                    x86asm_out(native, POPlr, 0); \
                    allocate_postflags(alloc, mstate, SUBdef, flagsset, native); \
                  }
                
                // although sub isn't commutative, these ones should be fine
       ##### -> LOGIC0(sub,SUB);
          26 -> LOGIC1(sub,SUB);
          16 -> NONCOM2(sub,SUB);
       ##### -> LOGIC3(sub,SUB);
           1 -> LOGIC4(sub,SUB);
         179 -> LOGIC5(sub,SUB);
          68 -> LOGIC6(sub,SUB);
                
                #undef INVCHECK
                #define INVCHECK \
                  if (!alloc->vloc[reg_CPSRC].in.invertedflag) \
                  { \
                    x86asm_out(native, CMC, 0); \
                    alloc->vloc[reg_CPSRC].in.invertedflag = 1; \
                  }
                
       ##### -> LOGIC0(sbc,SBB);
       ##### -> LOGIC1(sbc,SBB);
       ##### -> NONCOM2(sbc,SBB);
       ##### -> LOGIC3(sbc,SBB);
       ##### -> LOGIC4(sbc,SBB);
       ##### -> LOGIC5(sbc,SBB);
       ##### -> LOGIC6(sbc,SBB);
                
                #undef INVCHECK
                #define INVCHECK
                #undef MODSIBDISP
                
                /*
                // regx <- (regy <- #imm) - regx
                GENFN(sub7)
                {
                	uint5 rm = FORCEARG(0);
                	uint5 imm = mstate->imm;
                  allocate_preflags(alloc, NEGdef|NEGundef|SUBdef|SUBundef, flagsset,
                                    native);
                	x86asm_out(native, SUBlri, NEGlr, 0);
                  allocate_postflags(alloc, mstate, SUBdef, flagsset, native,
                                     &blk->natlength);
                }
                
                // regx <- (regy <- #imm) - regz
                GENFN(sub8)
                {
                	uint5 reg = FORCEARG(2);
                	uint5 rm = ARG(0);
                	uint5 imm = mstate->imm;
                  allocate_preflags(alloc, NEGdef|NEGundef|SUBdef|SUBundef, flagsset,
                                    native);
                	x86asm_out(native, MOVlrr, SUBlri, NEGlr, 0);
                  allocate_postflags(alloc, mstate, SUBdef, flagsset, native,
                                     &blk->natlength);
                }
                */
                
                #undef LOGIC
                #undef LOGIC0
                #undef LOGIC1
                #undef LOGIC2
                #undef LOGIC3
                #undef LOGIC4
                #undef LOGIC5
                #undef LOGIC6
                #undef LOGIC7
                #undef LOGIC8
                
                // regx <- regx * regx
                GENFN(mul0)
       ##### -> {
                  uint5 rm = FORCEARG(0);
                  uint5 reg = rm;
                  allocate_preflags(alloc, IMULdef|IMULundef, flagsset, native);
                	x86asm_out(native, IMULlrr, 0);
                  allocate_postflags(alloc, mstate, IMULdef, flagsset, native);
                }
                
                // regx <- regx * regy
                GENFN(mul1)
       ##### -> {
                  uint5 rm = FORCEARG(0);
                  uint5 reg = FORCEARG(1);
                  allocate_preflags(alloc, IMULdef|IMULundef, flagsset, native);
                	x86asm_out(native, IMULlrr, 0);
                  allocate_postflags(alloc, mstate, IMULdef, flagsset, native);
                }
                
                // regx <- regy * regx
                GENFN(mul2)
           1 -> {
                  uint5 rm = FORCEARG(0);
                  uint5 reg = FORCEARG(1);
                  allocate_preflags(alloc, IMULdef|IMULundef, flagsset, native);
                	x86asm_out(native, IMULlrr, 0);
                  allocate_postflags(alloc, mstate, IMULdef, flagsset, native);
                }
                
                // regx <- regy * regy
                GENFN(mul3)
       ##### -> {
                  uint5 rm = ARG(0);
                  uint5 reg = FORCEARG(1);
                  allocate_preflags(alloc, MOVdef|MOVundef|IMULdef|IMULundef, flagsset,
                                    native);
                	x86asm_out(native, MOVlrr, 0);
                	reg = rm;
                	x86asm_out(native, IMULlrr, 0);
                  allocate_postflags(alloc, mstate, IMULdef, flagsset, native);
                }
                
                // regx <- regy * regz
                GENFN(mul4)
       ##### -> {
                  uint5 rm = ARG(0);
                	uint5 reg = FORCEARG(1);
                  allocate_preflags(alloc, MOVdef|MOVundef|IMULdef|IMULundef, flagsset,
                                    native);
                	x86asm_out(native, MOVlrr, 0);
                	reg = FORCEARG(2);
                	x86asm_out(native, IMULlrr, 0);
                  allocate_postflags(alloc, mstate, IMULdef, flagsset, native);
                }
                
                // regx cmp regx
                #define COMPARE0(t,T) \
                  GENFN(t##0) \
                  { \
                    uint5 rm = FORCEARG(0); \
                	  uint5 reg = rm; \
                    allocate_preflags(alloc, T##def|T##undef, flagsset, native); \
                	  x86asm_out(native, T##lrr, 0); \
                    allocate_postflags(alloc, mstate, T##def, flagsset, native); \
                  }
                
                // regx cmp regy
                #define COMPARE1(t,T) \
                  GENFN(t##1) \
                  { \
                    allocate_preflags(alloc, T##def|T##undef, flagsset, native); \
                    FORCEARG(0); \
                    if (INMEM(1)) \
                    { \
                      MEMSETUP(1,0); \
                      x86asm_out(native, T##lrm, 0); \
                    } \
                    else \
                    { \
                      REGSETUP(1,0); \
                      x86asm_out(native, T##lrr, 0); \
                    } \
                    allocate_postflags(alloc, mstate, T##def, flagsset, native); \
                  }
                
                // regx cmp (regy <- #imm)
                #define COMPARE2(t,T) \
                  GENFN(t##2) \
                  { \
                    uint5 rm = FORCEARG(0); \
                	  uint5 imm = mstate->imm; \
                    allocate_preflags(alloc, T##def|T##undef, flagsset, native); \
                	  x86asm_out(native, T##lri, 0); \
                    allocate_postflags(alloc, mstate, T##def, flagsset, native); \
                  }
                
                #define COMPARE(t,T) \
                  COMPARE0(t,T) \
                  COMPARE1(t,T) \
                  COMPARE2(t,T)
                
                // null <- regx cmp regx
                #define COMPAREB0(t,T) \
                  GENFN(t##0) \
                  { \
                    uint5 reg = FORCEARG(0); \
                	  registermapping temp = allocate_reg(alloc, reg_T5, lock | ctn_T5, \
                                                        alloc_INVALID, native); \
                    uint5 rm = temp.parts.mappedto; \
                    allocate_preflags(alloc, T##def|T##undef, flagsset, native); \
                	  x86asm_out(native, MOVlrr, 0); \
                    reg = rm; \
                    x86asm_out(native, T##lrr, 0); \
                    allocate_postflags(alloc, mstate, T##def, flagsset, native); \
                  }
                
                // null <- regx cmp regy
                #define COMPAREB1(t,T) \
                  GENFN(t##1) \
                  { \
                    registermapping temp = allocate_reg(alloc, reg_T5, lock | ctn_T5, \
                                                        alloc_INVALID, native); \
                    allocate_preflags(alloc, T##def|T##undef|MOVdef|MOVundef, flagsset, \
                                      native); \
                    mstate->regset[2] = mstate->regset[1]; \
                    mstate->regset[1] = mstate->regset[0]; \
                    mstate->regset[0] = temp; \
                    INVCHECK \
                    if (INMEM(1)) \
                    { \
                      MEMSETUP(1,0); \
                	    x86asm_out(native, MOVlrm, 0); \
                    } \
                    else \
                    { \
                      REGSETUP(1,0); \
                      x86asm_out(native, MOVlrr, 0); \
                    } \
                    if (INMEM(2)) \
                    { \
                      MEMSETUP(2,0); \
                      x86asm_out(native, T##lrm, 0); \
                    } \
                    else \
                    { \
                      REGSETUP(2,0); \
                		  x86asm_out(native, T##lrr, 0); \
                    } \
                    allocate_postflags(alloc, mstate, T##def, flagsset, native); \
                  }
                
                // null <- regx cmp (regy <- #imm)
                #define COMPAREB2(t,T) \
                  GENFN(t##2) \
                  { \
                    uint5 reg = FORCEARG(0); \
                		registermapping temp = allocate_reg(alloc, reg_T5, lock | ctn_T5, \
                                                        alloc_INVALID, native); \
                		uint5 imm = mstate->imm, rm = temp.parts.mappedto; \
                    allocate_preflags(alloc, T##def|T##undef|MOVdef|MOVundef, flagsset, \
                                      native); \
                    INVCHECK \
                		x86asm_out(native, MOVlrr, T##lri, 0); \
                    allocate_postflags(alloc, mstate, T##def, flagsset, native); \
                  }
                
                #define COMPAREB(t,T) \
                  COMPAREB0(t,T) \
                  COMPAREB1(t,T) \
                  COMPAREB2(t,T)
                
                #define MODSIBDISP MODDISP8
         108 -> COMPARE(cmp,CMP);
           5 -> COMPARE(tst,TEST);
                // no direct analogues for these two, unfortunately
       ##### -> COMPAREB(teq,XOR);
       ##### -> COMPAREB(cmn,ADD);
                #undef MODSIBDISP
                
                #define LOAD(n,f,s,d) \
                  GENFN(n) \
                  { \
                    generators_fncall(native, alloc, lock, (void*)&(f), ARG(s), 2, \
                      0, mstate->regset[d], 1, machine->mem); \
                  }
                
                // regx <- !regx
       ##### -> LOAD(ldw0, nativesupport_readword, 0, 0);
                
                // regx <- !regy
         155 -> LOAD(ldw1, nativesupport_readword, 0, 1);
                
                // regx <- ?regx
       ##### -> LOAD(ldb0, nativesupport_readbyte, 0, 0);
                
                // regx <- ?regy
          22 -> LOAD(ldb1, nativesupport_readbyte, 0, 1);
                
                #define STORE(n,f,s,d) \
                  GENFN(n) \
                  { \
                    generators_fncall(native, alloc, lock, (void*)&(f), -1, 3, \
                      0, mstate->regset[d], \
                      0, mstate->regset[s], \
                      1, machine->mem); \
                  }
                
                // !regx <- regx
       ##### -> STORE(stw0, nativesupport_writeword, 0, 0);
                
                // !regx <- regy
         139 -> STORE(stw1, nativesupport_writeword, 0, 1);
                
                // ?regx <- regx
       ##### -> STORE(stb0, nativesupport_writebyte, 0, 0);
                
                // ?regx <- regy
           7 -> STORE(stb1, nativesupport_writebyte, 0, 1);
                


Top 10 Lines:

     Line      Count

      177        366
      845        186
      876        179
      447        166
     1128        155
      477        146
     1149        139
      412        123
     1110        108
      582         92

Execution Summary:

       71   Executable lines in this file
       71   Lines executed
   100.00   Percent of the file executed

     2185   Total number of line executions
    30.77   Average executions per line


*** File /home/jules/ARMemu/armemu/hash.c:
                #include <stdio.h>
                
                #include "cnew.h"
                #include "hash.h"
                
                hashtable* hash_new(uint5 size)
         599 -> {
                  hashtable* htab = cnew(hashtable);
                	uint5 i;
                	
                	htab->table = cnewarray(list, size);
                	htab->entries = 0;
                	htab->size = size;
                	
                	for (i=0; i<size; i++)
                	{
                	  htab->table[i] = 0;
                	}
                	
                	return htab;
                }
                
                // use a simple hashing scheme for now...
                #define HASHFN(K,S) ((K)%(S))
                
                hashentry* hash_insert(hashtable* hash, uint5 key)
        5331 -> {
                  hashentry* entry;
                	uint5 loc = HASHFN(key, hash->size);
                	list* item, *theitem=0;
                	
                	for (item=hash->table[loc]; item; item=item->prev)
                	{
                	  hashentry* h = (hashentry*) item->data;
                
                		if (h->key==key)
                		{
                		  theitem = item;
                			entry = item->data;
                	    break;
                		}
                	}
                	
                	if (!theitem)
                	{
                	  theitem = list_add(&hash->table[loc]);
                  	theitem->data = entry = cnew(hashentry);
                  	entry->key = key;
                  	entry->data = 0;
                		hash->entries++;
                	}
                
                	return entry;
                }
                
                // this gives you back your data pointer, cos you have to free that yourself
                void* hash_remove(hashtable* hash, uint5 key)
       ##### -> {
                  uint5 loc = HASHFN(key, hash->size);
                  list* item, *theitem=0;
                	void* hashentrydata=0;
                	
                	for (item=hash->table[loc]; item;)
                	{
                	  list* prev = item->prev;
                		hashentry* h = (hashentry*) item->data;
                
                		if (h->key==key)
                		{
                		  hashentrydata = h->data;
                		  free(h);
                		  list_delinkitem(&hash->table[loc], item);
                			hash->entries--;
                		}
                		
                		item = prev;
                	}
                	
                	return hashentrydata;
                }
                
                // delete an entry, calling a destructor function
                void hash_delete(hashtable* hash, uint5 key, hashdestructor_fn destructor)
       ##### -> {
                  void* data = hash_remove(hash, key);
                	destructor(data);
                }
                
                // destroy an entire hash table, plus all its contents
                void hash_nuke(hashtable* hash, hashdestructor_fn destructor)
         248 -> {
                  list* w;
                	uint5 i;
                	
                	for (i=0; i<hash->size; i++)
                	{
                	  while (hash->table[i])
                		{
                		  if (destructor) destructor(hash->table[i]->data);
                			list_removehead(&hash->table[i]);
                		}
                	}
                
                	free(hash->table);
                	free(hash);
                }
                
                hashentry* hash_lookup(hashtable* hash, uint5 key)
     3240082 -> {
                	uint5 loc = HASHFN(key, hash->size);
                	list* item;
                	
                  
                	for (item=hash->table[loc]; item; item=item->prev)
                	{
                	  hashentry* h = (hashentry*) item->data;
                		if (h->key==key) return h;
                	}
                
                	return 0;
                }


Top 10 Lines:

     Line      Count

      109    3240082
       27       5331
        7        599
       91        248

Execution Summary:

        6   Executable lines in this file
        6   Lines executed
   100.00   Percent of the file executed

  3246260   Total number of line executions
541043.33   Average executions per line


*** File /home/jules/ARMemu/armemu/codegen.c:
                #include <assert.h>
                #include <stdarg.h>
                #include <stdio.h>
                #include <stddef.h>
                
                #include "cnew.h"
                #include "defs.h"
                #include "machine.h"
                #include "codegen.h"
                #include "allocate.h"
                #include "hash.h"
                #include "pseudo.h"
                #include "registers.h"
                #include "x86asm.h"
                #include "block.h"
                #include "analyse.h"
                #include "codegen_p.h"
                #include "pqueue.h"
                
                /*  no longer used
                x86node* codegen_newnode(void)
                {
                	x86node* n = cnew(x86node);
                	n->branch = 0;
                //	n->rule = 0;
                	return n;
                }*/
                
                // merge an entry into instruction pattern tree
                void codegen_merge(hashtable* ht, gen_fn rule, ...)
         146 -> {
                  va_list ap;
                	regclass c;
                  hashentry* entry;
                
                	va_start(ap, rule);
                
                	while (c=va_arg(ap, uint5))
                	{
                		entry = hash_insert(ht, c);
                		if (!entry->data) entry->data = hash_new(3);
                    ht = (hashtable*) entry->data;
                	}
                
                	// stick the code in
                	entry = hash_insert(ht, CODEGEN);
                	entry->data = rule;
                
                	va_end(ap);
                }
                
                // return either previously-assigned or new placeholder for a register
                static uint5 queryreg(matchstate* ms, uint5 reg)
        4219 -> {
                  const static uint5 rtypemap[] = {REGX, REGY, REGZ, REGT, REGU, REGV};
                  uint5 i;
                
                	for (i=0; i<ms->num; i++)
                    if (ms->regset[i].parts.original==reg) return rtypemap[i];
                
                	ms->regset[ms->num].parts.original = reg;
                
                  return rtypemap[ms->num++];
                }
                
                // don't use this function
                static void killreg(matchstate* ms, uint5 reg)
       ##### -> {
                  uint5 i;
                  
                  for (i=0; i<ms->num; i++)
                    if (ms->regset[i].parts.original==reg)
                      ms->regset[i].parts.original = reg_UNUSED;
                }
                
                // try to follow a branch in pattern tree; returns 1 if successful
                static uint5 follow(hashtable** patfsm, uint5 key)
        9552 -> {
                  hashentry* e = *patfsm ? hash_lookup(*patfsm, key) : 0;
                  #ifdef DEBUG2
                	static const char* typestring[] = {"done", "ignore", "imm", "regx", "regy",
                	                                   "regz", "regt", "regu", "regv", "codegen"};
                	extern const char* opname[];
                //	x86node* node = e->data;
                
                  fprintf(stderr, "%x: ", *patfsm);
                
                  if (key & (1U<<16))
                	  fprintf(stderr, "%s following op '%s'\n", e ? "successfully" :
                		                "unsuccessfully", opname[key&65535U]);
                	else
                  	fprintf(stderr, "%s following '%s'\n", e ? "successfully" :
                		        "unsuccessfully", typestring[key]);
                  #endif
                	if (!e) return 0;
                
                	*patfsm = (hashtable*)e->data;
                	return 1;
                }
                
                // see if an instruction matches, and if it does, set the code generation rule
                // to the one from the pattern tree
                uint5 codegen_rulify(hashtable* root, hashtable* itree, blockinfo* blk, 
                                     gencontext* ctxt, uint5 srcptr)
        2432 -> {
                	hashentry* thing;
                	gen_fn rulefn=0;
                	
                	if (!(blk->psb->info)[srcptr].rule)
                	{
                  	if (codegen_match(root, itree, blk, ctxt, srcptr, &rulefn, 0))
                		{
                  		// fill in rule code
                			if (!rulefn) return 0;
                    	blk->psb->info[srcptr].rule = rulefn;
                			blk->psb->info[srcptr].mstate = ctxt->mstate;
                //			fprintf(stderr, "Overwrite=%x\n", ctxt->mstate.overwrite);
                		  return 1;
                		}
                	}
                	else
                	{
                    #ifdef DEBUG4
                	  fprintf(stderr, "Already a rule at %x\n", srcptr);
                    #endif
                	  return 1;
                	}
                	return 0;
                }
                
                // match an instruction, possibly assimilating previous instructions
                uint5 codegen_match(hashtable* root, hashtable* itree, blockinfo* blk, 
                                    gencontext* ctxt, uint5 srcptr, gen_fn* rulefn,
                                    hashtable** writeback)
        2264 -> {
                  pseudoformat* inst = (pseudoformat*)&blk->psb->base[srcptr];
                	endpoint edgekey, last, next;
                	hashentry* edge, *elast, *enext;
                	hashentry* r;
                  #ifdef DEBUG4
                	const static char* secname[] = {"rd", "rm", "rn", "ro", "cflag", "vflag",
                  			                          "nflag", "zflag"};
                		
                  fprintf(stderr, "Matching instruction at %x\n", srcptr);
                  #endif
                	
                	// see if <instruction> matches
                	if (!follow(&itree, OP|inst->parts.opcode)) return 0;
                
                	// see if <rd> matches in this context
                	if (inst->parts.rd != reg_UNUSED)
                	{
                	  if (!follow(&itree, queryreg(&ctxt->mstate, inst->parts.rd)))
                		  return 0;
                		/*if (inst->parts.rd != inst->parts.rm &&
                		    inst->parts.rd != inst->parts.rn &&
                				inst->parts.rd != inst->parts.ro) */
                    ctxt->mstate.overwrite |= 1;
                	}
                
                  // preprocessor abuse follows:
                	
                #define CHECKBACK(S,N,B) \
                  edgekey.parts.address = srcptr; \
                	edgekey.parts.section = (S); \
                	elast = hash_lookup(blk->lastset, edgekey.value); \
                	last.value = elast ? (uint5) elast->data : -1; \
                	enext = hash_lookup(blk->nextused, edgekey.value); \
                	next.value = enext ? (uint5) enext->data : -1; \
                	if (elast && codegen_match(root, itree, blk, ctxt, last.parts.address, \
                      rulefn, &itree) && (!enext || (enext && codegen_rulify(root, root, blk, \
                      ctxt, next.parts.address)))) \
                	{ \
                	  EATEN \
                	  blk->psb->info[last.parts.address].rule = 0; \
                		ctxt->mstate.hidden |= (B); \
                	} \
                	else \
                	{ \
                	  if (inst->parts.##N != reg_UNUSED && !follow(&itree, \
                		  queryreg(&ctxt->mstate, inst->parts.##N))) return 0; \
                	}
                
                  #ifdef DEBUG4
                  #define EATEN fprintf(stderr, "Assimilating instruction at %x\n", \
                                last.parts.address);
                  #else
                  #define EATEN
                  #endif
                
                	CHECKBACK(sec_RM, rm, (1<<(ctxt->mstate.num-1)));
                	CHECKBACK(sec_RN, rn, (1<<(ctxt->mstate.num-1)));
                	CHECKBACK(sec_RO, ro, (1<<(ctxt->mstate.num-1)));
                
                #undef CHECKBACK
                
                  // if the 'next' thing is set, try to match an immediate
                  if (inst->parts.next)
                	{
                	  // set immediate value in context
                	  ctxt->mstate.imm = blk->psb->base[srcptr+1];
                	  if (!follow(&itree, IMM)) return 0;
                	}
                
                  // now they've all matched successfully...
                	r = hash_lookup(itree, CODEGEN);
                  #ifdef DEBUG4
                  fprintf(stderr, "%s rule at %x\n", r ? "Setting" : "Not setting", srcptr);
                  #endif
                
                	if (rulefn && !*rulefn) *rulefn = r ? r->data : 0;
                  if (writeback) *writeback = itree;
                  return 1;
                }
                
                // recompile a set of basic blocks
                void codegen_recompile(machineinfo* machine, blockinfo* blk)
          62 -> {
                  allocationinfo* alloc = cnew(allocationinfo);
                	uint5 i;
                  pqueue* pq = pqueue_new();
                  pqueueitem* pqi;
                  psblock* psb = blk->psb;
                  basicblockinfo* bb = hash_lookup(psb->basic, 0)->data;
                
                	// All ARM registers in memory
                	for (i=0; i<16; i++) alloc->vloc[i].all = var_MEM;
                	// ...except temporaries
                	for (i=16; i<32; i++) alloc->vloc[i].all = 0;
                	// All x86 registers contain nothing
                	for (i=0; i<NUMIREG; i++) alloc->rctn[i].all = 0;
                
                  alloc->spill = 0;
                	
                  blk->native = x86asm_newnative();
                  codegen_matchblock(machine, blk);
                  
                  // push start block into priority queue
                  pqi = pqueue_insert(&pq, 0);
                  pqi->item = bb;
                  // allocated here
                  bb->startalloc = *alloc;
                  psb->info[0].special.flag.allocated = psb->info[0].special.flag.complete = 1;
                
                  while (bb)
                  {
                    list* w;
                    uint5 line;
                    if (!pq->length) break;
                    pqi = pqueue_extract(pq);  // get lowest-addressed thingy
                    line = pqi->priority;
                    bb = pqi->item;
                    #ifdef DEBUG4
                    fprintf(stderr, "Generating from %x to %x\n", line, line+bb->length);
                    #endif
                    // if 'falling into' a new basic block which has already got an allocation,
                    // massage current state into the new one.
                    if (psb->info[line].special.flag.allocated)
                    {
                      #ifdef DEBUG
                //      allocate_checkalloc(alloc);
                      #endif
                      allocate_coerce(alloc, &bb->startalloc, blk->native);
                      #ifdef DEBUG
                      fprintf(stderr, "Resetting alloc at line %x\n", line);
                      #endif
                      *alloc = bb->startalloc;
                      #ifdef DEBUG
                //      allocate_checkalloc(alloc);
                      #endif
                    }
                
                //  allocate_checkalloc(alloc);
                
                    // Spill all flags to memory (if they're in registers)
                    allocate_preflags(alloc, ALLFLAGS, 0, blk->native);
                
                    // not pretty?
                    for (i=reg_CPSRC; i<=reg_CPSRN; i++)
                      alloc->vloc[i].all = var_MEM;
                
                    codegen_inner(machine, blk, line, bb, alloc);
                //    psb->info[line].special.flag.complete = 1;
                    pqueue_deleteitem(pqi);
                
                //    allocate_checkalloc(alloc);
                
                    // add on all destinations
                    for (w=bb->destblks; w; w=w->prev)
                    {
                      uint5 line = (uint5)w->data;
                      if (!psb->info[line].special.flag.complete)
                      {
                        bb = hash_lookup(psb->basic, line)->data;
                        bb->startalloc = *alloc;
                        // copy this allocation state to each destination
                        psb->info[line].special.flag.allocated = 1;
                        pqi = pqueue_insert(&pq, line);
                        psb->info[line].special.flag.complete = 1;
                        #ifdef DEBUG
                        fprintf(stderr, "Inserting line %d\n", line);
                        #endif
                        pqi->item = bb;
                      }
                    }
                  }
                  pqueue_delete(pq);
                  free(alloc);
                }
                
                void codegen_matchblock(machineinfo* machine, blockinfo* blk)
          62 -> {
                  uint5 i;
                	gencontext ctxt;
                
                	for (i=0; i<blk->psb->length; i++)
                	{
                	  pseudoformat inst;
                		inst.value = blk->psb->base[i];
                    ctxt.mstate.num = ctxt.mstate.overwrite = ctxt.mstate.hidden = 0;
                    #ifdef DEBUG4
                		fprintf(stderr, "Rulifying %x\n", i);
                    #endif
                	  if (!codegen_rulify(machine->translaterules, machine->translaterules, blk, 
                                        &ctxt, i))
                		{
                		  fprintf(stderr, "Failed to match anything at %x!\n", i);
                			exit(1);
                		}
                		if (inst.parts.next) i++;
                	}
                }
                
                void codegen_inner(machineinfo* machine, blockinfo* blk, uint5 start,
                                   basicblockinfo* basic, allocationinfo* alloc)
         407 -> {
                  uint5 i;
                	psblock* psb = blk->psb;
                	hashentry* bas; /* = hash_lookup(psb->basic, start);
                	
                	assert(bas);
                	basic = bas->data;*/
                	
                	for (i=start; i<start+basic->length; i++)
                	{
                    basicblockinfo* lastbasic = basic;
                	  pseudoformat inst;
                		inst.value = psb->base[i];
                
                    codegen_addmapping(psb->basic, i, blk->native->base,
                                       blk->native->length);
                		
                		if (blk->psb->info[i].rule)
                	  {
                		  uint5 j;
                			uint5 lock = ALWAYSLOCK;
                			matchstate* mstate = &blk->psb->info[i].mstate;
                      uint5 flags = 0;
                
                      #ifdef DEBUG
                			fprintf(stderr, "Setting up for instruction at %x\n", i);
                      #endif
                /*
                      allocate_registerpattern(alloc, mstate, &lock, blk->native);
                
                      // muhahaha
                      if (inst.parts.rm>=reg_CPSRC && inst.parts.rm<=reg_CPSRN)
                        flags |= (1<<(inst.parts.rm-reg_CPSRC));
                      if (inst.parts.rn>=reg_CPSRC && inst.parts.rn<=reg_CPSRN)
                        flags |= (1<<(inst.parts.rn-reg_CPSRC));
                      if (inst.parts.ro>=reg_CPSRC && inst.parts.ro<=reg_CPSRN)
                        flags |= (1<<(inst.parts.ro-reg_CPSRC));
                
                      allocate_ensureflags(alloc, mstate, flags, lock, blk->native);
                */
                      #ifdef DEBUG5
                      fprintf(stderr, "alloc->vloc[15].all=%x\n", alloc->vloc[15].all);
                      #endif
                
                      allocate_setup(alloc, mstate, inst.value, blk->native, &lock);
                
                			// generate code for this pattern
                		  blk->psb->info[i].rule(machine, blk->native, blk->psb->basic,
                        blk->psb->info, alloc, mstate, lock, inst.parts.flags);
                
                 //     x86asm_out(blk->native, NOP, 0);
                
                      allocate_npostfix(alloc, mstate);
                //      allocate_checkalloc(alloc);
                		}
                
                		if (inst.parts.next) i++;
                	}
                }
                
                // following two functions similar in spirit & implementation to the pseudo_ 
                // ones which do exactly the same thing
                
                // return the offset of an Intel instruction corresponding to pseudocode offset
                sint5 codegen_getinteladdr(hashtable* basicmap, uint5 psinst, uint5 patch)
         174 -> {
                  hashentry* h = hash_lookup(basicmap, psinst);
                  basicblockinfo* bl = h ? (basicblockinfo*) h->data : 0;
                  
                  assert(h);
                
                  if (bl->offset != -1)
                    return bl->offset - (patch+4);
                  
                  #ifdef DEBUG4
                  fprintf(stderr, "Adding x86 patch request at %x, waiting for %x\n", patch,
                          psinst);
                  #endif
                  list_add(&bl->patchback);
                  bl->patchback->data = (void*)patch;
                  
                  return -(patch+4);
                }
                
                void codegen_addmapping(hashtable* basicmap, uint5 psinst, uint3* base,
                                        sint5 ioffset)
        2264 -> {
                  hashentry* h = hash_lookup(basicmap, psinst);
                  basicblockinfo* bl = h ? (basicblockinfo*) h->data : 0;
                   
                  if (!h) return;
                  
                  #ifdef DEBUG
                  fprintf(stderr, "Setting mapping pseudo:%x to intel:%x\n", psinst, ioffset);
                  #endif
                  
                  bl->offset = ioffset;
                
                  #ifdef DEBUG
                  if (bl->patchback) fprintf(stderr, "Patching back x86\n");
                  #endif
                  
                  while (bl->patchback)
                  {
                    uint5* addr = (uint5*)((uint5)base + (uint5)bl->patchback->data);
                    #ifdef DEBUG
                    fprintf(stderr, "Poking %x\n", ioffset);
                    #endif
                    (*addr) += ioffset;
                    list_removehead(&bl->patchback);
                  }
                }


Top 10 Lines:

     Line      Count

       78       9552
       54       4219
      105       2432
      135       2264
      422       2264
      336        407
      401        174
       31        146
      218         62
      312         62

Execution Summary:

       11   Executable lines in this file
       11   Lines executed
   100.00   Percent of the file executed

    21582   Total number of line executions
  1962.00   Average executions per line


*** File /home/jules/ARMemu/armemu/analyse.c:
                #include <assert.h>
                #include <stdio.h>
                
                #include "cnew.h"
                #include "machine.h"
                #include "block.h"
                #include "pseudo.h"
                #include "analyse.h"
                
                static void addedge(hashtable* hash, endpoint start, endpoint end)
        6691 -> {
                  hashentry* d;
                  if (start.parts.address!=-1 && end.parts.address!=-1)
                	{
                	  d = hash_insert(hash, start.value);
                		d->data = (void*) end.value;
                	}
                }
                
                basicblockinfo* analyse_newbasicblock(uint5 length)
         407 -> {
                  basicblockinfo* basic = cnew(basicblockinfo);
                	
                	basic->length = length;
                	basic->destblks = 0;
                	basic->offset = -1;
                	basic->patchback = 0;
                	
                	return basic;
                }
                
                void analyse_block(blockinfo* blk)
          62 -> {
                  psblock* psb = blk->psb;
                	imapinfo* info;
                	hashtable* lastset, *nextused;
                	endpoint usetab[32];
                	sint5 i, j;
                	uint5 blockcount = 1, blockend;
                	hashtable* basic;
                	hashentry* basicentry;
                	hashentry* thisblock = 0, *lastblock = 0;
                		
                	info = (imapinfo*)blk->psb->info = cnewarray(imapinfo, psb->length);
                	lastset = blk->lastset = hash_new(psb->length);
                	nextused = blk->nextused = hash_new(psb->length);
                
                	// initialise data
                	for (i=0; i<psb->length; i++)
                	{
                	  info[i].special.value = 0;
                		info[i].rule = 0;
                	}
                
                	// partition this code block into basic blocks
                
                  // start of this chunk is always a leader
                	info[0].special.flag.leader = 1;
                
                	for (i=0; i<32; usetab[i++].value=-1);
                
                	// find leaders, make block traversable backwards, find last-set info
                	for (i=0; i<psb->length; i++)
                	{
                	  pseudoformat inst;
                		endpoint s;
                		inst.value = psb->base[i];
                
                    if (info[i].special.flag.leader)
                		{
                		  uint5 j;
                			for (j=0; j<32; usetab[j++].value=-1);
                		}
                		
                		if (inst.parts.rm != reg_UNUSED)
                		{
                		  s.parts.address = i;
                			s.parts.section = sec_RM;
                
                			addedge(lastset, s, usetab[inst.parts.rm]);
                		}
                		
                		if (inst.parts.rn != reg_UNUSED)
                		{
                		  s.parts.address = i;
                			s.parts.section = sec_RN;
                			
                			addedge(lastset, s, usetab[inst.parts.rn]);
                		}
                		
                		if (inst.parts.ro != reg_UNUSED)
                		{
                		  s.parts.address = i;
                			s.parts.section = sec_RO;
                			
                			addedge(lastset, s, usetab[inst.parts.ro]);
                		}
                
                    if (inst.parts.rd != reg_UNUSED)
                		{
                		  usetab[inst.parts.rd].parts.address = i;
                			usetab[inst.parts.rd].parts.section = sec_RD;
                		}
                		
                    if (inst.parts.opcode>=op_BEQ && inst.parts.opcode<=op_BAL)
                		{
                		  // destination of a branch is a leader
                			if (!info[psb->base[i+1]].special.flag.leader) blockcount++;
                		  info[psb->base[i+1]].special.flag.leader = 1;
                			if (inst.parts.opcode != op_BAL)
                			{
                			  // if jump is conditional, instruction following branch is a leader too
                				if (!info[i+2].special.flag.leader) blockcount++;
                				info[i+2].special.flag.leader = 1;
                //				info[i+2].special.flag.follows = 1;
                			}
                		}
                
                		if (inst.parts.next)
                		{
                		  if (i+2 < psb->length) info[i+2].special.flag.prev = 1;
                			i++;
                		}
                	}
                
                	basic = psb->basic = hash_new(blockcount);  // more arbitrariness
                	blockend = psb->length;
                
                	for (i=0; i<32; usetab[i++].value=-1);
                
                	// calculate next-use information
                	for (i=psb->length-1; i>=0; i--)
                	{
                	  pseudoformat inst;
                		endpoint e;
                		hashentry* d;
                		inst.value = psb->base[i];
                
                		if (inst.parts.rd != reg_UNUSED)
                		{
                		  e.parts.address = i;
                			e.parts.section = sec_RD;
                
                      addedge(nextused, e, usetab[inst.parts.rd]);
                			
                		  usetab[inst.parts.rd].value = -1;
                		}
                
                		if (inst.parts.rm != reg_UNUSED)
                		{
                			e.parts.address = i;
                			e.parts.section = sec_RM;
                			
                			addedge(nextused, e, usetab[inst.parts.rm]);
                			
                		  usetab[inst.parts.rm] = e;
                		}
                		
                		if (inst.parts.rn != reg_UNUSED)
                		{
                		  e.parts.address = i;
                			e.parts.section = sec_RN;
                
                      addedge(nextused, e, usetab[inst.parts.rn]);
                			
                			usetab[inst.parts.rn] = e;
                		}
                
                		if (inst.parts.ro != reg_UNUSED)
                		{
                		  e.parts.address = i;
                			e.parts.section = sec_RO;
                
                      addedge(nextused, e, usetab[inst.parts.ro]);
                			
                			usetab[inst.parts.ro] = e;
                		}
                		
                    // beginning of a new block: clear last-use array
                		if (info[i].special.flag.leader)
                		{
                		  uint5 j;
                		  for (j=0; j<32; usetab[j++].value=-1);
                			basicentry = hash_insert(basic, i);
                			basicentry->data = analyse_newbasicblock(blockend-i);
                			blockend = i;
                		}
                
                		if (info[i].special.flag.prev) i--;
                	}
                	
                  thisblock = 0;
                  
                	// trace flow-of-control between basic blocks
                	for (i=0; i<psb->length; i++)
                	{
                	  pseudoformat inst;
                	  list* newdest;
                		uint5 j;
                
                		inst.value = psb->base[i];
                		
                    #ifdef DEBUG3
                		for (j=0; j<7; j++)
                		{
                		  endpoint s;
                			hashentry* entry;
                			const static char* secname[] = {"rd", "rm", "rn", "ro", "cflag", "vflag",
                			                                "nflag", "zflag"};
                			s.parts.address = i;
                			s.parts.section = j;
                			if (entry = hash_lookup(blk->nextused, s.value))
                			{
                			  endpoint e;
                				e.value = (uint5) entry->data;
                			  fprintf(stderr, "Thing %s:%x next used at %s:%x\n", 
                				        secname[s.parts.section], s.parts.address,
                								secname[e.parts.section], e.parts.address);
                			}
                			if (entry = hash_lookup(blk->lastset, s.value))
                			{
                			  endpoint e;
                				e.value = (uint5) entry->data;
                				fprintf(stderr, "Thing %s:%x last set at %s:%x\n",
                				        secname[s.parts.section], s.parts.address,
                								secname[e.parts.section], e.parts.address);
                			}
                		}
                    #endif
                
                //		fprintf(stderr, "Seeking leader at %d\n", i);
                		
                	  if (info[i].special.flag.leader)
                    {
                      lastblock = thisblock;
                      thisblock = hash_lookup(basic, i);
                      if (lastblock)
                      {
                        newdest = list_add(&((basicblockinfo*)lastblock->data)->destblks);
                        newdest->data = (void*)i;
                      }
                    }
                 
                		if (inst.parts.opcode>=op_BEQ && inst.parts.opcode<=op_BAL)
                		{
                      uint5 dest = psb->base[i+1];
                
                      // add to list of follow-on blocks for this block
                      newdest = list_add(&((basicblockinfo*)thisblock->data)->destblks);
                			newdest->data = (void*)dest;
                    }
                
                		if (inst.parts.next) i++;
                	}
                }


Top 10 Lines:

     Line      Count

       11       6691
       21        407
       33         62

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

     7160   Total number of line executions
  2386.67   Average executions per line


*** File /home/jules/ARMemu/armemu/pseudo.c:
                #include <stdarg.h>
                #include <stdio.h>
                
                #include "defs.h"
                #include "machine.h"
                #include "pseudo.h"
                #include "cnew.h"
                #include "execute.h"
                #include "hash.h"
                #include "block.h"
                
                psblock* pseudo_newblock(uint5 startsize)
          62 -> {
                  psblock* psb = cnew(psblock);
                
                	psb->base = cnewarray(uint5, 1024);
                  psb->info = 0;
                	psb->length = 0;
                	psb->size = 1024;
                	psb->pseudomap = hash_new(9);  // completely arbitrary now...
                	psb->basic = 0;
                
                	return psb;
                }
                
                // and now for the memory leaks...
                void pseudo_deleteblock(psblock* psb)
          62 -> {
                  free(psb->base);
                  free(psb->info);
                	hash_nuke(psb->pseudomap, pseudo_psminfodestructor);
                  hash_nuke(psb->basic, 0);
                  free(psb);
                }
                
                psmapinfo* pseudo_newpsminfo(uint5 pseudo)
         690 -> {
                  psmapinfo* psm = cnew(psmapinfo);
                	
                	psm->pseudo = pseudo;
                	psm->patchback = 0;
                //	psm->intel = 0;
                	
                	return psm;
                }
                
                void pseudo_psminfodestructor(void* data)
         690 -> {
                  psmapinfo* psm = (psmapinfo*)data;
                  while (psm->patchback) list_removehead(&psm->patchback);
                  free(psm);
                }
                
                void pseudo_deletepsminfo(psmapinfo* psm)
       ##### -> {
                  while (psm->patchback) list_removehead(&psm->patchback);
                  free(psm);
                }
                
                static void extend(psblock* blk)
        3114 -> {
                	if (++blk->length == blk->size)
                	{
                	  blk->size *= 2;
                	  blk->base = realloc(blk->base, sizeof(uint5)*blk->size);
                    fprintf(stderr, "--Extending block, base now %x--\n", blk->base);
                		if (!blk->base)
                		{
                		  fprintf(stderr, "Block extend failed?\n");
                			exit(1);
                		}
                	}
                }
                
                void pseudo_emit(psblock* blk, pseudoopcode op, ...)
        2264 -> {
                  va_list ap;
                	pseudoformat* psf;
                	int someflags = (op & PSSETFLAGS) ? 1 : 0;
                  int noflags = (op & NOFLAGS) ? 1 : 0;
                
                	extend(blk);
                	psf = (pseudoformat*) &blk->base[blk->length-1];
                		
                	op &= 0x7f;
                
                	psf->parts.opcode = op;
                
                	va_start(ap, op);
                	
                	if (someflags)
                	  psf->parts.flags = va_arg(ap, uint5);
                	else
                	  psf->parts.flags = 0;
                	
                	switch (op)
                	{
                /*	  case op_Z:     // unops
                		case op_N:
                		case op_RRXC:*/
                		case op_MOV:
                		case op_MVN:
                		psf->parts.rd = va_arg(ap, uint5);
                		psf->parts.rm = va_arg(ap, uint5);
                		psf->parts.rn = reg_UNUSED;
                		psf->parts.ro = reg_UNUSED;
                		psf->parts.next = 0;
                		break;
                
                		case op_RRX:
                		psf->parts.rd = va_arg(ap, uint5);
                		psf->parts.rm = va_arg(ap, uint5);
                		psf->parts.rn = reg_CPSRC;
                		psf->parts.ro = reg_UNUSED;
                		psf->parts.next = 0;
                    break;
                
                		case op_LDW:
                		case op_LDB:
                		psf->parts.rd = va_arg(ap, uint5);
                		psf->parts.rm = va_arg(ap, uint5);
                		psf->parts.rn = reg_UNUSED;
                		psf->parts.ro = reg_UNUSED;
                		psf->parts.next = 0;
                		break;
                
                		case op_STW:
                		case op_STB:
                    psf->parts.rd = reg_UNUSED;
                		psf->parts.rm = va_arg(ap, uint5);
                		psf->parts.rn = va_arg(ap, uint5);
                		psf->parts.ro = reg_UNUSED;
                		psf->parts.next = 0;
                		break;
                		
                		case op_BEQ:  // Z set
                		case op_BNE:  // Z clear
                		psf->parts.rd = reg_UNUSED;
                		psf->parts.rm = noflags ? reg_UNUSED : reg_CPSRZ;
                		psf->parts.rn = reg_UNUSED;
                		psf->parts.ro = reg_UNUSED;
                		psf->parts.next = 1;
                		extend(blk);
                		blk->base[blk->length-1] = va_arg(ap, uint5);
                		break;
                		
                		case op_BCS:  // C set
                		case op_BCC:  // C clear
                		psf->parts.rd = reg_UNUSED;
                		psf->parts.rm = noflags ? reg_UNUSED : reg_CPSRC;
                		psf->parts.rn = reg_UNUSED;
                		psf->parts.ro = reg_UNUSED;
                		psf->parts.next = 1;
                		extend(blk);
                		blk->base[blk->length-1] = va_arg(ap, uint5);
                		break;
                
                		case op_BMI:  // N set
                		case op_BPL:  // N clear
                		psf->parts.rd = reg_UNUSED;
                		psf->parts.rm = noflags ? reg_UNUSED : reg_CPSRN;
                		psf->parts.rn = reg_UNUSED;
                		psf->parts.ro = reg_UNUSED;
                		psf->parts.next = 1;
                		extend(blk);
                		blk->base[blk->length-1] = va_arg(ap, uint5);
                		break;
                		
                		case op_BVS:  // V set
                		case op_BVC:  // V clear
                		psf->parts.rd = reg_UNUSED;
                		psf->parts.rm = noflags ? reg_UNUSED : reg_CPSRV;
                		psf->parts.rn = reg_UNUSED;
                		psf->parts.ro = reg_UNUSED;
                		psf->parts.next = 1;
                		extend(blk);
                		blk->base[blk->length-1] = va_arg(ap, uint5);
                		break;
                
                		case op_BHI:  // C set and Z clear
                		case op_BLS:  // C clear or Z set
                		psf->parts.rd = reg_UNUSED;
                		psf->parts.rm = noflags ? reg_UNUSED : reg_CPSRC;
                		psf->parts.rn = noflags ? reg_UNUSED : reg_CPSRZ;
                		psf->parts.ro = reg_UNUSED;
                		psf->parts.next = 1;
                		extend(blk);
                		blk->base[blk->length-1] = va_arg(ap, uint5);
                		break;
                				
                		case op_BGE:  // N set and V set, or N clear and V clear
                		case op_BLT:  // N set and V clear, or N clear and V set
                		psf->parts.rd = reg_UNUSED;
                		psf->parts.rm = noflags ? reg_UNUSED : reg_CPSRN;
                		psf->parts.rn = noflags ? reg_UNUSED : reg_CPSRV;
                		psf->parts.ro = reg_UNUSED;
                		psf->parts.next = 1;
                		extend(blk);
                		blk->base[blk->length-1] = va_arg(ap, uint5);
                		break;
                		
                		case op_BGT:  // Z clear, and either N set and V set, or N clear and V clear
                		case op_BLE:  // Z set, or N set and V clear, or N clear and V set
                		psf->parts.rd = reg_UNUSED;
                		psf->parts.rm = noflags ? reg_UNUSED : reg_CPSRN;
                		psf->parts.rn = noflags ? reg_UNUSED : reg_CPSRV;
                		psf->parts.ro = noflags ? reg_UNUSED : reg_CPSRZ;
                		psf->parts.next = 1;
                		extend(blk);
                		blk->base[blk->length-1] = va_arg(ap, uint5);
                		break;
                
                		case op_BAL:
                		psf->parts.rd = reg_UNUSED;
                		psf->parts.rm = reg_UNUSED;
                		psf->parts.rn = reg_UNUSED;
                		psf->parts.ro = reg_UNUSED;
                		psf->parts.next = 1;
                		extend(blk);
                		blk->base[blk->length-1] = va_arg(ap, uint5);
                		break;
                
                		case op_CONST:
                		case op_SWI:    // immediate follows
                		psf->parts.rd = (op==op_CONST) ? va_arg(ap, uint5) : reg_UNUSED;
                		psf->parts.rm = reg_UNUSED;
                		psf->parts.rn = reg_UNUSED;
                		psf->parts.ro = reg_UNUSED;
                		psf->parts.next = 1;
                		extend(blk);
                		blk->base[blk->length-1] = va_arg(ap, uint5);
                		break;
                
                		case op_ADC:
                		case op_SBC:
                		psf->parts.rd = va_arg(ap, uint5);
                		psf->parts.rm = va_arg(ap, uint5);
                		psf->parts.rn = va_arg(ap, uint5);
                		psf->parts.ro = va_arg(ap, uint5);
                		psf->parts.next = 0;
                		break;
                		
                		case op_CMP:
                    case op_CMN:
                    case op_TEQ:
                    case op_TST:
                		psf->parts.rd = reg_UNUSED;
                		psf->parts.rm = va_arg(ap, uint5);
                		psf->parts.rn = va_arg(ap, uint5);
                		psf->parts.ro = reg_UNUSED;
                		psf->parts.next = 0;
                		break;
                		
                		case op_SETPC:
                		psf->parts.rd = reg_R15;
                		psf->parts.rm = reg_UNUSED;
                		psf->parts.rn = reg_UNUSED;
                		psf->parts.ro = reg_UNUSED;
                		psf->parts.next = 0;
                    break;
                    
                    case op_RECONSTRUCTPC:
                    psf->parts.rd = reg_R15;
                    psf->parts.rm = reg_CPSRFLAGS;
                    psf->parts.rn = reg_CPSRMODE;
                    psf->parts.ro = reg_CPSRINTMASK;
                    psf->parts.next = 1;
                		extend(blk);
                		blk->base[blk->length-1] = va_arg(ap, uint5);
                    break;
                
                		case op_XJMP:
                		psf->parts.rd = reg_UNUSED;
                		psf->parts.rm = reg_UNUSED;
                		psf->parts.rn = reg_UNUSED;
                		psf->parts.ro = reg_UNUSED;
                		psf->parts.next = 1;
                		extend(blk);
                		blk->base[blk->length-1] = va_arg(ap, uint5);
                		break;
                    
                		case op_END:
                		psf->parts.rd = reg_UNUSED;
                		psf->parts.rm = reg_UNUSED;
                		psf->parts.rn = reg_UNUSED;
                		psf->parts.ro = reg_UNUSED;
                		psf->parts.next = 0;
                		break;
                
                		default:  // binop (all the rest)
                		psf->parts.rd = va_arg(ap, uint5);
                		psf->parts.rm = va_arg(ap, uint5);
                		psf->parts.rn = va_arg(ap, uint5);
                		psf->parts.ro = reg_UNUSED;
                		psf->parts.next = 0;
                		break;
                	}
                	va_end(ap);
                }
                
                // generates intermediate code from a block of ARM code
                void pseudo_translateblock(machineinfo* machine, blockinfo* block, uint5 pc)
          62 -> {
                  registerinfo* reg = machine->reg;
                  uint5 i, oldr15 = RGET(15);
                
                  #ifdef DEBUG
                	fprintf(stderr, "Translating code at %x, length %d\n", pc, block->length);
                  #endif
                
                	if (block->psb) pseudo_deleteblock(block->psb);
                
                  block->psb = pseudo_newblock(block->length);  // may not be optimal size
                
                	for (i=0; i<block->length; i++)
                	{
                	  instructionformat inst;
                		uint5* instaddr = (uint5*)(pc+i*sizeof(uint5));
                		uint5* flataddr = memory_lookup(machine->mem, instaddr);
                		RPUT(15, pc+i*sizeof(uint5)+8);
                		inst.instruction = *flataddr;
                    #ifdef DEBUG
                		fprintf(stderr, "Translating %x: ", instaddr);
                		dispatch(machine, inst, &diss, 0);
                    fprintf(stderr, "\n");
                    #endif
                		pseudo_addmapping(block->psb->pseudomap, instaddr,
                		                  block->psb->base, block->psb->length);
                	  dispatch(machine, inst, &pseudo, (void*)block->psb);
                	}
                	
                	pseudo_addmapping(block->psb->pseudomap, (uint5*)(pc+i*sizeof(uint5)),
                	                  block->psb->base, block->psb->length);
                  // this is a far better place for this
                  pseudo_emit(block->psb, op_CONST, reg_R15, pc+block->length*sizeof(uint5)+8);
                	pseudo_emit(block->psb, op_END);
                
                	RPUT(15, oldr15);
                }
                
                // return the address of a pseudocode instruction corresponding to the ARM
                // instruction at 'arminst', or add pseudocode address to patchback list
                uint5 pseudo_getpsaddr(hashtable* pseudomap, uint5* arminst, sint5 patch)
         174 -> {
                  hashentry* h = hash_lookup(pseudomap, (uint5) arminst);
                	psmapinfo* ps = h ? (psmapinfo*) h->data : 0;
                
                	if (ps && ps->pseudo!=-1) return ps->pseudo;
                
                  if (ps) fprintf(stderr, "ps present, but unset?\n");
                
                //  fprintf(stderr, "Erm: %x\n", patch);
                
                  // no hashtable entry for this ARM instruction (ie, forward reference)
                	if (!h)
                	{
                		h = hash_insert(pseudomap, (uint5) arminst);
                		ps = h->data = pseudo_newpsminfo(-1);
                	}
                
                  patch++;
                  #ifdef DEBUG
                  fprintf(stderr, "Adding patch request at %x for inst %x\n", patch, arminst);
                  #endif
                	list_add(&ps->patchback);
                	ps->patchback->data = (void*)patch;
                	
                //  fprintf(stderr, "Returning -1 at %x\n", patch);
                  
                	return -1;
                }
                
                void pseudo_addmapping(hashtable* pseudomap, uint5* arminst, uint5* base,
                                       sint5 pseudo)
         690 -> {
                  hashentry* h = hash_lookup(pseudomap, (uint5) arminst);
                	psmapinfo* ps = h ? (psmapinfo*) h->data : 0;
                 	
                //	fprintf(stderr, "Adding mapping %x == %x\n", arminst, pseudo);
                	
                	if (!h)
                	{
                	  h = hash_insert(pseudomap, (uint5) arminst);
                		ps = h->data = pseudo_newpsminfo(pseudo);
                	}
                  
                  if (ps && ps->pseudo==-1) ps->pseudo = pseudo;
                	
                  #ifdef DEBUG
                	if (ps->patchback) fprintf(stderr, "Patching addresses back\n");
                  #endif
                	
                	while (ps->patchback)
                	{
                	  uint5 addr = (uint5) ps->patchback->data;
                		base[addr] = pseudo;
                //    fprintf(stderr, "Writing %x into address %x\n", pseudo, &base[addr]);
                		list_removehead(&ps->patchback);
                	}
                }
                
                // return the next temporary register slot (dumb)
                sint5 pseudo_newtemp(sint5* prevtemp)
         747 -> {
                  if (*prevtemp==-1) *prevtemp = reg_T0; else (*prevtemp)++;
                	if (*prevtemp>reg_T3)
                	{
                	  fprintf(stderr, "Out of static temporaries!\n");
                		exit(1);
                	}
                	return *prevtemp;
                }
                
                void pseudo_condition(machineinfo* machine, uint5 cond, psblock* psb)
         642 -> {
                	registerinfo* reg = machine->reg;
                	if (cond != cc_AL)
                	{
                  	// (condition ^ 1) is the opposite condition to (condition)
                		pseudo_jmp(machine, cond ^ 1, (uint5*)(GET(15)-4), psb);
                /*		pseudo_emit(blk, op_BEQ + (cond ^ 1),
                	  	pseudo_getpsaddr(psb->pseudomap, (uint5*)(GET(15)-4),
                			psb->length));*/
                	}
                }
                
                void pseudo_reconstitutepc(machineinfo* machine, uint5 sflag,
                                           psblock* psb, sint5* tc, sint5 offset)
          62 -> {
                  registerinfo* reg = machine->reg;
                  if (sflag)
                    pseudo_emit(psb, op_RECONSTRUCTPC, GET(15)+offset);
                  else
                    pseudo_emit(psb, op_CONST, reg_R15, GET(15)+offset);
                }
                
                // generate different types of jump depending on locality of destination
                void pseudo_jmp(machineinfo* machine, uint5 cond, uint5* dest, psblock* psb)
         261 -> {
                  blockinfo* arm = machine->live->data;
                	uint5* base = (uint5*) machine->live->key;
                
                  if (cond == cc_NV) return;
                
                  #ifdef DEBUG
                  fprintf(stderr, "base=%x end=%x dest=%x\n", base, &base[arm->length], dest);
                  #endif
                
                  if (dest>=base && dest<=&base[arm->length])
                	{
                		// within this block
                		pseudo_emit(psb, op_BEQ + cond, pseudo_getpsaddr(psb->pseudomap, dest,
                			        	psb->length));
                  }
                	else
                	{
                	  hashentry* h = hash_lookup(machine->blocks, (uint5)dest);
                    blockinfo* toblk = h ? h->data : 0;
                		
                		pseudo_condition(machine, cond, psb);
                
                		if (toblk && toblk->native)  // jump to the start of another basic block
                		{
                			pseudo_emit(psb, op_XJMP, toblk);
                		}
                		else
                		{
                		  // don't know any basic block at that address, fall back to emulator
                			pseudo_emit(psb, op_CONST, reg_R15, dest);
                			pseudo_emit(psb, op_SETPC);
                		}
                	}
                }
                
                void pseudo_dp(machineinfo* machine, instructionformat inst, void* blk)
         218 -> {
                  uint5 temp = inst.dp.operand2;
                	uint5 shifttype = (temp>>5)&3, amount;
                  uint3 regshift = (temp & 16) ? 1 : 0;
                  // mask for logic rather than arithmetic instructions
                	const uint5 logic = 0xf303;
                  const uint5 affectrd = 0xf0ff;
                	int islogic = logic & (1<<inst.dp.opcode);
                	sint5 tc = -1;
                	sint5 shiftbyreg = -1;
                	uint5 op2reg, rm = temp&15;
                  uint5 t, s;
                
                	pseudo_condition(machine, inst.generic.cond, blk);
                
                  if (inst.dp.rn==reg_R15 || rm==reg_R15)
                    pseudo_reconstitutepc(machine, inst.dp.s, blk, &tc, regshift ? 4 : 0);
                
                  if (regshift)  // shift by register
                	{
                	  shiftbyreg = temp>>8;
                    
                    if (shifttype!=3)
                    {
                      t = pseudo_newtemp(&tc);
                      pseudo_emit(blk, op_CONST, t, 0xff);
                      pseudo_emit(blk, op_AND, t, shiftbyreg, t);
                    }
                    
                    switch (shifttype)
                    {
                      case 0:  // lsl / no shift
                      {
                        s = pseudo_newtemp(&tc);
                        pseudo_emit(blk, op_CONST, s, 31);
                //        pseudo_emit(blk, op_CMP | PSSETFLAGS, ALLFLAGS, t, s);
                        pseudo_emit(blk, op_CMP, t, s);
                        pseudo_emit(blk, op_BGT|NOFLAGS, ((psblock*)blk)->length+5);
                			  op2reg = s;
                				if (islogic && inst.dp.s)
                				  pseudo_emit(blk, op_LSL | PSSETFLAGS, CFLAG, op2reg, rm, t);
                				else
                          pseudo_emit(blk, op_LSL, op2reg, rm, t);
                        pseudo_emit(blk, op_BAL|NOFLAGS, ((psblock*)blk)->length+4);
                        pseudo_emit(blk, op_CONST, op2reg, 0);
                      }
                      break;
                      
                      case 1:  // logical right
                      {
                        s = pseudo_newtemp(&tc);
                        pseudo_emit(blk, op_CONST, s, 31);
                //        pseudo_emit(blk, op_CMP | PSSETFLAGS, ALLFLAGS, t, s);
                        pseudo_emit(blk, op_CMP, t, s);
                        pseudo_emit(blk, op_BGT|NOFLAGS, ((psblock*)blk)->length+5);
                			  op2reg = s;
                				if (islogic && inst.dp.s)
                				  pseudo_emit(blk, op_LSR | PSSETFLAGS, CFLAG, op2reg, rm, t);
                				else
                          pseudo_emit(blk, op_LSR, op2reg, rm, t);
                        pseudo_emit(blk, op_BAL|NOFLAGS, ((psblock*)blk)->length+4);
                        pseudo_emit(blk, op_CONST, op2reg, 0);
                      }
                      break;
                      
                      case 2:  // arithmetic right
                      {
                        s = pseudo_newtemp(&tc);
                        pseudo_emit(blk, op_CONST, s, 31);
                //        pseudo_emit(blk, op_CMP | PSSETFLAGS, ALLFLAGS, t, s);
                        pseudo_emit(blk, op_CMP, t, s);
                        pseudo_emit(blk, op_BGT|NOFLAGS, ((psblock*)blk)->length+5);
                			  op2reg = s;
                				if (islogic && inst.dp.s)
                				  pseudo_emit(blk, op_ASR | PSSETFLAGS, CFLAG, op2reg, rm, t);
                				else
                          pseudo_emit(blk, op_ASR, op2reg, rm, t);
                        pseudo_emit(blk, op_BAL|NOFLAGS, ((psblock*)blk)->length+13);
                        pseudo_emit(blk, op_CONST, t, TOPBIT);
                        pseudo_emit(blk, op_TST | PSSETFLAGS, NFLAG|ZFLAG, rm, t);
                        pseudo_emit(blk, op_BEQ|NOFLAGS, ((psblock*)blk)->length+6);
                        pseudo_emit(blk, op_CONST, op2reg, 0xffffffff);
                        pseudo_emit(blk, op_BAL|NOFLAGS, ((psblock*)blk)->length+4);
                        pseudo_emit(blk, op_CONST, op2reg, 0);
                      }
                      break;
                      
                      case 3:  // rotate right
                      {
                		  	op2reg = pseudo_newtemp(&tc);
                				if (islogic && inst.dp.s)
                				  pseudo_emit(blk, op_ROR | PSSETFLAGS, reg_CPSRC, op2reg, rm,
                                      shiftbyreg);
                				else
                  				pseudo_emit(blk, op_ROR, op2reg, rm, shiftbyreg);
                      }
                      break;
                    }
                	}
                	else  // shift by immediate
                	{
                	  amount = temp>>7;
                		if (shifttype!=0 || amount!=0)
                		{
                      if (!(shifttype==3 && amount==0))
                      {
                  		  shiftbyreg = pseudo_newtemp(&tc);
                  			pseudo_emit(blk, op_CONST, shiftbyreg, amount);
                      }
                      op2reg = pseudo_newtemp(&tc);
                		}
                    else
                      op2reg = rm;
                
                    switch (shifttype)
                    {
                      case 0:  // logical left/no shift
                      {
                        if (amount)
                        {
                				  if (islogic && inst.dp.s)
                				    pseudo_emit(blk, op_LSL | PSSETFLAGS, CFLAG, op2reg, rm,
                              shiftbyreg);
                				  else
                            pseudo_emit(blk, op_LSL, op2reg, rm, shiftbyreg);
                        }
                      }
                      break;
                
                      case 1:  // logical right
                      {
                        if (amount)  // shift by 1..31
                        {
                				  if (islogic && inst.dp.s)
                				    pseudo_emit(blk, op_LSR | PSSETFLAGS, CFLAG, op2reg, rm, 
                              shiftbyreg);
                				  else
                            pseudo_emit(blk, op_LSR, op2reg, rm, shiftbyreg);
                        }
                        else  // shift by 32 (represented by 0)
                        {
                          if (islogic && inst.dp.s)
                          {
                            pseudo_emit(blk, op_CONST, op2reg, TOPBIT);
                //            pseudo_emit(blk, op_TST | PSSETFLAGS, NFLAG|ZFLAG, rm, op2reg);
                            pseudo_emit(blk, op_TST, rm, op2reg);
                            pseudo_emit(blk, op_BEQ|NOFLAGS, ((psblock*)blk)->length+6);
                            pseudo_emit(blk, op_CONST | PSSETFLAGS, CFLAG, reg_CPSRC, 1);
                            pseudo_emit(blk, op_BAL|NOFLAGS, ((psblock*)blk)->length+4);
                            pseudo_emit(blk, op_CONST | PSSETFLAGS, CFLAG, reg_CPSRC, 0);
                            pseudo_emit(blk, op_CONST, op2reg, 0);
                          }
                          else
                          {
                            pseudo_emit(blk, op_CONST, op2reg, 0);
                          }
                        }
                      }
                      break;
                
                      case 2:  // arithmetic right
                      {
                        if (amount)
                        {
                				  if (islogic && inst.dp.s)
                				    pseudo_emit(blk, op_ASR | PSSETFLAGS, CFLAG, op2reg, rm, 
                              shiftbyreg);
                				  else
                            pseudo_emit(blk, op_ASR, op2reg, rm, shiftbyreg);
                        }
                        else
                        {
                          if (islogic && inst.dp.s)
                          {
                            pseudo_emit(blk, op_CONST, op2reg, TOPBIT);
                //            pseudo_emit(blk, op_TST | PSSETFLAGS, NFLAG|ZFLAG, rm, op2reg);
                            pseudo_emit(blk, op_TST, rm, op2reg);
                            pseudo_emit(blk, op_BEQ|NOFLAGS, ((psblock*)blk)->length+8);
                            pseudo_emit(blk, op_CONST | PSSETFLAGS, CFLAG, reg_CPSRC, 1);
                            pseudo_emit(blk, op_CONST, op2reg, 0xffffffff);
                            pseudo_emit(blk, op_BAL|NOFLAGS, ((psblock*)blk)->length+6);
                            pseudo_emit(blk, op_CONST | PSSETFLAGS, CFLAG, reg_CPSRC, 0);
                            pseudo_emit(blk, op_CONST, op2reg, 0);
                          }
                          else
                          {
                            pseudo_emit(blk, op_CONST, op2reg, TOPBIT);
                //            pseudo_emit(blk, op_TST | PSSETFLAGS, NFLAG|ZFLAG, rm, op2reg);
                            pseudo_emit(blk, op_TST, rm, op2reg);
                            pseudo_emit(blk, op_BEQ|NOFLAGS, ((psblock*)blk)->length+6);
                            pseudo_emit(blk, op_CONST, op2reg, 0xffffffff);
                            pseudo_emit(blk, op_BAL|NOFLAGS, ((psblock*)blk)->length+4);
                            pseudo_emit(blk, op_CONST, op2reg, 0);
                          }
                        }
                      }
                      break;
                      
                      case 3:  // rotate right / rrx
                      {
                        if (amount)  // ror
                        {
                				  if (islogic && inst.dp.s)
                				    pseudo_emit(blk, op_ROR | PSSETFLAGS, reg_CPSRC, op2reg, rm,
                                        shiftbyreg);
                				  else
                  				  pseudo_emit(blk, op_ROR, op2reg, rm, shiftbyreg);
                        }
                        else  // rrx
                        {
                				  if (islogic && inst.dp.s)
                				    pseudo_emit(blk, op_RRX | PSSETFLAGS, CFLAG, op2reg, rm);
                				  else
                	  			  pseudo_emit(blk, op_RRX, op2reg, rm);
                        }
                      }
                      break;
                    }
                	}
                	/*
                	switch (shifttype)
                	{
                		case 0:  // LSL / no shift
                		{
                		  if (shiftbyreg != -1)
                			{
                			  op2reg = pseudo_newtemp(&tc);
                				if (islogic && inst.dp.s)
                				  pseudo_emit(blk, op_LSL | PSSETFLAGS, CFLAG, op2reg, rm, shiftbyreg);
                				else
                          pseudo_emit(blk, op_LSL, op2reg, rm, shiftbyreg);
                			}
                			else
                			{
                			  op2reg = rm;
                			}
                		}
                		break;
                		
                		case 1:  // LSR
                		{
                		  op2reg = pseudo_newtemp(&tc);
                			if (islogic && inst.dp.s)
                			  pseudo_emit(blk, op_LSR | PSSETFLAGS, CFLAG, op2reg, rm, shiftbyreg);
                			else
                		  	pseudo_emit(blk, op_LSR, op2reg, rm, shiftbyreg);
                		}
                		break;
                		
                		case 2:  // ASR
                		{
                		  op2reg = pseudo_newtemp(&tc);
                			if (islogic && inst.dp.s)
                			  pseudo_emit(blk, op_ASR | PSSETFLAGS, CFLAG, op2reg, rm, shiftbyreg);
                			else
                		  	pseudo_emit(blk, op_ASR, op2reg, rm, shiftbyreg);
                		}
                		break;
                		
                		case 3:  // ROR/RRX
                		{
                		  if (amount==0)  // immediate/amount==0 means RRX
                			{
                			  op2reg = pseudo_newtemp(&tc);
                				if (islogic && inst.dp.s)
                				  pseudo_emit(blk, op_RRX | PSSETFLAGS, CFLAG, op2reg, rm);
                				else
                	  			pseudo_emit(blk, op_RRX, op2reg, rm);
                			}
                			else
                			{
                		  	op2reg = pseudo_newtemp(&tc);
                				if (islogic && inst.dp.s)
                				  pseudo_emit(blk, op_ROR | PSSETFLAGS, reg_CPSRC, op2reg, rm,
                                      shiftbyreg);
                				else
                  				pseudo_emit(blk, op_ROR, op2reg, rm, shiftbyreg);
                			}
                		}
                	}*/
                	
                	// at this point, we should have op1 in inst.dp.rn and op2 in op2reg
                	pseudo_dp_guts(machine, inst, blk, op2reg, &tc);
                }
                
                void pseudo_dp_imm(machineinfo* machine, instructionformat inst, void* blk)
         155 -> {
                  sint5 tc = -1;
                	uint5 imm = pseudo_newtemp(&tc), temp = inst.dp.operand2;
                  uint5 value = temp&255, amount = (temp>>8)*2;
                	const uint5 logic = 0xf303;
                	int islogic = logic & (1<<inst.dp.opcode);
                
                	pseudo_condition(machine, inst.generic.cond, blk);
                
                  if (inst.dp.rn==reg_R15)
                    pseudo_reconstitutepc(machine, inst.dp.s, blk, &tc, 0);
                
                	pseudo_emit(blk, op_CONST, imm, ROR(value, amount));
                  
                  if (inst.dp.s && islogic && amount)
                    pseudo_emit(blk, op_CONST | PSSETFLAGS, CFLAG, reg_CPSRC,
                      (value & (1U<<(amount-1))) ? 1 : 0);
                	
                	pseudo_dp_guts(machine, inst, blk, imm, &tc);
                }
                
                void pseudo_dp_guts(machineinfo* machine, instructionformat inst, void* blk,
                                    uint5 op2reg, sint5* tc)
         373 -> {
                  uint3 sflagset = inst.dp.s;
                
                  if (inst.dp.rd==reg_R15) inst.dp.s = 0;
                
                	switch (inst.dp.opcode)
                	{
                	  case dp_AND:
                		{
                		  if (inst.dp.s)
                  		  pseudo_emit(blk, op_AND | PSSETFLAGS, ZFLAG | NFLAG,
                				            inst.dp.rd, inst.dp.rn, op2reg);
                			else
                  		  pseudo_emit(blk, op_AND, inst.dp.rd, inst.dp.rn, op2reg);
                		}
                		break;
                		
                		case dp_EOR:
                		{
                		  if (inst.dp.s)
                  		  pseudo_emit(blk, op_EOR | PSSETFLAGS, ZFLAG | NFLAG,
                				            inst.dp.rd, inst.dp.rn, op2reg);
                			else
                  		  pseudo_emit(blk, op_EOR, inst.dp.rd, inst.dp.rn, op2reg);
                		}
                		break;
                		
                		case dp_SUB:
                		{
                			if (inst.dp.s)
                			  pseudo_emit(blk, op_SUB | PSSETFLAGS, ALLFLAGS,
                				            inst.dp.rd, inst.dp.rn, op2reg);
                		  else
                		    pseudo_emit(blk, op_SUB, inst.dp.rd, inst.dp.rn, op2reg);
                		}
                		break;
                		
                		case dp_RSB:
                		{
                		  if (inst.dp.s)
                  		  pseudo_emit(blk, op_SUB | PSSETFLAGS, ALLFLAGS,
                				            inst.dp.rd, op2reg, inst.dp.rn);
                			else
                  		  pseudo_emit(blk, op_SUB, inst.dp.rd, op2reg, inst.dp.rn);
                		}
                		break;
                		
                		case dp_ADD:
                		{
                		  if (inst.dp.s)
                  		  pseudo_emit(blk, op_ADD | PSSETFLAGS, ALLFLAGS,
                				            inst.dp.rd, inst.dp.rn, op2reg);
                			else
                  		  pseudo_emit(blk, op_ADD, inst.dp.rd, inst.dp.rn, op2reg);
                		}
                		break;
                		
                		case dp_ADC:
                		{
                		  if (inst.dp.s)
                  		  pseudo_emit(blk, op_ADC | PSSETFLAGS, ALLFLAGS,
                				            inst.dp.rd, inst.dp.rn, op2reg, reg_CPSRC);
                			else
                  		  pseudo_emit(blk, op_ADC, inst.dp.rd, inst.dp.rn, op2reg, reg_CPSRC);
                		}
                		break;
                		
                		case dp_SBC:
                		{
                		  if (inst.dp.s)
                  		  pseudo_emit(blk, op_SBC | PSSETFLAGS, ALLFLAGS,
                				            inst.dp.rd, inst.dp.rn, op2reg, reg_CPSRC);
                			else
                  		  pseudo_emit(blk, op_SBC, inst.dp.rd, inst.dp.rn, op2reg, reg_CPSRC);
                		}
                		break;
                		
                		case dp_RSC:
                		{
                		  if (inst.dp.s)
                				pseudo_emit(blk, op_SBC | PSSETFLAGS, ALLFLAGS,
                			            	inst.dp.rd, op2reg, inst.dp.rn, reg_CPSRC);
                			else
                				pseudo_emit(blk, op_SBC, inst.dp.rd, op2reg, inst.dp.rn, reg_CPSRC);
                		}
                		break;
                		
                		case dp_TST:
                		{
                		  if (inst.dp.s)
                  			pseudo_emit(blk, op_TST | PSSETFLAGS, ZFLAG | NFLAG,
                				            inst.dp.rn, op2reg);
                			else
                        fprintf(stderr, "Warning: TEQ with clear S flag!\n");
                		}
                		break;
                		
                		case dp_TEQ:
                		{
                		  if (inst.dp.s)
                  			pseudo_emit(blk, op_TEQ | PSSETFLAGS, ZFLAG | NFLAG,
                				            inst.dp.rn, op2reg);
                			else
                        fprintf(stderr, "Warning: TEQ with clear S flag!\n");
                		}
                		break;
                		
                		case dp_CMP:
                		{
                		  if (inst.dp.s)
                			  pseudo_emit(blk, op_CMP | PSSETFLAGS, ALLFLAGS,
                				            inst.dp.rn, op2reg);
                			else
                        fprintf(stderr, "Warning: CMP with clear S flag!\n");
                		}
                		break;
                		
                		case dp_CMN:
                		{
                		  if (inst.dp.s)
                			  pseudo_emit(blk, op_CMN | PSSETFLAGS, ALLFLAGS,
                				            inst.dp.rn, op2reg);
                			else
                			  fprintf(stderr, "Warning: CMN with clear S flag!\n");
                		}
                		break;
                		
                		case dp_ORR:
                		{
                		  if (inst.dp.s)
                		  	pseudo_emit(blk, op_OR | PSSETFLAGS, ZFLAG | NFLAG,
                				            inst.dp.rd, inst.dp.rn, op2reg);
                			else
                		  	pseudo_emit(blk, op_OR, inst.dp.rd, inst.dp.rn, op2reg);
                		}
                		break;
                		
                		case dp_MOV:
                		{
                		  if (inst.dp.s)
                  		  pseudo_emit(blk, op_MOV | PSSETFLAGS, ZFLAG | NFLAG, inst.dp.rd, 
                                    op2reg);
                			else
                  		  pseudo_emit(blk, op_MOV, inst.dp.rd, op2reg);
                		}
                		break;
                		
                		case dp_BIC:
                		{
                		  uint5 inv = pseudo_newtemp(tc);
                		  pseudo_emit(blk, op_MVN, inv, op2reg);
                			if (inst.dp.s)
                				pseudo_emit(blk, op_AND | PSSETFLAGS, ZFLAG | NFLAG,
                				            inst.dp.rd, inst.dp.rn, inv);
                			else
                				pseudo_emit(blk, op_AND, inst.dp.rd, inst.dp.rn, inv);
                		}
                		break;
                		
                		case dp_MVN:
                		{
                		  if (inst.dp.s)
                		  	pseudo_emit(blk, op_MVN | PSSETFLAGS, ZFLAG | NFLAG, inst.dp.rd,
                                    op2reg);
                			else
                		  	pseudo_emit(blk, op_MVN, inst.dp.rd, op2reg);
                		}
                		break;
                	}
                	
                /*
                	if (inst.dp.s)
                	{
                	  pseudo_emit(blk, op_Z, reg_CPSRZ, inst.dp.rd);
                		pseudo_emit(blk, op_N, reg_CPSRN, inst.dp.rd);
                	}
                */
                	
                	if (inst.dp.rd==reg_R15)
                	{
                    if (sflagset)
                	    pseudo_emit(blk, op_SETPC | PSSETFLAGS, ALLFLAGS);
                    else
                	    pseudo_emit(blk, op_SETPC);
                	}
                }
                
                void pseudo_bra(machineinfo* machine, instructionformat inst, void* blk)
          98 -> {
                	sint5 offset = (sint5)(inst.bra.offset<<8)>>6, tc=-1;
                	psblock* psb = (psblock*) blk;
                	registerinfo* reg = machine->reg;
                
                /*	offset += 8;*/
                	
                	if (inst.bra.l)
                	{
                    uint5 four = pseudo_newtemp(&tc);
                    pseudo_condition(machine, inst.generic.cond, blk);
                    pseudo_reconstitutepc(machine, 1, blk, &tc, 0);
                    pseudo_emit(blk, op_CONST, four, 4);
                		pseudo_emit(blk, op_SUB, reg_R14, reg_R15, four);
                		pseudo_jmp(machine, cc_AL, (uint5*)(GET(15)+offset/*-8*/), psb);
                /*		pseudo_emit(blk, op_BAL,
                		  pseudo_getpsaddr(psb->pseudomap, (uint5*)(GET(15)+offset-8),
                		  psb->length));*/
                	}
                	else
                	{
                	  if (inst.generic.cond != cc_NV)
                		{
                /*      pseudo_emit(blk, op_BEQ + inst.generic.cond,
                			  pseudo_getpsaddr(psb->pseudomap, (uint5*)(GET(15)+offset-8),
                				psb->length));*/
                      pseudo_jmp(machine, inst.generic.cond, (uint5*)(GET(15)+offset/*-8*/), 
                                 psb);
                		}
                	}
                }
                
                void pseudo_mul(machineinfo* machine, instructionformat inst, void* blk)
           1 -> {
                  sint5 tc=-1;
                	uint5 temp = inst.mul.rd;
                	pseudo_condition(machine, inst.generic.cond, blk);
                
                  if (inst.mul.a && inst.mul.rd==inst.mul.rn) temp = pseudo_newtemp(&tc);
                	
                	if (inst.mul.s && !inst.mul.a)
                  	pseudo_emit(blk, op_MUL | PSSETFLAGS, ZFLAG | NFLAG,
                		            temp, inst.mul.rm, inst.mul.rs);
                	else
                  	pseudo_emit(blk, op_MUL, temp, inst.mul.rm, inst.mul.rs);
                
                  if (inst.mul.a)
                	{
                	  if (inst.mul.s)
                  	  pseudo_emit(blk, op_ADD | PSSETFLAGS, ZFLAG | NFLAG,
                			            inst.mul.rd, temp, inst.mul.rn);
                		else
                  	  pseudo_emit(blk, op_ADD, inst.mul.rd, temp, inst.mul.rn);
                	}
                
                /*  if (inst.mul.s)
                	{
                	  pseudo_emit(blk, op_Z, reg_CPSRZ, inst.mul.rd);
                		pseudo_emit(blk, op_N, reg_CPSRN, inst.mul.rd);
                	}*/
                }
                
                void pseudo_sdt(machineinfo* machine, instructionformat inst, void* blk)
         107 -> {
                  sint5 tc = -1, offset = -1, addr;
                	uint5 setpc = 0;
                
                  pseudo_condition(machine, inst.generic.cond, blk);
                
                 /* pseudo_emit(blk, op_CONST, reg_T5, 0x0);
                  pseudo_emit(blk, op_CONST, reg_T4, machine->reg->r[15]);
                  pseudo_emit(blk, op_STW, reg_T5, reg_T4);
                
                  pseudo_emit(blk, op_CONST, reg_T5, 0x4);
                  pseudo_emit(blk, op_STW, reg_T5, reg_R5);*/
                	  
                	addr = pseudo_newtemp(&tc);
                	
                	if (inst.sdt.i)  // register(/shifted register) offset
                	{
                	  uint5 temp = inst.sdt.offset;
                		uint5 rm = temp&15, shifttype = (temp>>5)&3, amount = (temp>>7);
                
                    if (rm==15 || inst.sdt.rn==15)
                      pseudo_reconstitutepc(machine, 0, blk, &tc, 0);
                
                		offset = pseudo_newtemp(&tc);
                		
                		switch (shifttype)
                		{
                		  case 0:  // LSL / no shift
                			{
                			  if (amount>0)
                				{
                				  uint5 amt = pseudo_newtemp(&tc);
                					pseudo_emit(blk, op_CONST, amt, amount);
                				  pseudo_emit(blk, op_LSL, offset, rm, amt);
                				}
                				else
                				{
                				  offset = rm;
                				}
                			}
                			break;
                			
                			case 1:  // LSR
                			{
                			  uint5 amt = pseudo_newtemp(&tc);
                			  if (amount==0) amount=32;
                				pseudo_emit(blk, op_CONST, amt, amount);
                				pseudo_emit(blk, op_LSR, offset, rm, amt);
                			}
                			break;
                			
                			case 2:  // ASR
                			{
                			  uint5 amt = pseudo_newtemp(&tc);
                				if (amount==0) amount=32;
                				pseudo_emit(blk, op_CONST, amt, amount);
                				pseudo_emit(blk, op_ASR, offset, rm, amt);
                			}
                			break;
                			
                			case 3:  // ROR/RRX
                			{
                			  if (amount)  // ROR
                				{
                				  uint5 amt = pseudo_newtemp(&tc);
                					pseudo_emit(blk, op_CONST, amt, amount);
                				  pseudo_emit(blk, op_ROR, offset, rm, amt);
                				}
                				else  // RRX
                				{
                				  pseudo_emit(blk, op_RRX, offset, rm);
                				}
                			}
                		}
                	}
                	else  // immediate offset
                	{
                    if (inst.sdt.rn==15)
                      pseudo_reconstitutepc(machine, 0, blk, &tc, 0);
                
                	  offset = pseudo_newtemp(&tc);
                		pseudo_emit(blk, op_CONST, offset, inst.sdt.offset);
                	}
                
                	if (inst.sdt.p)  // pre-indexed
                	{
                    if (inst.sdt.u)
                		  pseudo_emit(blk, op_ADD, addr, inst.sdt.rn, offset);
                		else
                		  pseudo_emit(blk, op_SUB, addr, inst.sdt.rn, offset);
                	}
                	else  // not pre-indexed
                	{
                	  pseudo_emit(blk, op_MOV, addr, inst.sdt.rn);
                	}
                
                	if (inst.sdt.l)  // load
                	{
                	  if (inst.sdt.b)  // byte
                		{
                		  pseudo_emit(blk, op_LDB, inst.sdt.rd, addr);
                		}
                		else  // word
                		{
                		  pseudo_emit(blk, op_LDW, inst.sdt.rd, addr);
                			if (inst.sdt.rd==reg_R15) setpc = 1;
                		}
                	}
                	else  // store
                	{
                    if (inst.sdt.rd==15) pseudo_reconstitutepc(machine, 1, blk, &tc, 4);
                
                	  if (inst.sdt.b)  // byte
                		{
                		  pseudo_emit(blk, op_STB, addr, inst.sdt.rd);
                		}
                		else  // word
                		{
                		  pseudo_emit(blk, op_STW, addr, inst.sdt.rd);
                		}
                	}
                
                	if (!inst.sdt.p)  // post-indexed addressing
                	{
                	  if (inst.sdt.u)  // up
                		{
                		  pseudo_emit(blk, op_ADD, inst.sdt.rn, inst.sdt.rn, offset);
                		}
                		else  // down
                		{
                		  pseudo_emit(blk, op_SUB, inst.sdt.rn, inst.sdt.rn, offset);
                		}
                	}
                
                	if (inst.sdt.w)  // writeback
                	{
                	  pseudo_emit(blk, op_MOV, inst.sdt.rn, addr);
                	}
                
                	if (setpc)
                	{
                	  pseudo_emit(blk, op_SETPC | PSSETFLAGS, ALLFLAGS);
                	}
                }
                
                void pseudo_bdt(machineinfo* machine, instructionformat inst, void* blk)
          48 -> {
                  sint5 tc = -1, i;
                	uint5 addr = pseudo_newtemp(&tc), base = inst.bdt.rn,
                	      incr = pseudo_newtemp(&tc), setpc = 0;
                	
                	pseudo_condition(machine, inst.generic.cond, blk);
                	
                	pseudo_emit(blk, op_MOV, addr, base);
                	pseudo_emit(blk, op_CONST, incr, 4);
                
                  if (inst.bdt.u)  // upwards
                  {
                    for (i=0; i<16; i++)
                    {
                	    if (inst.bdt.reglist & (1<<i))
                		  {
                	  	  if (inst.bdt.p)  // preincrement
                			  {
                			  	pseudo_emit(blk, op_ADD, addr, addr, incr);
                        }
                
                			  if (inst.bdt.l)  // load
                			  {
                		  	  pseudo_emit(blk, op_LDW, i, addr);
                				  if (i==reg_R15) setpc = 1;
                			  }
                			  else  // save
                			  {
                          if (i==reg_R15)
                            pseudo_reconstitutepc(machine, 1, blk, &tc, 0);
                
                		  	  pseudo_emit(blk, op_STW, addr, i);
                			  }
                
                			  if (!inst.bdt.p)  // postincrement
                			  {
                			  	pseudo_emit(blk, op_ADD, addr, addr, incr);
                			  }
                      }
                    }
                  }
                  else  // downwards
                  {
                    for (i=15; i>=0; i--)
                    {
                	    if (inst.bdt.reglist & (1<<i))
                		  {
                	  	  if (inst.bdt.p)  // predecrement
                			  {
                			  	pseudo_emit(blk, op_SUB, addr, addr, incr);
                        }
                
                			  if (inst.bdt.l)  // load
                			  {
                		  	  pseudo_emit(blk, op_LDW, i, addr);
                				  if (i==reg_R15) setpc = 1;
                			  }
                			  else  // save
                			  {
                          if (i==reg_R15)
                            pseudo_reconstitutepc(machine, 1, blk, &tc, 0);
                
                		  	  pseudo_emit(blk, op_STW, addr, i);
                			  }
                
                			  if (!inst.bdt.p)  // postdecrement
                			  {
                			  	pseudo_emit(blk, op_SUB, addr, addr, incr);
                			  }
                      }
                    }
                  }
                	
                	if (inst.bdt.w)  // writeback
                	{
                	  pseudo_emit(blk, op_MOV, base, addr);
                	}
                	
                	if (setpc)
                	{
                    if (inst.bdt.s)
                      pseudo_emit(blk, op_SETPC | PSSETFLAGS, ALLFLAGS);
                    else
                	    pseudo_emit(blk, op_SETPC);
                	}
                }
                
                void pseudo_swi(machineinfo* machine, instructionformat inst, void* blk)
           1 -> {
                  sint5 tc=-1;
                  pseudo_condition(machine, inst.generic.cond, blk);
                
                  pseudo_reconstitutepc(machine, 1, blk, &tc, 0);
                	pseudo_emit(blk, op_SWI, inst.swi.number);
                }
                
                void pseudo_cdt(machineinfo* machine, instructionformat inst, void* blk)
       ##### -> {
                }
                
                void pseudo_cdo(machineinfo* machine, instructionformat inst, void* blk)
       ##### -> {
                }
                
                void pseudo_crt(machineinfo* machine, instructionformat inst, void* blk)
       ##### -> {
                }
                
                void pseudo_sds(machineinfo* machine, instructionformat inst, void* blk)
       ##### -> {
                }
                
                void pseudo_und(machineinfo* machine, instructionformat inst, void* blk)
       ##### -> {
                }


Top 10 Lines:

     Line      Count

       61       3114
       76       2264
      404        747
       37        690
       48        690
      375        690
      415        642
      785        373
      439        261
      476        218

Execution Summary:

       27   Executable lines in this file
       27   Lines executed
   100.00   Percent of the file executed

    10521   Total number of line executions
   389.67   Average executions per line
