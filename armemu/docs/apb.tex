\chapter{Phetacode to \ia\ translation}

The following table lists the \ia\ code equivalents of most phetacode primitives. Parts of the table with heavy duplication are omitted for brevity.

Where a proportional font is used on the right-hand side of the table, the actual code which performs that function is omitted for clarity. Terms in square brackets may be included or not depending on the context.

In some cases, {\tt rx}, {\tt ry} etc\char`.\ as {\it source} (usually left-hand) operands in \ia\ assembler fragments may refer to either a memory location or a register.

The phrase ``fncall'' expands to code capable of invoking a C function in the compiled emulator code.

\begin{longtable}{cl}
Phetacode instruction & \ia\ translation\\
\hline
\vspace{0.3cm}
\(\beqfn phetalabel\) & \begin{tabular}{l} {\tt jz \ia label} \end{tabular}
\footnote{The allocation state must be coerced before each branch.}\\
\vspace{0.3cm}
\(\bnefn phetalabel\) & \begin{tabular}{l} {\tt jnz \ia label} \end{tabular}\\
\vspace{0.3cm}
\(\bcsfn phetalabel\) & \begin{tabular}{l} {\tt jc \ia label} \end{tabular}\\
\vspace{0.3cm}
\(\bccfn phetalabel\) & \begin{tabular}{l} {\tt jnc \ia label} \end{tabular}\\
\vspace{0.3cm}
\(\bmifn phetalabel\) & \begin{tabular}{l} {\tt js \ia label} \end{tabular}\\
\vspace{0.3cm}
\(\bplfn phetalabel\) & \begin{tabular}{l} {\tt jns \ia label} \end{tabular}\\
\vspace{0.3cm}
\(\bvsfn phetalabel\) & \begin{tabular}{l} {\tt jo \ia label} \end{tabular}\\
\vspace{0.3cm}
\(\bvcfn phetalabel\) & \begin{tabular}{l} {\tt jno \ia label} \end{tabular}\\

\vspace{0.3cm}
\(\bhifn phetalabel\) &
{\tt \begin{tabular}{l}
[cmc] \\
ja \ia label
\end{tabular}\footnote{{\tt cmc} is inserted if the \ia\ carry flag is currently valid, but {\it not} inverted.}}\\

\vspace{0.3cm}
\(\blsfn phetalabel\) &
{\tt \begin{tabular}{l}
[cmc] \\
jbe \ia label
\end{tabular}}\\

\vspace{0.3cm}
\(\bgefn phetalabel\) & \begin{tabular}{l} {\tt jge \ia label} \end{tabular}\\
\vspace{0.3cm}
\(\bltfn phetalabel\) & \begin{tabular}{l} {\tt jl \ia label} \end{tabular}\\
\vspace{0.3cm}
\(\bgtfn phetalabel\) & \begin{tabular}{l} {\tt jg \ia label} \end{tabular}\\
\vspace{0.3cm}
\(\blefn phetalabel\) & \begin{tabular}{l} {\tt jle \ia label} \end{tabular}\\
\vspace{0.3cm}
\(\balfn phetalabel\) & \begin{tabular}{l} {\tt jmp \ia label} \end{tabular}\\
\vspace{0.3cm}

\(\begin{array}{rcl}
r_x & \leftarrow & r_x \aslfn r_y
\end{array}
\)
& \begin{tabular}{l}
{\tt shll ry,rx} \end{tabular} \footnote{For register-specified shifts, {\tt ry} is first moved into the {\tt cl} register, as required by the instruction encoding. This may require displacing the {\tt ecx} register if previously in use.}\\
\vspace{0.3cm}

\(\begin{array}{rcl}
r_x & \leftarrow & r_y \aslfn r_z
\end{array}
\)
& {\tt \begin{tabular}{l}mov ry,rx \\shll rz,rx \end{tabular}} \\

\vspace{0.3cm}
\(\begin{array}{rcl}
r_y & \leftarrow & \#imm\\
r_x & \leftarrow & r_x \aslfn r_y
\end{array}
\)
& \begin{tabular}{l}
{\tt shll \$imm,rx}
\end{tabular} \\

\vspace{0.3cm}
\(\begin{array}{rcl}
r_z & \leftarrow & \#imm\\
r_x & \leftarrow & r_y \aslfn r_z
\end{array}
\)
&\begin{tabular}{l}
{\tt mov ry,rx}\\
{\tt shll \$imm,rx}
\end{tabular} \\

\vspace{0.3cm}
\(\begin{array}{rcl}
r_x & \leftarrow & r_x \lsrfn r_y
\end{array}
\)
& \begin{tabular}{l}
{\tt shrl ry,rx}
\end{tabular} \footnote{Other shift operations ($\lsrfn$, $\asrfn$, $\rorfn$) have the same variants as $\aslfn$.}\\

\vspace{0.3cm}
\(\begin{array}{rcl}
r_x & \leftarrow & r_x \asrfn r_y
\end{array}
\)
& \begin{tabular}{l}
{\tt sarl ry,rx}
\end{tabular}\\

\vspace{0.3cm}
\(\begin{array}{rcl}
r_x & \leftarrow & r_x \rorfn r_y
\end{array}
\)
& \begin{tabular}{l}
{\tt rorl ry,rx}
\end{tabular}\\

\vspace{0.3cm}
\(\begin{array}{rcl}
r_x & \leftarrow & \rrxfn r_x
\end{array}\)
& \begin{tabular}{l}
{\tt rcrl \$1,rx}
\end{tabular}\\

\vspace{0.3cm}
\(\begin{array}{rcl}
r_x & \leftarrow & \#imm
\end{array}\)
& \begin{tabular}{l}
{\tt movl \$imm,rx}
\end{tabular}\\

\vspace{0.3cm}
\(\begin{array}{rcl}
r_x & \leftarrow & r_y
\end{array}\)
& \begin{tabular}{l}
{\tt movl ry,rx}
\end{tabular}\\

\vspace{0.3cm}
\(\begin{array}{rcl}
r_y & \leftarrow & \#imm\\
r_x & \leftarrow & r_y
\end{array}\)
& \begin{tabular}{l}
{\tt movl \$imm,rx}
\end{tabular}\\

\vspace{0.3cm}
\(\begin{array}{rcl}
r_x & \leftarrow & \overline{r_x}
\end{array}\)
& \begin{tabular}{l}
{\tt notl rx}
\end{tabular}\\

\vspace{0.3cm}
end &
\begin{tabular}{l}
spill-all-regs\\
{\tt ret}
\end{tabular} \\

\vspace{0.3cm}
setpc &
\begin{tabular}{l}
{\tt addl \$8,pc} \\
\char`[extract-flags\char`]\\
{\tt andl 0x3fffffc,pc}\\
spill-all-regs\\
{\tt ret}
\end{tabular} \\

\vspace{0.3cm}
reconstructpc {\it imm}&
\begin{tabular}{l}
fncall reconstructpc
\end{tabular}\\

\vspace{0.3cm}
xjmp {\it imm} &
\begin{tabular}{l}
spill-all-regs\\
{\tt movl \$imm,temp}\\
{\tt jmp *temp}
\end{tabular} \\

\vspace{0.3cm}
swi {\it imm} &
\begin{tabular}{l}
fncall reconstructpc\\
spill-all-regs\\
fncall swi\\
{\tt ret}\\
\end{tabular} \\

\vspace{0.3cm}
\(\begin{array}{rcl}
r_x & \leftarrow & r_x + r_x
\end{array}\) &
\begin{tabular}{l}
{\tt addl rx,rx}
\end{tabular} \\

\vspace{0.3cm}
\(\begin{array}{rcl}
r_x & \leftarrow & r_x + r_y
\end{array}\) &
\begin{tabular}{l}
{\tt addl ry,rx}
\end{tabular} \\

\vspace{0.3cm}
\(\begin{array}{rcl}
r_x & \leftarrow & r_y + r_x
\end{array}\) &
\begin{tabular}{l}
{\tt addl ry,rx}
\end{tabular} \\

\vspace{0.3cm}
\(\begin{array}{rcl}
r_x & \leftarrow & r_y + r_y
\end{array}\) &
\begin{tabular}{l}
{\tt movl ry,rx}\\
{\tt addl rx,rx}
\end{tabular} \\

\vspace{0.3cm}
\(\begin{array}{rcl}
r_x & \leftarrow & r_y + r_z
\end{array}\) &
\begin{tabular}{l}
{\tt movl ry,rx}\\
{\tt addl rz,rx}
\end{tabular} \\

\vspace{0.3cm}
\(\begin{array}{rcl}
r_y & \leftarrow & \#imm\\
r_x & \leftarrow & r_x + r_y
\end{array}\) &
\begin{tabular}{l}
{\tt addl \$imm,rx}
\end{tabular} \\

\vspace{0.3cm}
\(\begin{array}{rcl}
r_z & \leftarrow & \#imm\\
r_x & \leftarrow & r_y + r_z
\end{array}\) &
\begin{tabular}{l}
{\tt movl ry,rx}\\
{\tt addl \$imm,rx}
\end{tabular} \\

\vspace{0.3cm}
\(\begin{array}{rcl}
r_y & \leftarrow & \#imm\\
r_x & \leftarrow & r_y + r_x
\end{array}\) &
\begin{tabular}{l}
{\tt addl \$imm,rx}
\end{tabular} \\

\vspace{0.3cm}
\(\begin{array}{rcl}
r_y & \leftarrow & \#imm\\
r_x & \leftarrow & r_y + r_z
\end{array}\) &
\begin{tabular}{l}
{\tt movl rz,rx}\\
{\tt addl \$imm,rx}
\end{tabular} \\

\vspace{0.3cm}
\(\begin{array}{rcl}
r_x & \leftarrow & r_y + r_x + cflag
\end{array}\) &
\begin{tabular}{l}
{\tt adcl ry,rx}
\end{tabular}\footnote{Variants on {\tt adc}, {\tt and}, {\tt or}, {\tt eor} are the same as for {\tt add}.} \\

\vspace{0.3cm}
\(\begin{array}{rcl}
r_x & \leftarrow & r_y \wedge r_x
\end{array}\) &
\begin{tabular}{l}
{\tt andl ry,rx}
\end{tabular} \\

\vspace{0.3cm}
\(\begin{array}{rcl}
r_x & \leftarrow & r_y \vee r_x
\end{array}\) &
\begin{tabular}{l}
{\tt orl ry,rx}
\end{tabular} \\

\vspace{0.3cm}
\(\begin{array}{rcl}
r_x & \leftarrow & r_y \oplus r_x
\end{array}\) &
\begin{tabular}{l}
{\tt xorl ry,rx}
\end{tabular} \\

\vspace{0.3cm}
\(\begin{array}{rcl}
r_x & \leftarrow & r_y - r_x
\end{array}\) &
\begin{tabular}{l}
{\tt pushl ry}\\
{\tt xchgl ry,rx}\\
{\tt subl ry,rx}\\
{\tt popl ry}
\end{tabular} \footnote{This is quite a tricky case to understand. Note that simpler versions of the code, employing {\tt neg} for instance, will set flags incorrectly. Other {\tt sub} and {\tt sbc} variants are the same as for {\tt add}.}\\

\vspace{0.3cm}
\(\begin{array}{rcl}
r_x & \leftarrow & r_y - r_x - \overline{cflag}
\end{array}\) &
\begin{tabular}{l}
{\tt pushl ry}\\
{\tt xchgl ry,rx}\\
{\tt [cmc]}\\
{\tt sbbl ry,rx}\\
{\tt popl ry}
\end{tabular} \footnote{{\tt cmc} is inserted if the carry flag is valid but not inverted. Also inserted in the other {\tt sbb} variants where necessary.}\\

\vspace{0.3cm}
\(\begin{array}{rcl}
r_x & \leftarrow & r_x * r_y
\end{array}\) &
\begin{tabular}{l}
{\tt imull ry,rx}
\end{tabular} \footnote{Multiplication variants are similar to addition, albeit with no immediate multiplication facility.} \\

\vspace{0.3cm}
\( r_x \cmpfn r_x \) &
\begin{tabular}{l}
{\tt cmpl rx,rx}
\end{tabular} \\

\vspace{0.3cm}
\( r_x \cmpfn r_y \) &
\begin{tabular}{l}
{\tt cmpl ry,rx}
\end{tabular} \\

\vspace{0.3cm}
\(\begin{array}{rcl}
r_y & \leftarrow & \#imm\\
 & & r_x \cmpfn r_y
\end{array}\) &
\begin{tabular}{l}
{\tt cmpl \$imm,rx}
\end{tabular} \\

\vspace{0.3cm}
\( r_x \tstfn r_y \) &
\begin{tabular}{l}
{\tt testl ry,rx}
\end{tabular} \footnote{{\tt tst} has same variants as {\tt cmp}.} \\

\vspace{0.3cm}
\( r_x \teqfn r_x \) &
\begin{tabular}{l}
{\tt movl rx,temp}\\
{\tt xorl temp,temp}\\
\end{tabular} \\

\vspace{0.3cm}
\( r_x \teqfn r_y \) &
\begin{tabular}{l}
{\tt movl rx,temp}\\
{\tt xorl ry,temp}\\
\end{tabular} \\

\vspace{0.3cm}
\(\begin{array}{rcl}
r_y & \leftarrow & \#imm\\
 & & r_x \teqfn r_y
\end{array}\) &
\begin{tabular}{l}
{\tt movl \$imm,temp}\\
{\tt xorl rx,temp}\\
\end{tabular} \\

\vspace{0.3cm}
\( r_x \cmnfn r_y \) &
\begin{tabular}{l}
{\tt movl rx,temp}\\
{\tt addl ry,temp}
\end{tabular} \footnote{{\tt cmn} variants are the same as {\tt teq}.}\\

\vspace{0.3cm}
\(\begin{array}{rcl}
!r_x & \leftarrow & r_y
\end{array}\) &
\begin{tabular}{l}
fncall writeword
\end{tabular} \\

\vspace{0.3cm}
\(\begin{array}{rcl}
r_x & \leftarrow & !r_y
\end{array}\) &
\begin{tabular}{l}
fncall readword
\end{tabular} \\

\vspace{0.3cm}
\(\begin{array}{rcl}
?r_x & \leftarrow & r_y
\end{array}\) &
\begin{tabular}{l}
fncall writebyte
\end{tabular} \\

\vspace{0.3cm}
\(\begin{array}{rcl}
r_x & \leftarrow & ?r_y
\end{array}\) &
\begin{tabular}{l}
fncall readbyte
\end{tabular}

\end{longtable}
