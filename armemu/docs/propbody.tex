% Draft #1 (final?)
%
%  Title page
%

\thispagestyle{empty}

\begin{flushright}
{\Large {\bf Julian T. Brown}\vspace{3mm} \\
Queens' College\vspace{1mm} \\
User ID: {\tt jtb20}} \\
\end{flushright}

\vspace{2cm}

\begin{center}
{\LARGE {\bf Computer Science Tripos Part II Project Proposal} \vspace{5mm} \\
     A Dynamically-Recompiling ARM Emulator}
\end{center}

%\vspace{2cm}

%{\large\begin{tabular}{ll}
%{\bf Project Originator:} & J. Brown \\ \\
%{\bf Special Resources:}  & Use of own machines \\ \\
%{\bf Overseers:} & Dr F. H. King \\ \\
%& \sigline \\ \\
%& Dr W. Clocksin \\ \\
%& \sigline \\ \\
%{\bf Supervisor:} & Dr M. Richards \\ \\
%& \sigline \\ \\
%{\bf Director of Studies:} & Dr R. Walker \\ \\
%& \sigline \\
%\end{tabular}}
\newpage

%
%  Main body
%

% Main document

\section*{Introduction}

Emulating one architecture on another is typically very slow -- you might expect performance an order of magnitude worse for emulated code than native code for a good emulator. Modelling the exact behaviour of a processor in software, necessarily down to every single bit for each operation, is bound to be slower than running code natively on the host architecture. This project's aim is to create an emulator for the ARM processor which runs ARM binaries at closer to the speed of native code on x86 Linux. This will be done using a technique known as dynamic recompilation, or binary code translation.

This is not an original idea -- there are commercial emulators available which perform dynamic recompilation with a very high level of success. These include: Virtual PC for the Power Macintosh (which emulates an IBM PC), Executor for the PC and other architectures (which emulates an 68k Macintosh), UltraHLE for the PC (which emulates a Nintendo 64 games console) and FX!32 for Windows NT, which runs Intel code on Alpha processors.

\section*{Resources required}

I will be using my own machines for the development of the project. The first is an Acorn Risc PC, which will be used to assemble and compile test binaries. It will be useful to compare the execution of ARM code on a real ARM processor with execution of the same code under emulation. The specifications for this machine are:

\begin{itemize}

\item 233MHz StrongARM processor
\item 36+2Mb RAM (+VRAM)
\item 2Gb+1.2Gb hard discs
\item RISC OS and NetBSD operating systems

\end{itemize}

Programming will be done under Linux on a second machine. Its specifications are:

\begin{itemize}

\item 450MHz AMD K6-2 processor
\item 64Mb RAM
\item 13Gb hard disc
\item Linux operating system

\end{itemize}

I will be programming in C, and any fragments of assembler which are
strictly necessary. Both machines have the GNU compiler toolchain installed (including C compilers and native assemblers), and other GNU development tools such as Make. Development will be done using these tools.

Backups will be done regularly using Pelican, the University archiving service (automatically, using {\tt cron}), and copies of source code and documentation will be kept on both development machines.

\section*{Starting point}

I have a strong knowledge of the C programming language, and a fairly thorough understanding of the ARM architecture through application-level (and some system-level) assembly programming, as well as through Part I Computer Science courses. However, I don't know the internals of the Intel x86 processor in great detail, and I've not done a great deal of programming for Linux. The project will involve learning about both of these.

I have done some background reading on dynamically-recompiling emulators on the Internet. There is some interesting and useful, if slightly non-technical, information on the following pages:

Information about Executor can be found at:

\begin{quotation}http://www.ardi.com/MacHack/machack.html\end{quotation}

There is an article about Virtual PC at:

\begin{quotation}http://www.byte.com/art/9711/sec4/art4.htm\end{quotation}

Information about FX!32 at:

\begin{quotation}http://www.digital.com/amt/fx32/fx-white.html\end{quotation}

There are more links relating to dynamic recompilation at:

\begin{quotation}http://www.cybervillage.co.uk/acorn/emulation/dynrcomp.htm\end{quotation}

\section*{Description}

There are several variants of the ARM architecture. I will aim to emulate a processor using the ARMv3 architecture, circa ARM610, using the 26-bit addressing mode (there is a large codebase compiled for this configuration from which test binaries may be taken).

Due to the nature of dynamic recompilation, `self-modifying' code will be problematic: if unchecked, a block of code which has been recompiled may be altered, then the original recompiled code may be called leading to unexpected behaviour. A large performance penalty would be imposed by trying to detect this (fairly rare) occurence automatically. Luckily, other members of the ARM family have the same problem (notably the StrongARM), brought about through having seperate instruction and data caches on-processor, so a mechanism exists for synchronising the caches on such processors. This mechanism, if understood by the emulator, would suffice to notify it of changes to code -- provided the code contains calls to synchronise the caches in the necessary places.

(Note that `self-modifying code' includes parts of an operating system which load programs from disc and executes them, not just curious pieces of hand-written code.)

Why dynamic recompilation? The alternative (static recompilation) would probably be more difficult in the general case -- simply because it's not easy (perhaps impossible) to determine what is code and what is data in an arbitrary block of memory. It's not unknown for compilers and assembly-language programmers to embed static data in the middle of function definitions, and attempting to translate these would lead to garbage.

Dynamic recompilation will work something like this: the emulator will start emulating code in the traditional fashion, fetching instructions from emulated memory using a virtual program counter, then decoding the instructions in software and performing equivalent operations to a real ARM processor by simulating the processor's logic. As the interpreter progresses, statistics are gathered on `blocks' of code being emulated. If a block of code is emulated often (say, inside the body of a loop), this is detected and a stream of Intel instructions which perform the same operations as the ARM instructions in that block are generated and executed. Now, when the program tries to execute the block of code again, the Intel instructions previously generated are called instead, which will result in much faster execution time for that block of code.

The dynamic recompilation of ARM to Intel instructions is likely to be the most challenging part of the project. The aim will be to produce code which works, rather than code which is highly optimised -- as such, instructions will probably be translated one at a time, instead of attempting to produce some sort of abstract semantic structure (which would probably be similar in form to intermediate code used by a full-blown compiler) then producing optimised code from that. Register allocation needs to be considered -- the ARM has 16 concurrently-visible 32-bit registers (15 which are general-purpose, although one of those is also used as a subroutine link register, and one which is the program counter). The x86 processor claims to have 8 general-purpose 32-bit registers, but in reality some of these have special uses (eg, stack manipulation), and some have special meanings in certain instructions. Clearly there is no way that ARM registers can have a one-to-one mapping with Intel registers -- some sort of allocation strategy will be needed.

Status flags are a vital part of virtually any processor -- conditional instructions generally rely on them, and on the ARM any instruction can have a condition attached to it. It's possible that calculation of these processor status flags may actually turn out to be easier for recompiled code than for the interpreting emulator -- the x86 CPU maintains a superset of the flags available on the ARM. The x86 provides (in the first twelve or so bits of the EFLAGS register):

\begin{itemize}

\item Carry flag (equivalent to the ARM `C' flag)
\item Parity flag
\item Auxiliary flag
\item Zero flag (equivalent to the ARM `Z' flag)
\item Sign flag (equivalent to the ARM `N' flag)
\item Trap flag
\item Interrupt enable flag
\item Direction flag
\item Overflow flag (equivalent to the ARM `V' flag)

\end{itemize}

Therefore, it may be possible to use the host processor to calculate the status of the equivalent ARM flags directly using its built-in logic, which will result in much denser, faster generated code. However, since it is absolutely vital that the status flags are correctly calculated, this approach needs to be researched and tested with a great deal of care.

Other issues which have to be considered include: switching between different processor modes, the memory-management unit, branching and arbitrary program-counter modification (used for example by jump tables, which are often generated in compiled code from the C `switch' statement), and self-modifying code. Algorithms and data structures will have to be found which are suitable for:

\begin{itemize}

\item Efficiently gathering statistics on potentially large programs
\item Storing streams of x86 instructions (with clearing out of `dead' code)
\item Holding virtual to physical memory page tables and access rights (MMU emulation)
\item Storing mappings between ARM and Intel registers during recompilation
\item Keeping track of the validity of status flags during recompilation, with knowledge about how the ARM and Intel treat flags differently for each instruction emulated and generated

\end{itemize}

It's important to say what I do not intend to implement for this project: given time constraints, I will not attempt to emulate a full computer system, just the ARM processor core and possibly the memory-management unit. Obviously this will not be able to boot an operating system of any description, so the emulator will be tested with stand-alone binaries which require no, or very few, system calls (which will be trapped and faked by the emulator). I may not have time to implement some more esoteric ARM features such as coprocessor and interrupt support.

There are several possible extensions to the project: the obvious one is to emulate a whole machine (possibly by incorporating the emulator core with, say, someone else's Acorn Archimedes emulator -- ArcEm by David Gilbert (http://www.treblig.clara.net) is very capable, is free and has source code suitable for Unix available. Its processor emulation is currently very slow). Another interesting possibility would be to program the memory management unit of the host machine to perform the address translation for the emulated machine rather than using a software-only approach (a trick used by several emulators, notably Virtual PC). This would speed up access to memory greatly, but would require very detailed knowledge of the host and emulated architectures.

\section*{Plan of work}

This project splits neatly into two sections -- a `traditional' interpreting emulator, and a dynamic recompiler. The latter is dependent on the former because of the statistic-gathering on code blocks which needs to be done before recompilation can take place. Elements of the traditional emulator can be reused by the recompiler too -- for instance, the ARM instruction decoding stage will be very similar if not identical in them both.

I will try to keep to the following deadlines:

\LTXtable{\textwidth}{timescale.tex}
