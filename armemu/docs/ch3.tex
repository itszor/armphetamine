\chapter{Implementation}

\section{Execution model}

The emulator runs as a simple, single-threaded Linux process. The `virtual' guest machine is much simpler than any real ARM-based computer. No attempt is made at emulating the whole ARM processor (the memory-management unit and ability to switch between different processor modes, notably, are missing), or running a real operating system\footnote{This was felt to be justified, and was known to be sufficient for running some `real' code from examining Edwin Dorr's ARM2 emulator \cite{Dorr9X}, which has similar limitations.}.

In this simple model, instructions are fetched from the program counter location, and executed one at a time (modifying the virtual machine's state as appropriate). The program counter is also fed to a profiler, which tallies execution counts for chunks of \arm\ code, passing any blocks which are executed often (so will benefit most from being sped up) to the binary code translator. The translated code block can now be used whenever the emulator tries to execute the equivalent ARM code again.

\subsection{System calls}

As no attempt at running a real operating system is currently made, a few system calls (software interrupts on the \arm) are trapped and `faked' by the emulator (character output, notably). The normal course of action on discovering a software interrupt is for the processor to switch to supervisor mode and branch through the SWI vector to a handler routine in the operating system -- for the present though, a subroutine is called in the emulator itself to handle SWIs.

\section{Interpreter}

\subsection{Decoder}

The instruction decoder was the first piece of code to be designed and implemented. The problem is to take an arbitrary 32-bit instruction and quickly break it down to be handled by an appropriate subroutine. Unfortunately, there isn't really one particular field which can reliably be used as a simple opcode, as can be seen from the table in figure \ref{armtable}. The twelve ``instruction classes'' listed refer to instructions for data processing, processor status register transfers, multiplications, single-data swaps, single-data transfers, undefined instructions, block-data transfers, branches, coprocessor data transfers, coprocessor data operations, coprocessor register transfers and software interrupts.

\begin{figure}[tbh]

\armtab

\caption{\label{armtable}ARM instruction encoding}
\end{figure}

The solution used was to switch on the sixteen values obtained from bits 24-27 of the instruction field, but as you can see this gives some overlaps between completely different types of instruction, for example multiplications and some data processing operations. So additionally, in cases like these, individual tests are used (eg, bits 4-7 to identify a multiply) within the cases.

The decoder is written in such a way that it can be reused by supplying different tables of function pointers for handling the different instruction types. The same routine is used for an \arm\ code disassembler, the instruction interpreter and in conversion to intermediate code.

\subsection{Executing instructions}

Execution of instructions is done by a variety of functions which handle particular classes of ARM instruction, and update the state of the virtual processor and memory map in the correct ways. Every operation must be absolutely perfect, otherwise emulated programs will execute incorrectly (sometimes in very subtle ways, depending on the nature of the flaw). Particular care must be taken for operations like shifting, where the behaviour of the in-built C operators {\tt <<} and {\tt >>} for shifts of zero and over 31 (for a word size of 32 bits) cannot necessarily be relied upon to be the same as the \arm.

\section{Profiler}

The profiler must perform two roles -- to gather contiguous blocks of code which are executed often, and to do it quickly. I will call the blocks gathered by the profiler `chunks', to differentiate them from the `basic blocks' described later.

The profiler maintains a hash table of chunks, keyed by the start address of each, and a `current' chunk. Before emulation starts, the current chunk is unset and the hash table is empty. The algorithm commences as follows:

\begin{itemize}

\item If the current chunk is unset, insert a new chunk into the hash table at the current program counter location, and make it the current chunk
\item If the program counter is at the start of the current chunk, either increment a use counter or execute the equivalent native code if present
\item If the program counter is at the end of (four bytes beyond) the current chunk, extend the chunk to include the program counter
\item If the program counter is outside the current chunk, either unset the current chunk or set the current chunk to a previously created chunk, incrementing its use count
\item If the program counter is at the start of a chunk, and its use count exceeds a certain threshold, recompile the chunk and execute that code instead

\end{itemize}

\begin{figure}

\begin{tabbing}
\keyword{Procedure} \keyword{Gather}($program\_counter$)\\
\startblk
  \keyword{If} (\keyword{Invalid}($current\_block$))\\
  \startblk
    $h =\ $\keyword{Lookup}($block\_table$, $program\_counter$)\\
    \keyword{If} (\keyword{Valid}($h$))\\
    \startblk
      \keyword{If} (\keyword{Valid}($h \rightarrow code$))\\
      \startblk
        \keyword{NativeInvoke}($h \rightarrow code$)\\
        \keyword{Unset}($current\_block$)\\
        \keyword{Return} true\\
      \stopblk
      \keyword{Else}\\
      \startblk
        \keyword{Increment}($use\_count$)\\
        \keyword{If} ($use\_count > threshold$)\\
        \startblk
          $h \rightarrow code =\ $\keyword{Recompile}($h$)\\
          \keyword{NativeInvoke}($h \rightarrow code$)\\
          \keyword{Unset}($current\_block$)\\
          \keyword{Return} true\\
        \stopblk
        \keyword{EndIf}\\
      \stopblk
      \keyword{EndIf}\\
    \stopblk
    \keyword{Else}\\
    \startblk
      $current\_block =\ $\keyword{Insert}($block\_table$, $program\_counter$)\\
      \keyword{Return} false\\
    \stopblk
    \keyword{EndIf}\\
  \stopblk
  \keyword{EndIf}\\
  \keyword{If} ($program\_counter =\ $\keyword{End}($current\_block$))\\
  \startblk
    \keyword{Extend}($current\_block$)\\
  \stopblk
  \keyword{Else}\\
  \startblk
    \keyword{If} (\keyword{Outside}($current\_block$, $program\_counter$)\\
    \startblk
      \keyword{Unset}($current\_block$)\\
      \keyword{Return} \keyword{Gather}($program\_counter$)\\
    \stopblk
    \keyword{EndIf}\\
  \stopblk
  \keyword{EndIf}\\
\stopblk
\keyword{End}\\
\end{tabbing}

\caption{\label{profalg}The profiler algorithm}
\end{figure}

This is written in pseudocode form in figure \ref{profalg}. This algorithm is sufficient to gather blocks of contiguous code, recompiling and executing natively sections which are executed often. At present, recompiled code blocks are never discarded.

Notice that it is possible for chunks to overlap. This is deliberate, as it means that fairly complex register-allocation state information at each instruction in the middle of recompiled chunks need not be stored explicitly.

\subsection{Profiler example}

In figure \ref{profilediag}, execution starts at (a) with no stored chunks and no current chunk. In (b), emulation continues in a straight line. In (c), the processor jumps back to an earlier point in the block (which remains the current block, and retains its previous size). In (d), the processor jumps outside the block -- a new block is started, and the old block is no longer the current block. In (e), emulation continues in a straight line and the new current block has been extended.

\begin{figure}[tbh]

\centerline{\epsfbox{profile.eps}}

\caption{\label{profilediag}Operation of the profiler}
\end{figure}

\section{Intermediate code}

The intermediate code is named ``phetacode''\footnote{Pronounced like the cheese.}, derived from the working title of the project, ARMphetamine.

The form of phetacode is very like a register transfer language which might be used by a normal compiler. Every operation has an opcode, destination register and up to three source registers. Some operations also have a 32-bit immediate field. \arm\ instructions may refer to 16 different registers, {\tt r0}-{\tt r15}, but this is expanded to 32 registers in phetacode so that processor status flags and a handful of `temporary' registers may be referred to explicitly by instructions.

In this document, I will write phetacode with the destination register on the left-hand side of an arrow, and source registers on the right-hand side, like this:

\[dest \leftarrow src1 \mathop{\rm operator} src2\]

Some instructions don't fit this pattern perfectly -- not all have destination registers, and some alter the flow of control. Branches and labels are written like this:
\begin{eqnarray*}
 & & \beqfn label\\
r_0 & \leftarrow & r_1 + r_2\\
label: r_3 & \leftarrow & r_3 - r_4
\end{eqnarray*}

For a more complete description of phetacode instructions, see appendix A.

\subsection{Registers}

The registers which may be used in phetacode are named as in figure \ref{phetareg}.

\begin{figure}
{\centering \( \begin{array}{cccccccc}
r_{0} & r_{1} & r_{2} & r_{3} & r_{4} & r_{5} & r_{6} & r_{7}\\
r_{8} & r_{9} & r_{10} & r_{11} & r_{12} & r_{13} & r_{14} & pc\\
t_{0} & t_{1} & t_{2} & t_{3} & t_{4} & t_{5} & cpsr & spsr\\
allflags & c\_flag & v\_flag & z\_flag & n\_flag & mode & int\_mask & unused\\
\end{array} \)\par}
\caption{\label{phetareg}Phetacode register names}
\end{figure}

$cpsr$ and $spsr$ refer to the \arm\ current and stored processor status registers respectively. $allflags$ refers to the status flags carry, overflow, zero and negative altogether, and the four $x\_flag$ pseudo-registers refer to them seperately. $mode$ refers to the \arm's current operating mode stored in the $cpsr$ (ie, {\sc User}, {\sc Supervisor}, {\sc Interrupt Request} or {\sc Fast Interrupt Request}). $int\_mask$ refers to the \arm's interrupt mask stored in the cpsr, which may have bits set to mask out IRQs or FIQs.

The registers $t_0$ to $t_3$ are used explicitly in phetacode (static temporaries), $t_4$ and $t_5$ are kept free to be allocated on-the-fly by code generating functions (dynamic temporaries).

The $unused$ register is used as a filler for usused operands in phetacode instructions, which have a fixed length of 32 bits plus an optional 32-bit immediate field.

\subsection{Flags}

A decision had to be made on what to do with instructions which set processor status flags. The trade-off is between using entirely seperate instructions, eg for an \arm\ subtraction:

\begin{code}
subs~r0,r1,r2
\end{code}

do we convert to two seperate instructions, something like this?
\begin{eqnarray*}
r_{0} & \leftarrow & r_{1} - r_{2} \\
flags & \leftarrow & \subflagvalfn(r_0,r_1,r_2)
\end{eqnarray*}

This approach was decided against, led by what was desired from the destination code: ideally, we want this code sequence to be converted to something like the following \ia\ code:

\begin{code}
movl~\%ebx,\%eax\\
subl~\%ecx,\%eax
\end{code}

The subtraction operation places the result in the destination register, and sets flags as needed, so it doesn't seem to make much sense to split the subtraction operation in half. So, although aesthestically less pleasing in some ways, each phetacode instruction is instead annotated with side-effect information, indicating flags which should be altered. The previous example becomes:

\[\mathrm{[cvnz]}\: r_0 \leftarrow r_1 - r_2 \]

to show that the carry, overflow, negative and zero flags are all updated by this instruction.

\subsection{Use of temporaries}

Some of the more complex \arm\ instructions are broken down into a large number of phetacode instructions. Phetacode only allows one simple operation per instruction, only allows register operands and only has conditionals for branch instructions. As an example, {\tt orrgts r0,r0,r1,ror r2} might be converted to:
\begin{eqnarray*}
 & & \blefn skip\\
\mathrm{[c]}\: t_{0} & \leftarrow & r_1 \rorfn r_2\\
\mathrm{[nz]}\: r_{0} & \leftarrow & r_0 \vee t_0\\
skip: & & ...
\end{eqnarray*}

Notice how the $t_0$ temporary variable has been introduced, and the conditional has been converted to a branch. Notice also that flag-affecting instructions can be split during an instruction translation.

\subsection{Flow control}

There are essentially two ways flow can be controlled in \arm\ programs: using branch instructions, or by directly modifying {\tt r15}, the program counter. Naturally, all cases of either must work perfectly under all circumstances or all hell will break loose. A clean solution for the latter in particular, however, initially proved to be slightly elusive.

Approaching the problem from one perspective, say we have a block of code representing a complete function, and we want to call that function from another block of code we're generating. The typical sequence in an \arm\ program might call the function with a {\tt bl} (branch-with-link) instruction, then return from the call at the end of the function with {\tt movs pc,r14} to restore the previous program counter. Obviously, the trivial translation of this into code which just moves {\tt r14} into {\tt pc} won't do the right thing!

The problem is that there now seems to be a fairly complex mapping between linear \arm\ code addresses and the address of the actual code we want to transfer control to. Is it necessary to explicitly store such detailed information in some sort of table for each fragment of \ia\ code we're generating for each \arm\ instruction? A partial solution was considered which would attempt to `shadow' the {\tt r14} return register -- call this $\mathtt{r14_s}$ -- with the return address in \ia\ code to allow for efficient returning from functions (just resetting the \ia\ program counter to $\mathtt{r14_s}$ where possible), but this was rejected as being far too complicated and error-prone. After all, in a block of code, {\it anything} can be done to the {\tt r14} register, all of which would need to be mirrored perfectly in $\mathtt{r14_s}$. Furthermore, we're really dealing with code at a lower level than function calls anyway.

Instead, whenever any sort of program-counter mapping has to be done, control is simply returned to the interpretive emulator. The method used involves the identification of four different types of flow control which can occur in a program. These are:

\begin{itemize}

\item Fixed branch inside current chunk
\item Fixed branch outside current chunk, to the start of another (already-recompiled) chunk
\item Fixed branch outside current chunk, to somewhere other than the start of another chunk
\item Arbitrary calculated jump

\end{itemize}

The first case can generate a simple branch in the phetacode. The second can generate a special ``cross-jump'' instruction to transfer control directly to the start of the destination \ia\ code. The third and fourth cases can set {\tt r15} however they like, then generate a ``program-counter-set'' instruction which will simply return control to the interpretive emulator (after dealing with pipelining issues).

This method means that generated code can't execute independently of the interpretive emulator for very long, but this might even be considered an advantage, if the emulator were extended to the level where things like emulated interrupt latency must be considered.

\subsection{How translation works}

The translation phase from \arm\ code to phetacode is fairly simple. Each \arm\ instruction in a chunk is simply taken in turn and converted into an equivalent stream of phetacode instructions, with no attempt being made at any sort of optimisation.

The layout of the translator is actually very much like that of the \arm\ instruction interpreter, the main difference being that sections of phetacode are generated instead of altering the state of the virtual machine.

\subsubsection{Backpatching}

Forward references, with respect to branches within a chunk, are dealt with using a technique called `backpatching'. A single pass over the ARM code is made, and because there isn't a one-to-one relationship between the sizes of source and target codes, addresses of generated phetacode instructions for forward-referenced ARM instructions aren't known in advance. The destination address of such phetacode branches is instead left blank, and the ARM instruction in question is tagged with a list of addresses to be `patched back' once translation reaches that point.

\subsubsection{Example conversion sequences}

% \LTXtable{\textwidth}{intexampletable.tex}

\vspace{0.3cm}

{\centering \begin{tabular}{|c|c|}
\hline
\multicolumn{2}{|c|}{Conditional (any)}\\
\hline
\hline
{\tt xxx{\it cc}}&
\( \begin{array}{rcl}
 & & \bnccfn skip\\
 & & xxx\\
skip: & & ... \\
\end{array}\)\\
\hline
\end{tabular}\par}

\vspace{0.3cm}

{\centering \begin{tabular}{|c|c|}
\hline 
\multicolumn{2}{|c|}{Simple data-processing operation}\\
\hline 
\hline 
{\tt eor r0,r1,r2}&
\( \begin{array}{rcl}
r_0 & \leftarrow & r_1 \oplus r_2\\
\end{array} \)\\
\hline 
\end{tabular}\par}

\vspace{0.3cm}

{\centering \begin{tabular}{|c|c|}
\hline 
\multicolumn{2}{|c|}{Data-processing operation with shift}\\
\hline 
\hline 
{\tt and r0,r1,r2,asl \#5}&
\( \begin{array}{rcl}
t_0 & \leftarrow  & \#5\\
t_1 & \leftarrow  & r_2 \aslfn t_0\\
r_0 & \leftarrow  & r_1 \wedge t_1\\
\end{array} \)\\
\hline 
\end{tabular}\par}

\vspace{0.3cm}

{\centering \begin{tabular}{|c|c|}
\hline 
\multicolumn{2}{|c|}{Data-processing operation with register-specified shift}\\
\hline 
\hline 
{\tt add r0,r1,r2,lsr r3}&
\( \begin{array}{rcl}
t_0 & \leftarrow & \#255\\
t_0 & \leftarrow & r_3 \wedge t_0\\
t_1 & \leftarrow & \#31\\
 & & t_0 \cmpfn\dagger\ t_1\\
 & & \bgtfn\dagger\ ldzero\\
t_1 & \leftarrow & r_2 \lsrfn t_0\\
 & & \balfn notzero\\
ldzero: t_1 & \leftarrow & \#0\\
notzero: r_0 & \leftarrow & r_1 + t_1\\
\end{array} \)\\
\hline 
\end{tabular}\par}

\vspace{0.3cm}

{\centering \begin{tabular}{|c|c|}
\hline 
\multicolumn{2}{|c|}{Data-processing operation with immediate operand}\\
\hline 
\hline 
{\tt sub r0,r1,\#5}&
\( \begin{array}{rcl}
t_1 & \leftarrow & \#5\\
r_0 & \leftarrow & r_1 - t_1\\
\end{array} \)\\
\hline 
\end{tabular}\par}

\vspace{0.3cm}

{\centering \begin{tabular}{|c|c|}
\hline 
\multicolumn{2}{|c|}{Multiply-with-accumulate}\\
\hline 
\hline 
{\tt mla r0,r1,r2,r3}&
\( \begin{array}{rcl}
t_0 & \leftarrow & r_1 * r_2\\
r_0 & \leftarrow & t_0 + r_3\\
\end{array} \)\\
\hline 
\end{tabular}\par}

\vspace{0.3cm}

{\centering \begin{tabular}{|c|c|}
\hline 
\multicolumn{2}{|c|}{Single-word load}\\
\hline 
\hline 
{\tt ldr r0,[r1,r2,asl \#2]}&
\( \begin{array}{rcl}
t_0 & \leftarrow & \#2\\
t_1 & \leftarrow & r_2 \aslfn t_0\\
t_2 & \leftarrow & r_1 + t_1\\
r_0 & \leftarrow & !t_2\\
\end{array} \)\\
\hline 
\end{tabular}\par}

\vspace{0.3cm}

{\centering \begin{tabular}{|c|c|}
\hline 
\multicolumn{2}{|c|}{Multi-word store}\\
\hline 
\hline 
{\tt stmfd r13!,\{r0,r1\}}&
\( \begin{array}{rcl}
t_0 & \leftarrow & r_{13}\\
t_1 & \leftarrow & \#4\\
!t_0 & \leftarrow & r_1\\
t_0 & \leftarrow & t_0 - t_1\\
!t_0 & \leftarrow & r_0\\
t_0 & \leftarrow & t_0 - t_1\\
r_{13} & \leftarrow & t_0\\
\end{array} \)\\
\hline 
\end{tabular}\par}

\vspace{0.3cm}

{\centering \begin{tabular}{|c|c|}
\hline 
\multicolumn{2}{|c|}{Software interrupt}\\
\hline 
\hline 
{\tt swi 0x30}&
\( \begin{array}{rcl}
 & & \swifn 0x30\\
\end{array} \)\\
\hline 
\end{tabular}\par}

\vspace{0.3cm}

{\centering \begin{tabular}{|c|c|}
\hline 
\multicolumn{2}{|c|}{Branch-table indirect (typical)}\\
\hline 
\hline 
{\tt adds pc,pc,r0,asl \#2}&
\( \begin{array}{rcl}
pc & \leftarrow & \pcrestorefn(\#0x2058,...)\\
t_0 & \leftarrow & \#2\\
t_1 & \leftarrow & r_0 \aslfn t_0\\
\mathrm{[cvnz]}\: pc & \leftarrow & pc + t_1\\
 & & \pcsetfn\\
\end{array} \)\\
\hline 
\end{tabular}\par}

\vspace{0.3cm}

\subsubsection{Conditionals}

The overbar in the conditional, $\overline{\mathtt{cc}}$, represents the opposite condition code to that in the instruction -- eg, ``less than'' rather than ``greater than or equal to''.

\subsubsection{Register shifts}

With register-specified shifts, the complexity of dealing with the peculiar bounding cases of the \arm\ instruction\footnote{For {\tt ASL}, {\tt ASR} and {\tt LSR}, only the bottom byte of the shift-amount register is used. For {\tt LSR}, shifts of greater than 31 yield a result of zero. The exact operation of each shift variant is too tedious to go into here.} are moved into the phetacode, leaving the \ia\ code generators unencumbered with the details. This brings some difficulties though -- any {\tt cmp} instructions generated here must not affect the \arm\ flags, and similarly the branch instructions immediately following must use the values of the \ia\ flags just calculated rather than the previously-cached \arm\ flags. The atomicity of the operation is exploited using special forms of comparison and branch instruction, where the comparison has its side-effect field clear, and the branch doesn't have the flag pseudo-registers embedded as implicit operands.

\section{Native code}

Although simpler than direct translation from \arm\ code, translating a chunk of phetacode into \ia\ code is quite a tricky problem. Some method was desired which was extensible (ideally table-driven in some sense), very fast, and above all that produced code which worked.

The following explanation is in kind of reversed order, describing lower-level parts of the solution first, moving upwards towards a view of the structure of the recompiler as a whole.

\subsection{Run-time assembly}

Some form of primitive assembler was required, capable of filling blocks of memory with arbitrary instruction streams\footnote{An alternative technique generating assembler source then invoking an external assembler was rejected on the grounds of efficiency.}. The implementation used works as follows: all required variants of each \ia\ instruction are defined in the program code as lists of (number of bits, value) pairs, where the value may be constant (defining opcode fields) or variable (defining registers used, addressing modes or values of immediate fields). A combination of the C macro syntax and a simple variadic function to assemble instructions suffices to allow extremely efficient output of code, with a fairly readable style at the source level.

For example, a macro to generate an instruction to add an immediate to a register looks like:

\begin{code}
\#define ADDlri 8,0x81,3,rm,3,0x0,2,0x3,32,imm
\end{code}

This defines eight bits holding the constant 0x81, followed by three bits holding the destination register {\tt rm} (the value used is the one at the point the macro is invoked), and so on. The three letters `{\tt lri}' are self-imposed mnemonics, {\tt l} standing for long operands, {\tt r} standing for a register destination operand, and {\tt i} standing for an immediate source operand. Other variants are defined, eg {\tt ADDlrr} to add a register to a register, or {\tt ADDlrm} to add a memory location to a register.

To generate an instruction to add 100 to the {\tt EAX} register, we could set up some variables, then call a function with the above macro as an `argument' to be expanded at compile time:

\begin{code}
uint5~rm~=~EAX,~imm~=~100;\\
x86asm\_out(codeblock,~ADDlri,~0);
\end{code}

\subsection{Code templates}

Templates (``rules'') are used to fit onto fragments of phetacode. Each template has an associated code-generating function, which outputs equivalent \ia\ code directly. The form of rules is discussed below.

\subsubsection{A simple rule}

The simplest kind of rule consists of an opcode (identical to the opcode used in phetacode), between zero and four register placeholders, an optional immediate value placeholder and a pointer to a code-generating function. For example, an addition operation might have a rule which looks like:

\begin{code}
ADD REGX REGY REGZ
\end{code}

Alternatively, this can be thought of as a tree-shaped fragment, as in figure \ref{addrule}.

\begin{figure}[tbh]

\centerline{\epsfbox{addrule.eps}}

\caption{\label{addrule}Example rule for addition}
\end{figure}

The placeholders {\tt REGX}, {\tt REGY}... are filled in as a particular rule is matched: they refer to strictly unique registers, so this rule can only match an \int\ code addition instruction where each of the destination and two source operands are different:

\[r_3 \leftarrow r_2 + r_4\]

In this case, {\tt REGX} will map to $r_3$, {\tt REGY} to $r_2$, {\tt REGZ} to $r_4$. The reason for doing things this way is twofold: it sidesteps problems with `bound variables', and affords an easy way of generating more efficient code in certain situations. An example of the latter:

\begin{code}
ADD REGX REGX REGY
\end{code}

corresponds neatly to the \ia\ architecture's preferred way of doing things, which forces overwriting of one source register with the destination value,

\begin{code}
addl \%ebx,\%eax
\end{code}

And an example of the former. Consider a rule involving three seperate registers, like this:

\begin{code}
SUB REGX REGY REGZ
\end{code}

Say register allocation has been done, this might generate code like this:

\begin{code}
movl \%ebx,\%eax\\
subl \%ecx,\%eax
\end{code}

However, a simple-minded code generation algorithm might {\it always} generate this {\tt mov}, {\tt sub} combination in exactly the same way, just putting the right registers in the given placeholders. But consider now that {\tt REGX} and {\tt REGZ} refer to the same register. The code produced will now look like this:

\begin{code}
movl \%ebx,\%eax\\
subl \%eax,\%eax
\end{code}

This is utterly wrong -- it will produce zero as an output, no matter what the input, which isn't what we wanted at all. The method used avoids this situation.

In preparation for the \ia\ instruction set being entirely non-orthogonal, each code generating function is written in C, allowing for as much tweaking for individual instructions as necessary. This proved to be slight overkill -- the \ia\ instruction set isn't quite so bad as it might be -- but the flexibility gained by it was found to be worthwhile nonetheless. For example, it is necessary to be able to set or unset the \ia\ carry flag at arbitrary points in a program\footnote{A barely-documented feature of some \arm\ data-processing operations is to either set or clear the carry flag, as a side-effect of using the barrel shifter to calculate the value of their immediate operand, which is stored in an encoded format}, and adding the ability to do this to the ``load constant'' function (with the carry flag as the destination register) was very easy.

\subsubsection{More complex rules}

An example of a more complex rule now: most phetacode instructions may take only register operands, although the \ia\ instructions set is capable of representing immediate values within most data-processing instructions. Phetacode deals with immediate values using a ``load-constant'' instruction, called {\tt CONST}. So, we probably want to be able to perform arithmetic using immediate constant operands directly: a rule which is capable of subtracting a constant from a register may in fact be written:

\begin{code}
SUB REGX REGX CONST REGY IMM
\end{code}

This can be viewed diagrammatically in figure \ref{subimmrule}.

\begin{figure}[tbh]

\centerline{\epsfbox{subimmrule.eps}}

\caption{\label{subimmrule}Example rule for subtraction of an immediate value}
\end{figure}

The implementation of the code generating function for this rule can now output (a single instruction of) code which directly subtracts the constant value {\tt IMM} from the register corresponding to {\tt REGX}.

\subsubsection{Storage of rules}

A singly-rooted {\it n}-ary tree structure is used to hold all the rules, which allows for very efficient incremental searching. A small part of the tree, corresponding to each of the templates used for adding, is shown in figure \ref{rulestore}.

\begin{figure}[tbh]

\centerline{\epsfbox{tree.eps}}

\caption{\label{rulestore}A cutting from the rule tree -- addition operations}
\end{figure}

\subsection{Code analysis}

Before templates can be matched, some data-flow and control-flow analysis must be done of the phetacode.

\subsubsection{Basic blocks}

Basic blocks are an important primitive in compilers, being sections of straight-line code with no possibility of internal flow disruption. The first instruction in a chunk, the destinations of any branches within a chunk and the instructions immediately following conditional branches are all tagged as being `leader' instructions, indicating that they each start a new basic block.

In the following section of code, the leaders have been marked with a diamond.
\begin{eqnarray*}
\diamond \: \mathrm{[cvnz]}\: r_0& \leftarrow & r_1 + r_2\\
 & & \blefn label\\
\diamond \: r_4 & \leftarrow & \#5\\
r_2 & \leftarrow & r_3 * r_4\\
\diamond \: label:\: r_2 & \leftarrow & r_2 \wedge r_5
\end{eqnarray*}

\subsubsection{Data flow}

Data flow analysis is done only within basic blocks. Flow information is built up as a graph, with edges describing the last time an operand register was set within the current basic block, and also the next time each register is used within that block.

In a fragment of code like the following (a translated {\tt STM} instruction), the data flow information found can be viewed as graph, like figure \ref{stmgraph} (meant to be `read' left-to-right).
\begin{eqnarray*}
t_0 & \leftarrow & r_{13}\\
t_1 & \leftarrow & \#4\\
!t_0 & \leftarrow & r_1\\
t_0 & \leftarrow & t_0 - t_1\\
!t_0 & \leftarrow & r_0\\
t_0 & \leftarrow & t_0 - t_1\\
r_{13} & \leftarrow & t_0
\end{eqnarray*}

\begin{figure}[tbh]

\centerline{\epsfbox{stmgraph.eps}}

\caption{\label{stmgraph}Data flow graph for a translated {\tt STM} instruction}
\end{figure}

\subsubsection{Control flow}

A list of possible destination addresses (numbering up to two) for each basic block is added to that block. Although this information isn't used as fully as it might be for determining where inner loops are and so on for optimisation purposes, it does help when tracking register allocation states later.

\subsection{Template matching}

The purpose of the template matching algorithm is to try and fit the fewest number of `rules' possible onto the graph representing a chunk of code. The only attempt at optimisation of any sort by the recompiler is made here, where more complex rules are favoured over simpler ones in the hope that the code they generate will be more efficient.

\subsubsection{The matching algorithm}

Intermediate code is processed one basic block at a time -- there are typically several of these per chunk. Instructions within a basic block are considered sequentially. A pointer to the current position in the rule tree is maintained (``tree pointer''), starting from the root, and moving along its branches as an instruction is matched. For each instruction:

\begin{itemize}

\item The tree pointer is followed through the operator, then operand register placeholders, filling the register placeholders with actual registers as it proceeds.
\item If an operand has a ``last-set'' pointer to a previous instruction, attempt to recursively match that rule (from the current tree pointer). If that succeeds, try to recursively match any ``next-used'' pointer for that operand register (from the root of the rule tree). If that succeeds, {\it kill} (unset) the rule pointed to by the ``last-set'' pointer for the current instruction. Mark destination registers of assimilated instructions as {\sc Hidden}.
\item If matching a rule succeeds, and this instruction doesn't already have a rule, mark the instruction as using that rule.

\end{itemize}

This algorithm can be written in pseudocode (with a couple of details omitted) as follows.

\begin{tabbing}
\keyword{Procedure} \keyword{Rulify}($location$)\\
\startblk
  \keyword{If} (\keyword{Valid}($location \rightarrow rule$))\\
  \startblk
    \keyword{Return} true\\
  \stopblk
  \keyword{Else}\\
  \startblk
    $rulefn =\ $\keyword{Match}($root$, $location$)\\
    \keyword{If} (\keyword{Valid}($rulefn$))\\
    \startblk
      $location \rightarrow rule = rulefn$\\
      \keyword{Return} true\\
    \stopblk
    \keyword{Else}\\
    \startblk
      \keyword{Return} false\\
    \stopblk
    \keyword{EndIf}\\
  \stopblk
  \keyword{EndIf}\\
\stopblk
\keyword{End}\\
\\
\keyword{Procedure} \keyword{Match}($tptr$, $location$)\\
\startblk
  \keyword{If} (\keyword{Not}(\keyword{Follow}($tptr$, $opcode$)))\\
  \startblk
    \keyword{Return} null\\
  \stopblk
  \keyword{If} (\keyword{Not}(\keyword{Follow}($tptr$, \keyword{NextUnique}($dest\_operand$))))\\
  \startblk
    \keyword{Return} null\\
  \stopblk
  \keyword{For} $operand$ \keyword{in} $src\_operands$\\
  \startblk
    \keyword{If} (\keyword{Valid}($operand$))\\
    \startblk
      $last =\ $\keyword{Lookup}($last\_set$, $operand$)\\
      $next =\ $\keyword{Lookup}($next\_used$, $operand$)\\
      \keyword{If} (\keyword{Valid}($last$) $\wedge$ \keyword{Match}($tptr$, $last$) $\wedge$ \keyword{Rulify}($next$))\\
      \startblk
        \keyword{Unset}($last \rightarrow location \rightarrow rule$)\\
      \stopblk
      \keyword{Else}\\
      \startblk
        \keyword{If} (\keyword{Not}(\keyword{Follow}($tptr$, \keyword{NextUnique}($operand$))))\\
        \startblk
          \keyword{Return} null\\
        \stopblk
      \stopblk
      \keyword{EndIf}\\
    \stopblk
    \keyword{EndIf}\\
  \stopblk
  \keyword{Next}\\
  \keyword{If} ($immediate$)\\
  \startblk
    \keyword{If} (\keyword{Not}(\keyword{Follow}($tptr$, imm)))\\
    \startblk
      \keyword{Return} null\\
    \stopblk
  \stopblk
  $rule =\ $\keyword{Lookup}($tptr$, codegen)\\
  \keyword{If} (\keyword{Not}(\keyword{Valid}($location \rightarrow rule$)))\\
  \startblk
    \keyword{Return} rule\\
  \stopblk
  \keyword{Else}\\
  \startblk
    \keyword{Return} null\\
  \stopblk
  \keyword{EndIf}\\
\stopblk
\keyword{End}
\end{tabbing}

\subsubsection{An example}

Going back to the {\tt STM} instruction example of page \pageref{stmgraph}:
\[
\begin{array}{rrcl}
\mathrm{1} & t_0 & \leftarrow & r_{13}\\
\mathrm{2} & t_1 & \leftarrow & \#4\\
\mathrm{3} & !t_0 & \leftarrow & r_1\\
\mathrm{4} & t_0 & \leftarrow & t_0 - t_1\\
\mathrm{5} & !t_0 & \leftarrow & r_0\\
\mathrm{6} & t_0 & \leftarrow & t_0 - t_1\\
\mathrm{7} & r_{13} & \leftarrow & t_0
\end{array}
\]

Instructions 1, 2 and 3 will be matched to individual code generators. When instruction 4 is encountered, it will be matched as far as the $t_0$ source operand\footnote{Instructions are matched in the order operator, destination operand, first, second, third source operand, immediate value.}, at which point a recursive call will be made back to check the `last set' instruction for $t_0$, which is number 1. No match will be found here, and matching will continue at instruction 4. When the $t_1$ source operand is encountered, the instruction at 2 will be matched successfully -- but $t_1$ is used again at instruction 6, so a check must be made that assimilating instruction 1 into instruction 4 will not cause problems.

A recursive call is now made to match instruction 6 from the root of the rule tree. $t_0$ was now last set at instruction 4 -- that rule will be matched from the current position, but will fail. $t_1$ was still last set at instruction 2 though, and matching it will succeed. As $t_1$ is not used again, this level of matching can return success.

Now that has succeeded, the instruction at 4 is free to assimilate the instruction at 2, and it does so. Now, the instruction at 2 no longer needs to have any code generated for it, so its generating rule is {\it killed}.

At the end of the operation, the rules attached to the intermediate code might be visualised as looking something like this:
\begin{eqnarray*}
t_0 & \leftarrow & r_{13}\\
!t_0 & \leftarrow & r_1\\
t_0 & \leftarrow & t_0 - (\{t_1\} \leftarrow \#4)\\
!t_0 & \leftarrow & r_0\\
t_0 & \leftarrow & t_0 - (\{t_1\} \leftarrow \#4)\\
r_{13} & \leftarrow & t_0
\end{eqnarray*}

\subsection{Code generation}

For a complete description of each phetacode instruction and corresponding \ia\ instruction sequence, see appendix B.

\subsubsection{Generating functions}

These functions, numbering around 150, generate streams of \ia\ machine code equivalent to each rule, as explained above, using the run-time assembler. A typical function might look like this:

\begin{code}
//~regx~<-~regy~*~regz\\
GENFN(mul4)\\
\{\\
~~uint5~rm~=~ARG(0);\\
~~uint5~reg~=~FORCEARG(1);\\
~~allocate\_preflags(alloc,~MOVdef|MOVundef|IMULdef|IMULundef,\\
~~~~~~~~~~~~~~~~~~~~flagsset,~native);\\
~~x86asm\_out(native,~MOVlrr,~0);\\
~~reg~=~FORCEARG(2);\\
~~x86asm\_out(native,~IMULlrr,~0);\\
~~allocate\_postflags(alloc,~mstate,~IMULdef,~flagsset,\\
~~~~~~~~~~~~~~~~~~~~~native);\\
\}
\end{code}

There is a fair amount of duplication between these functions, so C macros are used extensively to specify them concisely. Some of those used above need some explanation: {\tt GENFN} expands its argument to a standard C function declaration (using a macro led to terser code). {\tt ARG} and {\tt FORCEARG} are macros which expand to the \ia\ register equivalent of their argument number, the latter forcing that argument into a register when necessary ({\tt ARG(0)} corresponds to {\tt REGX}, etc.).

The {\tt MOVlrr} and {\tt IMULlrr} macros both expect two registers, `rm' is the destination and `reg' is the source. These names come from those used in \cite{ArtOfAsm9X}, from which parts of the instruction encoding table were taken.

{\tt allocate\_preflags} and {\tt allocate\_postflags} are functions which ensure flags are saved to memory if necessary before being corrupted, and update the state of flags afterwards respectively.

\subsection{Register allocation}

There are many more phetacode registers than available \ia\ registers -- 32 versus around 6. The \ia\ actually has eight general-purposes registers, but some are more general-purpose than others. The {\tt ESP} register really isn't much use as anything but a stack pointer, and the {\tt EBP} register is used throughout as a pointer to the memory-based register file, leaving {\tt EAX} through {\tt EDX} and the source and destination index registers {\tt ESI} and {\tt EDI} for holding the values of \arm\ registers.

The mapping between phetacode registers and \ia\ registers is held in two seperate structures. One holds information about the current location of each phetacode register (whether in memory, an \ia\ register, in a flag, etc.). The other tells which phetacode register is held in each \ia\ register. These two structures have some redundancy, so may be cross-checked with one another for debugging purposes.

To differentiate phetacode registers from \ia\ registers, somewhat in the spirit of a normal compiler, I occasionally refer to the former as `variables'. In more detail, a table holds the information for each {\it variable} shown in figure \ref{vloc}.

\begin{figure}
\begin{center}
\begin{tabular}{lc}
Field & Bits\\
\hline
Register number & 8\\
In memory-based variable file & 1\\
In \ia\ register & 1\\
In \ia\ flag & 1\\
If in \ia\ flag and inverted & 1\\
If in \ia\ register with valid contents & 1
\end{tabular}
\end{center}
\caption{\label{vloc}Variable location information}
\end{figure}

For each {\it register}, 32 bits are used as a bitmap indicating which variables are held in that register. Currently, only zero or one bits are ever set for each register in this bitmap -- future development may allow a more sophisticated register allocation scheme to delay register copies through setting more than one bit concurrently.

There are four different types of request for \ia\ register which can be made:

\begin{itemize}

\item {\sc Valid}, where the returned \ia\ register must contain the correct value
\item {\sc Invalid}, where we don't care what the value in the register is
\item {\sc Memory}, which returns either a `valid' register if that register is already allocated, or else just leaves the register in the memory-based register file
\item {\sc Hidden}, which doesn't do anything\footnote{`Hidden' allocations are made for the destination registers of assimilated instructions, which are really just placeholders in the rule syntax.}

\end{itemize}

The usual way allocation works for a typical instruction is this. The destination operand register is allocated as `invalid' -- it's about to be overwritten, so we don't care what the value is. Each source operand register is allocated using the `memory' request type. Many of the code generation functions are capable of generating instructions which access memory locations in the register file directly for source operands, but all require a physical register for destination operands. The latter point was an arbitrary design decision to simplify the code generation strategy: \ia\ machine code can't represent instructions with memory operands for both their source and destination, and always forcing the destination into a register avoids having to make a decision on a case-by-case basis.

Any code generation functions which are given an operand in memory that they require to be in a register may request that it is explicitly loaded -- the multiplication functions need to do this, for example.

\subsection{Allocation state coercion}

At the end of each basic block, certain phetacode registers will reside in certain \ia\ registers. Before processing the next basic block, certain precautions must be taken to ensure that no registers will be lost or corrupted. Each leader has a tag stating whether an ``allocation state'' exists for the corresponding basic block, and if set, also contains that allocation state. This is done as follows. 

\begin{itemize}

\item For each destination block listed for the current block, if that block has no allocation information, copy the current allocation state to the start of that block
\item If the next block to be processed has been allocated, {\it coerce} the current allocation state into that at the start of the new block

\end{itemize}

{\it Coercion} also takes place before branch instructions internal to a chunk.

The coercion function's method of operation involves storing and loading registers to the memory-based register file as necessary.

\subsection{Flag caching}

The \ia\ processor's native logic is used to calculate the values of the \arm\ processor's status flags. The mapping between \ia\ and \arm\ flags is shown in figure \ref{iaarmflags}.

\begin{figure}

\begin{center}
\begin{tabular}{llclc}
{\tt FLAGS} bit\# & \ia\ name & & \arm\ name & \\
\hline
0 & Carry flag & {\tt CF} & Carry flag & {\tt C} \\
2 & Parity flag & {\tt PF} & - & - \\
4 & Auxiliary carry flag & {\tt AF} & - & - \\
6 & Zero flag & {\tt ZF} & Zero flag & {\tt Z} \\
7 & Sign flag & {\tt SF} & Negative flag & {\tt N} \\
8 & Trap flag & {\tt TF} & - & - \\
9 & Interrupt enable flag & {\tt IF} & - & - \\
10 & Direction flag & {\tt DF} & - & - \\
11 & Overflow flag & {\tt OF} & Overflow flag & {\tt V} \\
12,13 & I/O privelege level & {\tt IOPL} & - & - \\
14 & Nested task & {\tt NT} & - & - \\

\end{tabular}
\end{center}

\caption{\label{iaarmflags}Correspondence between \ia\ and \arm\ flags}
\end{figure}

Extreme care must be taken when dealing with the correspondence between these two sets of flags. In phetacode (as in the original \arm\ code), setting flags is always optional, but not so with the \ia\ code being generated. In fact, the run-time assembler also contains information about which flags are set `correctly' (in the same manner as the \arm) and which are corrupted by each type of \ia\ instruction. Where the state of flags is undefined after an \arm\ instruction, no effort is made to ensure they are undefined {\em in the same way} after the corresponding \ia\ instruction. Code relying on undocumented side-effects of instructions may fail to execute correctly.

Before each instruction is generated, a check is made that the two sets of flag values (phetacode and \ia) will not diverge because of it. If they do, the flags are stored to a reserved location in the memory-based register file, and the `real' versions are marked as being invalid.

If a phetacode instruction requires a particular flag to be valid before its execution, that flag is named as one of its source operands (for example, all branch instructions have the flags which the condition is based upon embedded within them). Before the \ia\ code for that instruction is generated, the relevant \ia\ flags are restored to the last-known valid \arm\ equivalents.

\subsubsection{Flag store code sequence}

In the register file, each of the \arm/phetacode {\tt C}, {\tt V}, {\tt N} and {\tt Z} flags are stored as byte-wide quantities. This allows the \ia\ {\tt set{\it n}} instructions to be used for storing individual flags on demand. In 26-bit addressing mode on a real \arm\ processor (and during the course of interpretive emulation), the flag bits are embedded within spare bits in the program counter register, but performing bit operations on that register in generated code would require many \ia\ instructions, so it isn't done. Instead, the flags must be `unpacked' from the register {\tt r15} before native code is invoked (and sometimes when {\tt r15} is used as a destination operand), and repacked when control is returned to the interpreter (and when {\tt r15} is used as a source operand).

\subsubsection{Flag restore code sequence}

The sequence of code used for restoring flags is slightly unfortunate -- the \ia\ architecture provides no easy way of setting a flag to the contents of a memory location. In fact, the only way of even accessing all the necessary bits of the {\tt EFLAGS} register is using the {\tt PUSHF} and {\tt POPF} stack-based instructions. This leads to rather verbose (hence bulky and slow) flag-restore code, for example this example restores just two of the four flags:

\begin{code}
pushf\\
popl~~~\%eax\\
andl~~~\$0xfffff77f,\%eax\\
movzbl~0x43(\%ebp),\%ebx\\
shll~~~\$0x7,\%ebx\\
orl~~~~\%ebx,\%eax\\
movzbl~0x41(\%ebp),\%ebx\\
shll~~~\$0xb,\%ebx\\
orl~~~~\%ebx,\%eax\\
pushl~~\%eax\\
popf
\end{code}

There is a possible way around needing to use code like this, but it would require significant changes to the recompiler -- see the next chapter for details.

\subsubsection{The carry {\it vs} borrow problem}

Looking at the exact definitions of the \arm\ instruction {\tt SBC} and the \ia\ instruction {\tt SBB} should arouse suspicion that things are not as straightforward as they seem in the correspondence between \ia\ and \arm\ flags. The \arm\ {\tt SBC} instruction is defined to perform the operation:

\begin{code}
rd = rm - rn - $\overline{\mathtt{carry}}$
\end{code}

whereas the \ia\ {\tt SBB} instruction is defined as:

\begin{code}
rd -= rm - carry
\end{code}

Notice how the \arm\ uses the {\em inverse} of the carry flag, whereas the \ia\ uses the carry flag (as a `borrow') directly. At first, I assumed this was a typo -- but in fact, in all subtraction operations, the \ia\ processor uses the carry in the {\it opposite sense} to the \arm. (Note here that subtraction operations also include comparisons using {\tt CMP}). Of course, certain corresponding condition codes depending on the carry flag also expect it to have the inverse value on the two architectures.

This seems like a fairly nasty problem, but in fact it's not catastrophic since the \ia\ also provides an instruction to invert the carry flag, {\tt CMC}. The recompiler hence tracks when the carry flag is valid but inverted, and inserts {\tt CMC} operations in the necessary places in generated code.

\subsection{Code interfaces}

\subsubsection{Recompiled code invocation glue}

Transferring control to sections of recompiled code required the use of GCC's inline assembler. Care had to be taken over ensuring the state of all necessary registers over the call remained valid throughout the switchover between the two execution environments, hence the explicit preservation of the {\tt EBP} register which isn't done by GCC by default.

\begin{code}
asm("pushl~\%\%ebp\bq n\bq t"~\bq \\
~~~~"movl~\%0,\%\%ebp\bq n\bq t"~\bq \\
~~~~"call~*\%1\bq n\bq t"~\bq \\
~~~~"popl~\%\%ebp"\\
~~:~/*~no~outputs~*/\\
~~:~"a"~(reg),~"b"~(code->base)\\
~~:~"cx",~"dx",~"si",~"di");
\end{code}

\subsubsection{C code invocation glue}

At various points in recompiled code, it was found to be necessary to make subroutine calls back to functions in the original compiled C program. Shortage of available documentation necessitated perusal of the GCC source to discover the function-calling conventions used, as great care had to be taken that the state of the calling code was not corrupted by implicit assumtions the compiled C code was making.

It was found that all function arguments are passed on the stack, but functions may corrupt the {\tt EAX}, {\tt ECX} and {\tt EDX} registers -- other registers are preserved. It is left up to the caller of the function to fix up the {\tt ESP} register after function calls to discard the values previously pushed onto the stack as arguments. With this knowledge, it was possible to write a function to output the code sequence necessary to call back to C functions in recompiled code.

\section{Overall structure}

An overview of the way the sections of code described above fit together are mapped neatly in figure \ref{structure}.

\begin{figure}[tbh]

\centerline{\epsfbox{structure.eps}}

\caption{\label{structure}Overall structure of the project}
\end{figure}
